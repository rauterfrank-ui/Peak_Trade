#!/usr/bin/env python3
"""
Run the Promotion Loop v0: build promotion candidates from config patches,
apply governance filters, and materialize live promotion proposals.

Usage:
    # Manual-only mode (only generate proposals, no auto-apply)
    python scripts/run_promotion_proposal_cycle.py --auto-apply-mode manual_only

    # Bounded auto-apply mode (proposals + live overrides within bounds)
    python scripts/run_promotion_proposal_cycle.py --auto-apply-mode bounded_auto

    # Disabled mode (no proposals, no auto-apply)
    python scripts/run_promotion_proposal_cycle.py --auto-apply-mode disabled
"""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import List

from src.governance.promotion_loop import (
    build_promotion_candidates_from_patches,
    build_promotion_proposals,
    check_global_promotion_lock,
    filter_candidates_for_live,
    load_safety_config_from_toml,
    materialize_promotion_proposals,
)
from src.governance.promotion_loop.engine import apply_proposals_to_live_overrides
from src.governance.promotion_loop.models import DecisionStatus
from src.governance.promotion_loop.policy import AutoApplyBounds, AutoApplyPolicy
from src.meta.learning_loop.models import ConfigPatch


def parse_args() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description=(
            "Run the Promotion Loop v0: build promotion candidates from config patches, "
            "apply governance filters, and materialize live promotion proposals."
        )
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path("reports/live_promotion"),
        help="Directory where promotion proposals will be written.",
    )
    parser.add_argument(
        "--live-overrides-path",
        type=Path,
        default=Path("config/live_overrides/auto.toml"),
        help="Path to the live overrides TOML file for bounded auto-apply.",
    )
    parser.add_argument(
        "--auto-apply-mode",
        type=str,
        default="manual_only",
        choices=["disabled", "manual_only", "bounded_auto"],
        help="Auto-apply mode for live promotion.",
    )
    return parser.parse_args()


def _load_patches_for_promotion() -> List[ConfigPatch]:
    """
    Load ConfigPatch objects that are candidates for live promotion.

    v1 implementation: Load from JSON file generated by Learning Loop or demo script.

    Returns:
        List of ConfigPatch objects with APPLIED_OFFLINE or PROMOTED status
    """
    import json
    from datetime import datetime
    from pathlib import Path as P
    from src.meta.learning_loop.models import PatchStatus

    # Try to load from demo patches (for testing)
    demo_path = P("reports/learning_snippets/demo_patches_for_promotion.json")

    if not demo_path.exists():
        print(f"[promotion_loop] Warning: No patches found at {demo_path}")
        print(
            "[promotion_loop] Generate demo patches with: python scripts/generate_demo_patches_for_promotion.py"
        )
        return []

    with demo_path.open("r", encoding="utf-8") as f:
        patches_data = json.load(f)

    patches = []
    for patch_dict in patches_data:
        # Convert ISO strings back to datetime
        if patch_dict.get("generated_at"):
            patch_dict["generated_at"] = datetime.fromisoformat(patch_dict["generated_at"])
        if patch_dict.get("applied_at"):
            patch_dict["applied_at"] = (
                datetime.fromisoformat(patch_dict["applied_at"])
                if patch_dict["applied_at"]
                else None
            )
        if patch_dict.get("promoted_at"):
            patch_dict["promoted_at"] = (
                datetime.fromisoformat(patch_dict["promoted_at"])
                if patch_dict["promoted_at"]
                else None
            )

        # Convert status string back to PatchStatus enum
        if isinstance(patch_dict.get("status"), str):
            patch_dict["status"] = PatchStatus(patch_dict["status"])

        patches.append(ConfigPatch(**patch_dict))

    print(f"[promotion_loop] Loaded {len(patches)} patches from {demo_path}")
    return patches


def main() -> None:
    """Main entry point for the promotion proposal cycle."""
    args = parse_args()

    # Load safety config (P0/P1 features)
    config_path = Path("config/promotion_loop_config.toml")
    safety_config = load_safety_config_from_toml(config_path)
    print(f"[promotion_loop] Loaded safety config from {config_path}")

    # Check global promotion lock (P1)
    lock_warning = check_global_promotion_lock(safety_config)
    if lock_warning:
        print(f"[promotion_loop] {lock_warning}")
        if args.auto_apply_mode == "bounded_auto":
            print("[promotion_loop] Forcing mode to manual_only due to global lock.")
            args.auto_apply_mode = "manual_only"

    print("[promotion_loop] Loading patches for promotion...")
    patches = _load_patches_for_promotion()
    print(f"[promotion_loop] Loaded {len(patches)} patch(es).")

    candidates = build_promotion_candidates_from_patches(patches)
    print(f"[promotion_loop] Built {len(candidates)} promotion candidate(s).")

    # Demo mode: Mark candidates with high confidence as eligible for live
    # In production, this would be done by policy or operator review
    for candidate in candidates:
        confidence = candidate.patch.confidence_score
        if confidence and confidence >= 0.75:
            candidate.eligible_for_live = True
            print(
                f"[promotion_loop] Marked {candidate.patch.id} as eligible_for_live (confidence: {confidence:.2f})"
            )
        else:
            conf_str = f"{confidence:.2f}" if confidence else "N/A"
            print(
                f"[promotion_loop] Rejected {candidate.patch.id} due to low confidence ({conf_str})"
            )

    # Apply P0/P1 safety filters
    decisions = filter_candidates_for_live(
        candidates,
        safety_config=safety_config,
        mode=args.auto_apply_mode,
    )
    accepted = [d for d in decisions if d.status is DecisionStatus.ACCEPTED_FOR_PROPOSAL]

    print(f"[promotion_loop] Accepted candidates: {len(accepted)}")
    print(f"[promotion_loop] Rejected candidates: {len(decisions) - len(accepted)}")

    # Show P0 violations if any
    p0_violations = [
        d for d in decisions if any(f.startswith("P0_") for f in d.candidate.safety_flags)
    ]
    if p0_violations:
        print(
            f"[promotion_loop] WARNING: {len(p0_violations)} candidates have P0 safety violations"
        )

    proposals = build_promotion_proposals(decisions)
    if not proposals:
        print("[promotion_loop] No proposals generated.")
        return

    written = materialize_promotion_proposals(proposals, args.output_dir)
    print(
        f"[promotion_loop] Written {len(written)} proposal artifact file(s) to {args.output_dir}."
    )

    # Auto-Apply
    policy = AutoApplyPolicy(
        mode=args.auto_apply_mode,
        leverage_bounds=AutoApplyBounds(min_value=1.0, max_value=2.0, max_step=0.25),
        trigger_delay_bounds=AutoApplyBounds(min_value=3.0, max_value=15.0, max_step=2.0),
        macro_weight_bounds=AutoApplyBounds(min_value=0.0, max_value=0.8, max_step=0.1),
    )

    live_path = apply_proposals_to_live_overrides(
        proposals,
        policy=policy,
        live_override_path=args.live_overrides_path,
    )
    if live_path is None:
        print(f"[promotion_loop] Auto-apply: no changes applied (mode={args.auto_apply_mode!r}).")
    else:
        print(f"[promotion_loop] Auto-apply: written live overrides to {live_path}")


if __name__ == "__main__":
    main()
