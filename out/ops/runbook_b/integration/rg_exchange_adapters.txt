src/ai_orchestration/l2_runner.py:24:from .model_client import ModelClient, ModelRequest, create_model_client
src/ai_orchestration/l2_runner.py:159:        # Create model client
src/ai_orchestration/l2_runner.py:160:        client = create_model_client(mode=mode, transcript=transcript)
src/ai_orchestration/l2_runner.py:164:            client=client,
src/ai_orchestration/l2_runner.py:171:            client=client,
src/ai_orchestration/l2_runner.py:260:        self, client: ModelClient, model_id: str, prompt: Optional[str] = None
src/ai_orchestration/l2_runner.py:282:        response = client.complete(request)
src/ai_orchestration/l2_runner.py:306:        self, client: ModelClient, model_id: str, proposer_output: str
src/ai_orchestration/l2_runner.py:327:        response = client.complete(request)
src/experiments/armstrong_elkaroui_combi_experiment.py:596:        from src.data.kraken import fetch_ohlcv_df
src/data/kraken_cache_loader.py:15:    from src.data.kraken_cache_loader import (
src/data/kraken_cache_loader.py:17:        load_kraken_cache_window,
src/data/kraken_cache_loader.py:25:    df, health = load_kraken_cache_window(
src/data/kraken_cache_loader.py:120:            "test_base_path": "tests/data/kraken_smoke",
src/data/kraken_cache_loader.py:137:        "test_base_path": rms.get("test_base_path", "tests/data/kraken_smoke"),
src/data/kraken_cache_loader.py:181:def load_kraken_cache_window(
src/data/kraken_cache_loader.py:359:    _, health = load_kraken_cache_window(
src/experiments/base.py:678:            from src.data.kraken import fetch_ohlcv_df
src/experiments/base.py:691:                kraken_symbol = symbol.replace("-", "/")
src/experiments/base.py:709:                    symbol=kraken_symbol,
src/ai_orchestration/l4_critic.py:35:from .model_client import ModelClient, ModelRequest, create_model_client
src/ai_orchestration/l4_critic.py:296:        # Create model client
src/ai_orchestration/l4_critic.py:297:        client = create_model_client(
src/ai_orchestration/l4_critic.py:320:        response = client.complete(request)
src/data/exchange_client.py:5:Dieses Modul darf ccxt NICHT importieren.
src/data/exchange_client.py:18:        mod = importlib.import_module("src.data.providers.resilient_ccxt_exchange_client")
src/data/exchange_client.py:22:            "Optional dependency missing while loading resilient ccxt exchange client.\n\n"
src/data/exchange_client.py:23:            "This feature depends on 'ccxt'. Install it (or the project's optional extra) and retry.\n\n"
src/data/exchange_client.py:25:            "  pip install ccxt\n"
src/data/exchange_client.py:26:            '  pip install -e ".[kraken]"\n'
src/data/exchange_client.py:32:    def __init__(self, exchange_id: str = "kraken", config: Optional[Dict[str, Any]] = None):
src/data/exchange_client.py:34:        self._impl = impl_cls(exchange_id=exchange_id, config=config)
src/webui/execution_watch_api_v0_2.py:181:    from prometheus_client import Counter as _PromCounter  # type: ignore
src/webui/execution_watch_api_v0_2.py:182:    from prometheus_client import Histogram as _PromHistogram  # type: ignore
src/ai_orchestration/evidence_pack_generator.py:19:from .model_client import ModelResponse
src/governance/policy_critic/critic.py:192:        execution_files = [f for f in changed_files if "execution" in f or "exchange" in f]
src/orders/base.py:40:        client_id: Optionale Client-ID fuer Tracking
src/orders/base.py:49:    client_id: Optional[str] = None
src/governance/policy_critic/README.md:34:- **WARN**: Other changes in `src/execution/`, `src/exchange/`, `src/live/`
src/governance/policy_critic/README.md:129:- `src/exchange/**`
src/docs/Peak_Trade_0_trades_debug_summary.md:69:- `src/data/kraken.py`
src/experiments/live_session_registry.py:41:    ...     env_name="kraken_futures_testnet",
src/experiments/live_session_registry.py:105:        env_name: Environment-Name (z.B. "kraken_futures_testnet")
src/experiments/live_session_registry.py:122:        ...     env_name="kraken_futures_testnet",
src/experiments/live_session_registry.py:253:        ...     env_name="kraken_testnet",
src/governance/policy_critic/rules.py:145:        "src/exchange/",
src/governance/policy_critic/rules.py:273:        "src/exchange/",
src/governance/policy_critic/rules.py:282:        "src/exchange/",
src/orders/mappers.py:73:                  client_order_id, extra, strategy_key, run_name, signal_as_of, comment
src/orders/mappers.py:116:    client_id = getattr(live_req, "client_order_id", None)
src/orders/mappers.py:117:    if not client_id:
src/orders/mappers.py:118:        client_id = f"order_{uuid.uuid4().hex[:8]}"
src/orders/mappers.py:150:        client_id=client_id,
src/orders/mappers.py:160:    - client_order_id, symbol, side, order_type, quantity, notional,
src/orders/mappers.py:235:    client_id = row.get("client_order_id")
src/orders/mappers.py:236:    if not client_id or str(client_id) == "nan":
src/orders/mappers.py:237:        client_id = f"order_{uuid.uuid4().hex[:8]}"
src/orders/mappers.py:239:        client_id = str(client_id)
src/orders/mappers.py:282:        client_id=client_id,
src/docs/Peak_Trade_OVERVIEW.md:35:│  │  └─ kraken.py          # OHLCV-Fetch + Caching
src/docs/Peak_Trade_OVERVIEW.md:53:### 3.1 `src/data/kraken.py`
src/docs/Peak_Trade_OVERVIEW.md:57:- Verbindung zur **Kraken-API** (meistens REST über `requests` oder `ccxt`)
src/docs/Peak_Trade_OVERVIEW.md:147:1. Laden der OHLCV-Daten über `kraken.py`
src/docs/Peak_Trade_OVERVIEW.md:199:> „Das ist für mein **Peak_Trade**-Projekt. Wir haben ein Python-Backtesting-Framework mit Modulen `kraken.py`, `ma_crossover.py`, `backtest/engine.py`, `backtest/stats.py` und einem Runner-Skript `run_ma_realistic.py`. Bitte berücksichtige, dass es um Krypto-Backtests (v. a. Kraken) geht.“
src/data/lake/__init__.py:3:from .client import LakeClient
src/docs/Peak_Trade_Projektuebersicht.md:43:│  ├─ demo_kraken_simple.py
src/docs/Peak_Trade_Projektuebersicht.md:86:  - neue Data-Pipeline (`src/data/kraken_pipeline.py`)
src/docs/Peak_Trade_Projektuebersicht.md:87:  - neue Demo-Skripte (`demo_complete_pipeline.py`, `demo_kraken_simple.py`)
src/live/risk_limits.py:880:            >>> monitor = LivePortfolioMonitor(exchange_client, risk_limits)
src/autonomous/monitors.py:120:    def is_market_hours(self, exchange: str = "kraken") -> bool:
src/autonomous/monitors.py:125:            exchange: Exchange name
src/ai_orchestration/transcript_store.py:16:from .model_client import ModelRequest, ModelResponse
src/exchange/base.py:1:# src/exchange/base.py
src/exchange/base.py:107:    - `CcxtExchangeClient`: Konkrete Implementierung mit ccxt
src/exchange/base.py:110:        >>> client: ExchangeClient = CcxtExchangeClient("kraken")
src/exchange/base.py:111:        >>> ticker = client.fetch_ticker("BTC/EUR")
src/exchange/base.py:117:        Name/ID des Exchanges (z.B. 'kraken', 'binance').
src/exchange/base.py:235:        exchange_order_id: ID der Order auf der Exchange
src/exchange/base.py:244:    exchange_order_id: str
src/exchange/base.py:270:        >>> client: TradingExchangeClient = DummyExchangeClient(prices={"BTC/EUR": 50000})
src/exchange/base.py:271:        >>> order_id = client.place_order(
src/exchange/base.py:277:        >>> status = client.get_order_status(order_id)
src/exchange/base.py:286:        Name/ID des Exchanges (z.B. 'dummy', 'kraken_testnet').
src/exchange/base.py:300:        client_order_id: Optional[str] = None,
src/exchange/base.py:311:            client_order_id: Optionale Client-seitige ID für Tracking
src/exchange/base.py:322:    def cancel_order(self, exchange_order_id: str) -> bool:
src/exchange/base.py:327:            exchange_order_id: Die Exchange-Order-ID
src/exchange/base.py:337:    def get_order_status(self, exchange_order_id: str) -> ExchangeOrderResult:
src/exchange/base.py:342:            exchange_order_id: Die Exchange-Order-ID
src/orders/testnet_executor.py:52:    from src.exchange.kraken_testnet import KrakenTestnetClient
src/orders/testnet_executor.py:107:        exchange_order_id: ID der Order auf der Exchange
src/orders/testnet_executor.py:116:    exchange_order_id: Optional[str] = None
src/orders/testnet_executor.py:149:        >>> from src.exchange.kraken_testnet import KrakenTestnetClient, KrakenTestnetConfig
src/orders/testnet_executor.py:156:        >>> client = KrakenTestnetClient(KrakenTestnetConfig())
src/orders/testnet_executor.py:159:        ...     exchange_client=client,
src/orders/testnet_executor.py:168:        exchange_client: "KrakenTestnetClient",
src/orders/testnet_executor.py:177:            exchange_client: KrakenTestnetClient fuer API-Calls
src/orders/testnet_executor.py:185:        self._client = exchange_client
src/orders/testnet_executor.py:267:                client_order_id=order.client_id or f"testnet_{self._execution_count}",
src/orders/testnet_executor.py:349:            exchange_order_id = self._client.create_order(order)
src/orders/testnet_executor.py:351:            logger.info(f"[TESTNET EXECUTOR] Order gesendet: exchange_order_id={exchange_order_id}")
src/orders/testnet_executor.py:354:            if exchange_order_id == "VALIDATED":
src/orders/testnet_executor.py:373:                        "exchange_order_id": exchange_order_id,
src/orders/testnet_executor.py:380:                fill = self._client.fetch_order_as_fill(exchange_order_id, order)
src/orders/testnet_executor.py:397:                        "exchange_order_id": exchange_order_id,
src/orders/testnet_executor.py:402:            self._log_execution(order, result, now, exchange_order_id=exchange_order_id)
src/orders/testnet_executor.py:411:                reason=f"exchange_error: {e}",
src/orders/testnet_executor.py:477:        exchange_order_id: Optional[str] = None,
src/orders/testnet_executor.py:486:            exchange_order_id=exchange_order_id,
src/orders/testnet_executor.py:548:    exchange_client: Optional["KrakenTestnetClient"] = None,
src/orders/testnet_executor.py:556:        exchange_client: Optionaler KrakenTestnetClient (sonst neu erstellt)
src/orders/testnet_executor.py:574:    from src.exchange.kraken_testnet import (
src/orders/testnet_executor.py:576:        create_kraken_testnet_client_from_config,
src/orders/testnet_executor.py:586:    if exchange_client is None:
src/orders/testnet_executor.py:587:        exchange_client = create_kraken_testnet_client_from_config(cfg)
src/orders/testnet_executor.py:595:        exchange_client=exchange_client,
src/exchange/protocols.py:6:- Keep the "core" type surface importable without optional deps (e.g. ccxt)
src/exchange/protocols.py:8:- Provider implementations (e.g. ccxt-backed) can implement these protocols.
src/exchange/protocols.py:11:- This module must not import pandas/ccxt.
src/exchange/ccxt_client.py:1:# src/exchange/ccxt_client.py
src/exchange/ccxt_client.py:5:Read-only Exchange-Client basierend auf ccxt.
src/exchange/ccxt_client.py:7:Dieses Modul implementiert das `ExchangeClient`-Protokoll mit ccxt als Backend.
src/exchange/ccxt_client.py:11:    Alle von ccxt unterstützten Exchanges (140+), z.B.:
src/exchange/ccxt_client.py:12:    - kraken
src/exchange/ccxt_client.py:18:    >>> client = CcxtExchangeClient("kraken")
src/exchange/ccxt_client.py:19:    >>> ticker = client.fetch_ticker("BTC/EUR")
src/exchange/ccxt_client.py:23:    >>> client = CcxtExchangeClient(
src/exchange/ccxt_client.py:24:    ...     "kraken",
src/exchange/ccxt_client.py:29:    >>> balance = client.fetch_balance()
src/exchange/ccxt_client.py:44:    Lazy-load der ccxt-Implementierung aus dem Provider-Modul.
src/exchange/ccxt_client.py:45:    Dadurch bleibt dieses Modul ohne ccxt importierbar.
src/exchange/ccxt_client.py:50:        mod = importlib.import_module("src.data.providers.ccxt_exchange_client")
src/exchange/ccxt_client.py:55:            "Optional dependency missing while loading ccxt exchange client.\n\n"
src/exchange/ccxt_client.py:56:            "This feature depends on 'ccxt'. Install it (or the project's optional extra) and retry.\n\n"
src/exchange/ccxt_client.py:58:            "  pip install ccxt\n"
src/exchange/ccxt_client.py:59:            '  pip install -e ".[kraken]"\n'
src/exchange/ccxt_client.py:68:    Wichtig: importiert ccxt NICHT beim Import dieses Moduls.
src/exchange/ccxt_client.py:74:        exchange_id: str,
src/exchange/ccxt_client.py:84:            exchange_id=exchange_id,
src/exchange/ccxt_client.py:93:    def exchange(self) -> Any:
src/exchange/ccxt_client.py:94:        return getattr(self._impl, "exchange")
src/exchange/ccxt_client.py:99:    # Protocol compatibility (dependency-free protocol in src/exchange/protocols.py)
src/exchange/ccxt_client.py:132:_shim_exchange_client_typecheck: ExchangeClientProtocol | None = None
src/orders/exchange.py:1:# src/orders/exchange.py
src/orders/exchange.py:319:        # exchange_client: Any = None,
src/orders/exchange.py:418:            f"(Phase 71 – no real exchange call, design only)"
src/orders/exchange.py:525:    from src.exchange.base import TradingExchangeClient, ExchangeOrderResult
src/orders/exchange.py:548:        >>> from src.exchange.dummy_client import DummyExchangeClient
src/orders/exchange.py:549:        >>> client = DummyExchangeClient(simulated_prices={"BTC/EUR": 50000})
src/orders/exchange.py:550:        >>> executor = ExchangeOrderExecutor(safety_guard=guard, trading_client=client)
src/orders/exchange.py:558:        trading_client: Optional["TradingExchangeClient"] = None,
src/orders/exchange.py:566:            trading_client: Optionaler TradingExchangeClient für echte Order-Aufrufe
src/orders/exchange.py:571:        self._trading_client = trading_client
src/orders/exchange.py:580:        self._use_trading_client = trading_client is not None
src/orders/exchange.py:584:            f"TradingClient={trading_client.get_name()}" if self._use_trading_client else "Dry-Run"
src/orders/exchange.py:591:        return not self._use_trading_client
src/orders/exchange.py:594:    def trading_client(self) -> Optional["TradingExchangeClient"]:
src/orders/exchange.py:596:        return self._trading_client
src/orders/exchange.py:624:        if env == TradingEnvironment.PAPER and not self._use_trading_client:
src/orders/exchange.py:641:        if self._use_trading_client and self._trading_client is not None:
src/orders/exchange.py:642:            return self._execute_via_trading_client(order)
src/orders/exchange.py:669:    def _execute_via_trading_client(self, order: OrderRequest) -> OrderExecutionResult:
src/orders/exchange.py:679:        from src.exchange.base import ExchangeOrderStatus
src/orders/exchange.py:681:        assert self._trading_client is not None
src/orders/exchange.py:684:        client_name = self._trading_client.get_name()
src/orders/exchange.py:687:            f"[EXCHANGE EXECUTOR] Order via {client_name}: "
src/orders/exchange.py:693:            exchange_order_id = self._trading_client.place_order(
src/orders/exchange.py:699:                client_order_id=order.client_id,
src/orders/exchange.py:703:            exchange_result = self._trading_client.get_order_status(exchange_order_id)
src/orders/exchange.py:706:            return self._map_exchange_result_to_execution_result(
src/orders/exchange.py:708:                exchange_order_id=exchange_order_id,
src/orders/exchange.py:709:                exchange_result=exchange_result,
src/orders/exchange.py:710:                client_name=client_name,
src/orders/exchange.py:715:            logger.error(f"[EXCHANGE EXECUTOR] Order fehlgeschlagen via {client_name}: {e}")
src/orders/exchange.py:720:                reason=f"trading_client_error: {e}",
src/orders/exchange.py:723:                    "mode": f"trading_client_{client_name}",
src/orders/exchange.py:729:    def _map_exchange_result_to_execution_result(
src/orders/exchange.py:732:        exchange_order_id: str,
src/orders/exchange.py:733:        exchange_result: "ExchangeOrderResult",
src/orders/exchange.py:734:        client_name: str,
src/orders/exchange.py:742:            exchange_order_id: ID der Order auf der Exchange
src/orders/exchange.py:743:            exchange_result: Ergebnis vom TradingExchangeClient
src/orders/exchange.py:744:            client_name: Name des Clients
src/orders/exchange.py:750:        from src.exchange.base import ExchangeOrderStatus
src/orders/exchange.py:764:        mapped_status = status_mapping.get(exchange_result.status, "rejected")
src/orders/exchange.py:768:        if exchange_result.filled_qty > 0 and exchange_result.avg_price is not None:
src/orders/exchange.py:772:                quantity=exchange_result.filled_qty,
src/orders/exchange.py:773:                price=exchange_result.avg_price,
src/orders/exchange.py:775:                fee=exchange_result.fee,
src/orders/exchange.py:776:                fee_currency=exchange_result.fee_currency,
src/orders/exchange.py:786:                else f"status_{exchange_result.status.value}"
src/orders/exchange.py:790:                "mode": f"trading_client_{client_name}",
src/orders/exchange.py:791:                "exchange_order_id": exchange_order_id,
src/orders/exchange.py:792:                "exchange_status": exchange_result.status.value,
src/orders/exchange.py:793:                "client_name": client_name,
src/orders/exchange.py:834:        from src.exchange import build_trading_client_from_config
src/orders/exchange.py:843:        trading_client = build_trading_client_from_config(cfg)
src/orders/exchange.py:847:            trading_client=trading_client,
src/orders/exchange.py:863:    trading_client: Optional["TradingExchangeClient"] = None,
src/orders/exchange.py:877:        4. Mit trading_client → ExchangeOrderExecutor (kann echte Calls machen)
src/orders/exchange.py:882:        trading_client: Optionaler TradingExchangeClient für echte Order-Aufrufe
src/orders/exchange.py:922:    if trading_client is not None:
src/orders/exchange.py:925:            f"({trading_client.get_name()}) für {env.value}-Modus"
src/orders/exchange.py:930:            trading_client=trading_client,
src/orders/__init__.py:22:         >>> from src.orders.exchange import TestnetOrderExecutor
src/orders/__init__.py:48:# Direkter Import: from src.orders.exchange import TestnetOrderExecutor, ...
src/orders/__init__.py:65:    _exchange_exports = {
src/orders/__init__.py:71:    if name in _exchange_exports:
src/orders/__init__.py:72:        from . import exchange
src/orders/__init__.py:74:        return getattr(exchange, name)
src/exchange/dummy_client.py:1:# src/exchange/dummy_client.py
src/exchange/dummy_client.py:17:    >>> client = DummyExchangeClient(
src/exchange/dummy_client.py:22:    >>> order_id = client.place_order("BTC/EUR", "buy", 0.01, "market")
src/exchange/dummy_client.py:23:    >>> status = client.get_order_status(order_id)
src/exchange/dummy_client.py:62:        client_order_id: Client-seitige ID
src/exchange/dummy_client.py:77:    client_order_id: Optional[str] = None
src/exchange/dummy_client.py:108:        >>> client = DummyExchangeClient(
src/exchange/dummy_client.py:112:        >>> order_id = client.place_order("BTC/EUR", "buy", 0.01, "market")
src/exchange/dummy_client.py:113:        >>> assert client.get_order_status(order_id).status == ExchangeOrderStatus.FILLED
src/exchange/dummy_client.py:165:        client_order_id: Optional[str] = None,
src/exchange/dummy_client.py:179:            client_order_id: Optionale Client-ID
src/exchange/dummy_client.py:209:            client_order_id=client_order_id,
src/exchange/dummy_client.py:232:    def cancel_order(self, exchange_order_id: str) -> bool:
src/exchange/dummy_client.py:237:            exchange_order_id: Die Order-ID
src/exchange/dummy_client.py:242:        order = self._orders.get(exchange_order_id)
src/exchange/dummy_client.py:245:            logger.warning(f"[DUMMY EXCHANGE] Order nicht gefunden: {exchange_order_id}")
src/exchange/dummy_client.py:252:                f"{exchange_order_id} (Status: {order.status})"
src/exchange/dummy_client.py:259:        logger.info(f"[DUMMY EXCHANGE] Order storniert: {exchange_order_id}")
src/exchange/dummy_client.py:262:    def get_order_status(self, exchange_order_id: str) -> ExchangeOrderResult:
src/exchange/dummy_client.py:267:            exchange_order_id: Die Order-ID
src/exchange/dummy_client.py:275:        order = self._orders.get(exchange_order_id)
src/exchange/dummy_client.py:278:            raise ValueError(f"Order nicht gefunden: {exchange_order_id}")
src/exchange/dummy_client.py:281:            exchange_order_id=order.order_id,
src/exchange/dummy_client.py:293:                "client_order_id": order.client_order_id,
src/docs/trading_bot_notes.md:85:- **Börsen‑Anbindung:** `ccxt` (für Krypto) oder spezifische Broker‑SDKs  
src/data/lake/client.py:14:    Minimal DuckDB-backed client for local, read-only friendly analytics.
src/data/lake/client.py:17:    - This client is used by OTel instrumentation tests under `tests/obs/test_otel.py`.
src/ai_orchestration/__init__.py:50:from .model_client import (
src/ai_orchestration/__init__.py:57:    create_model_client,
src/ai_orchestration/__init__.py:103:    "create_model_client",
src/data/kraken.py:7:- ccxt-basierte Kraken-Integration
src/data/kraken.py:24:def get_kraken_client() -> Any:
src/data/kraken.py:29:        Konfigurierter Kraken-Client (ccxt Exchange Objekt)
src/data/kraken.py:34:    # Lazy: ccxt wird erst im Provider-Backend importiert.
src/data/kraken.py:35:    from .providers.kraken_ccxt_backend import KrakenCcxtBackend
src/data/kraken.py:38:    return backend._exchange()
src/data/kraken.py:107:        from .providers.kraken_ccxt_backend import KrakenCcxtBackend
src/data/kraken.py:147:        # Best-effort Mapping ohne ccxt Import: anhand Klassennamen
src/data/kraken.py:152:                hint="Check your internet connection and verify Kraken API status at status.kraken.com",
src/data/kraken_live.py:1:# src/data/kraken_live.py
src/data/kraken_live.py:92:def _symbol_to_kraken(symbol: str) -> str:
src/data/kraken_live.py:160:        name: Exchange-Name (z.B. "kraken")
src/data/kraken_live.py:168:    name: str = "kraken"
src/data/kraken_live.py:170:    base_url: str = "https://api.kraken.com"
src/data/kraken_live.py:269:        base_url: str = "https://api.kraken.com",
src/data/kraken_live.py:292:        self.kraken_symbol = _symbol_to_kraken(symbol)
src/data/kraken_live.py:312:            f"[KRAKEN LIVE] Initialisiert: symbol={symbol} ({self.kraken_symbol}), "
src/data/kraken_live.py:342:            "pair": self.kraken_symbol,
src/data/kraken_live.py:672:def create_kraken_source_from_config(
src/data/kraken_live.py:674:    exchange_cfg: LiveExchangeConfig,
src/data/kraken_live.py:681:        exchange_cfg: Exchange Config
src/data/kraken_live.py:689:        base_url=exchange_cfg.base_url,
src/data/kraken_live.py:691:        max_retries=exchange_cfg.max_retries,
src/data/kraken_live.py:692:        retry_delay=exchange_cfg.retry_delay_seconds,
src/data/kraken_live.py:693:        rate_limit_ms=exchange_cfg.rate_limit_ms,
src/data/kraken_live.py:721:def load_live_exchange_config(cfg: Any) -> LiveExchangeConfig:
src/data/kraken_live.py:732:        name=cfg.get("live_exchange.name", "kraken"),
src/data/kraken_live.py:733:        use_sandbox=cfg.get("live_exchange.use_sandbox", True),
src/data/kraken_live.py:734:        base_url=cfg.get("live_exchange.base_url", "https://api.kraken.com"),
src/data/kraken_live.py:735:        rate_limit_ms=cfg.get("live_exchange.rate_limit_ms", 1000),
src/data/kraken_live.py:736:        max_retries=cfg.get("live_exchange.max_retries", 3),
src/data/kraken_live.py:737:        retry_delay_seconds=cfg.get("live_exchange.retry_delay_seconds", 5.0),
src/exchange/kraken_testnet.py:1:# src/exchange/kraken_testnet.py
src/exchange/kraken_testnet.py:23:- Kraken REST API: https://docs.kraken.com/api/
src/exchange/kraken_testnet.py:109:    base_url: str = "https://api.kraken.com"
src/exchange/kraken_testnet.py:205:def to_kraken_symbol(symbol: str) -> str:
src/exchange/kraken_testnet.py:230:def from_kraken_symbol(kraken_symbol: str) -> str:
src/exchange/kraken_testnet.py:235:        kraken_symbol: Kraken-Symbol (z.B. "XXBTZEUR")
src/exchange/kraken_testnet.py:240:    if kraken_symbol in KRAKEN_TO_SYMBOL:
src/exchange/kraken_testnet.py:241:        return KRAKEN_TO_SYMBOL[kraken_symbol]
src/exchange/kraken_testnet.py:244:    return kraken_symbol
src/exchange/kraken_testnet.py:274:        >>> client = KrakenTestnetClient(config)
src/exchange/kraken_testnet.py:276:        >>> txid = client.create_order(order)
src/exchange/kraken_testnet.py:520:        kraken_symbol = to_kraken_symbol(order.symbol)
src/exchange/kraken_testnet.py:527:            "pair": kraken_symbol,
src/exchange/kraken_testnet.py:543:        if order.client_id:
src/exchange/kraken_testnet.py:545:            # Wir hashen die client_id zu einem Integer
src/exchange/kraken_testnet.py:546:            userref = abs(hash(order.client_id)) % (2**31)
src/exchange/kraken_testnet.py:579:    def fetch_order_status(self, exchange_order_id: str) -> KrakenOrderStatus:
src/exchange/kraken_testnet.py:584:            exchange_order_id: Die Transaction-ID (txid) der Order
src/exchange/kraken_testnet.py:593:        if exchange_order_id == "VALIDATED":
src/exchange/kraken_testnet.py:603:        logger.debug(f"[KRAKEN TESTNET] fetch_order_status: txid={exchange_order_id}")
src/exchange/kraken_testnet.py:605:        data = {"txid": exchange_order_id}
src/exchange/kraken_testnet.py:610:            if exchange_order_id not in result:
src/exchange/kraken_testnet.py:612:                    f"Order not found: {exchange_order_id}",
src/exchange/kraken_testnet.py:616:            order_data = result[exchange_order_id]
src/exchange/kraken_testnet.py:626:                txid=exchange_order_id,
src/exchange/kraken_testnet.py:642:        self, exchange_order_id: str, original_order: OrderRequest
src/exchange/kraken_testnet.py:648:            exchange_order_id: Die Transaction-ID (txid) der Order
src/exchange/kraken_testnet.py:654:        status = self.fetch_order_status(exchange_order_id)
src/exchange/kraken_testnet.py:673:    def cancel_order(self, exchange_order_id: str) -> bool:
src/exchange/kraken_testnet.py:678:            exchange_order_id: Die Transaction-ID (txid) der Order
src/exchange/kraken_testnet.py:686:        if exchange_order_id == "VALIDATED":
src/exchange/kraken_testnet.py:690:        logger.info(f"[KRAKEN TESTNET] cancel_order: txid={exchange_order_id}")
src/exchange/kraken_testnet.py:692:        data = {"txid": exchange_order_id}
src/exchange/kraken_testnet.py:723:        kraken_symbol = to_kraken_symbol(symbol)
src/exchange/kraken_testnet.py:724:        result = self._make_public_request("/0/public/Ticker", {"pair": kraken_symbol})
src/exchange/kraken_testnet.py:776:def create_kraken_testnet_client_from_config(
src/exchange/kraken_testnet.py:778:    config_prefix: str = "exchange.kraken_testnet",
src/exchange/kraken_testnet.py:785:        config_prefix: Config-Pfad-Prefix (default: "exchange.kraken_testnet")
src/exchange/kraken_testnet.py:793:        >>> client = create_kraken_testnet_client_from_config(cfg)
src/exchange/kraken_testnet.py:798:        base_url=cfg.get(f"{config_prefix}.base_url", "https://api.kraken.com"),
src/docs/architecture.md:42:│  │  └─ kraken.py                  (Datenzugriff via ccxt, Caching)
src/docs/architecture.md:91:**`kraken.py`**
src/docs/architecture.md:93:- Stellt `get_kraken_client()` bereit:
src/docs/architecture.md:94:  - baut einen ccxt-Kraken-Client basierend auf `Settings.exchange`
src/live/portfolio_monitor.py:23:    monitor = LivePortfolioMonitor(exchange_client)
src/live/portfolio_monitor.py:137:        _exchange_client: Exchange-Client oder Broker-Client
src/live/portfolio_monitor.py:143:        exchange_client: BaseBrokerClient,
src/live/portfolio_monitor.py:150:            exchange_client: Exchange-Client oder Broker-Client
src/live/portfolio_monitor.py:153:        self._exchange_client = exchange_client
src/live/portfolio_monitor.py:158:        Liest aktuelle Positions- und ggf. Account-Daten vom exchange_client
src/live/portfolio_monitor.py:200:            if hasattr(self._exchange_client, "fetch_positions"):
src/live/portfolio_monitor.py:201:                df = self._exchange_client.fetch_positions()
src/live/portfolio_monitor.py:209:            if hasattr(self._exchange_client, "positions"):
src/live/portfolio_monitor.py:210:                positions_dict = self._exchange_client.positions
src/live/portfolio_monitor.py:341:            if hasattr(self._exchange_client, "fetch_balance"):
src/live/portfolio_monitor.py:342:                balance = self._exchange_client.fetch_balance()
src/live/portfolio_monitor.py:354:            if hasattr(self._exchange_client, "cash"):
src/live/portfolio_monitor.py:355:                cash = self._exchange_client.cash
src/ai_orchestration/model_client.py:25:    """Model client error."""
src/ai_orchestration/model_client.py:89:    """Abstract model client interface."""
src/ai_orchestration/model_client.py:109:        """Check if client is available."""
src/ai_orchestration/model_client.py:115:    Replay client (offline, no network).
src/ai_orchestration/model_client.py:122:        Initialize replay client.
src/ai_orchestration/model_client.py:143:                f"Replay client: No transcript found for prompt_hash={prompt_hash}. "
src/ai_orchestration/model_client.py:153:            raise ModelClientError("Replay client: No choices in transcript response")
src/ai_orchestration/model_client.py:182:        """Replay client is always available (offline)."""
src/ai_orchestration/model_client.py:188:    OpenAI client (real API calls).
src/ai_orchestration/model_client.py:195:        Initialize OpenAI client.
src/ai_orchestration/model_client.py:215:            self.client = openai.OpenAI(api_key=self.api_key)
src/ai_orchestration/model_client.py:223:            response = self.client.chat.completions.create(
src/ai_orchestration/model_client.py:302:def create_model_client(mode: str, transcript: Optional[Dict[str, Any]] = None) -> ModelClient:
src/ai_orchestration/model_client.py:304:    Factory function to create model client.
src/risk_layer/kill_switch/health_check.py:85:        self.require_exchange = config.get("require_exchange_connection", True)
src/risk_layer/kill_switch/health_check.py:126:        # Check exchange connection
src/risk_layer/kill_switch/health_check.py:127:        if self.require_exchange:
src/risk_layer/kill_switch/health_check.py:128:            exchange_ok = context.get("exchange_connected", False)
src/risk_layer/kill_switch/health_check.py:129:            metadata["exchange_connected"] = exchange_ok
src/risk_layer/kill_switch/health_check.py:131:            if exchange_ok:
src/data/backend.py:176:# Do NOT import provider modules at import time (e.g. Kraken via ccxt).
src/data/backend.py:179:    "kraken_ccxt": ("src.data.providers.kraken_ccxt_backend", "KrakenCcxtBackend"),
src/data/backend.py:185:    Lazy factory for provider backends (e.g. kraken_ccxt).
src/data/backend.py:189:    performs an operation that needs it (e.g. KrakenCcxtBackend._exchange()).
src/ai_orchestration/l1_runner.py:25:from .model_client import ModelClient, ModelRequest, create_model_client
src/ai_orchestration/l1_runner.py:163:        # Create model client
src/ai_orchestration/l1_runner.py:164:        client = create_model_client(mode=mode, transcript=transcript)
src/ai_orchestration/l1_runner.py:168:            client=client,
src/ai_orchestration/l1_runner.py:175:            client=client,
src/ai_orchestration/l1_runner.py:264:    def _run_proposer(self, client: ModelClient, model_id: str, question: str) -> ProposerArtifact:
src/ai_orchestration/l1_runner.py:289:        response = client.complete(request)
src/ai_orchestration/l1_runner.py:314:        self, client: ModelClient, model_id: str, proposer_output: str
src/ai_orchestration/l1_runner.py:343:        response = client.complete(request)
src/risk_layer/kill_switch/cli.py:183:        "exchange_connected": True,  # TODO: Get from actual system
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:23:├─ ccxt                  # Kraken-API
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:60:│  │  └─ kraken.py                     # OHLCV-Fetch + Parquet-Cache
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:225:### 3. src/data/kraken.py
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:230:import ccxt
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:234:def get_kraken_client() -> ccxt.kraken:
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:237:    return ccxt.kraken({
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:270:- Kraken-API-Integration (ccxt)
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:457:python scripts/run_ma_realistic.py --source kraken:BTC/USD:1h:720
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:622:- src/data/kraken.py – OHLCV-Daten + Caching
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:629:Python, Pandas, ccxt, Pydantic, Parquet-Caching
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:657:- `src/data/kraken.py` – Daten-Integration
src/live/shadow_session.py:22:    >>> from src.data.kraken_live import KrakenLiveCandleSource
src/live/shadow_session.py:60:from ..data.kraken_live import (
src/live/shadow_session.py:178:        ...     exchange_cfg=exchange_cfg,
src/live/shadow_session.py:179:        ...     data_source=kraken_source,
src/live/shadow_session.py:192:        exchange_cfg: LiveExchangeConfig,
src/live/shadow_session.py:206:            exchange_cfg: Exchange Config
src/live/shadow_session.py:226:        self._exchange_cfg = exchange_cfg
src/live/shadow_session.py:576:                client_order_id=order.client_id or f"shadow_{i}_{time.time_ns()}",
src/live/shadow_session.py:798:    from ..data.kraken_live import (
src/live/shadow_session.py:800:        load_live_exchange_config,
src/live/shadow_session.py:801:        create_kraken_source_from_config,
src/live/shadow_session.py:810:    exchange_cfg = load_live_exchange_config(cfg)
src/live/shadow_session.py:816:        data_source = create_kraken_source_from_config(shadow_cfg, exchange_cfg)
src/live/shadow_session.py:870:        exchange_cfg=exchange_cfg,
src/data/shadow/tick_normalizer.py:17:def parse_kraken_trade_message(msg: Any) -> list[Tick]:
src/data/shadow/tick_normalizer.py:79:                    source="kraken_ws",
src/data/shadow/tick_normalizer.py:107:        ticks = parse_kraken_trade_message(msg)
src/live/orders.py:27:    client_order_id: str
src/live/orders.py:52:    client_order_id: str
src/live/orders.py:64:    "client_order_id",
src/live/orders.py:151:                client_order_id=str(row.get("client_order_id")),
src/exchange/__init__.py:1:# src/exchange/__init__.py
src/exchange/__init__.py:22:    from src.exchange import build_exchange_client_from_config
src/exchange/__init__.py:23:    client = build_exchange_client_from_config(cfg)
src/exchange/__init__.py:24:    ticker = client.fetch_ticker("BTC/EUR")
src/exchange/__init__.py:27:    from src.exchange import build_trading_client_from_config
src/exchange/__init__.py:28:    trading_client = build_trading_client_from_config(cfg)
src/exchange/__init__.py:29:    order_id = trading_client.place_order("BTC/EUR", "buy", 0.01, "market")
src/exchange/__init__.py:44:from .ccxt_client import CcxtExchangeClient
src/exchange/__init__.py:54:    "build_exchange_client_from_config",
src/exchange/__init__.py:61:    "build_trading_client_from_config",
src/exchange/__init__.py:65:def build_exchange_client_from_config(cfg) -> ExchangeClientProtocol:
src/exchange/__init__.py:78:        >>> client = build_exchange_client_from_config(cfg)
src/exchange/__init__.py:79:        >>> ticker = client.fetch_ticker("BTC/EUR")
src/exchange/__init__.py:81:    exchange_id = cfg.get("exchange.id", "kraken")
src/exchange/__init__.py:82:    sandbox = cfg.get("exchange.sandbox", True)
src/exchange/__init__.py:83:    enable_rate_limit = cfg.get("exchange.enable_rate_limit", True)
src/exchange/__init__.py:85:    api_key = cfg.get("exchange.credentials.api_key", "") or None
src/exchange/__init__.py:86:    secret = cfg.get("exchange.credentials.secret", "") or None
src/exchange/__init__.py:96:    timeout = cfg.get("exchange.options.timeout")
src/exchange/__init__.py:99:    verbose = cfg.get("exchange.options.verbose", False)
src/exchange/__init__.py:104:        exchange_id=exchange_id,
src/exchange/__init__.py:113:def build_trading_client_from_config(cfg) -> TradingExchangeClient:
src/exchange/__init__.py:117:    Liest [exchange].default_type aus der Config und erstellt den
src/exchange/__init__.py:120:    - "kraken_testnet": KrakenTestnetClient (echte Testnet-API)
src/exchange/__init__.py:131:        >>> client = build_trading_client_from_config(cfg)
src/exchange/__init__.py:132:        >>> order_id = client.place_order("BTC/EUR", "buy", 0.01, "market")
src/exchange/__init__.py:134:    default_type = cfg.get("exchange.default_type", "dummy")
src/exchange/__init__.py:137:        from .dummy_client import DummyExchangeClient
src/exchange/__init__.py:141:            "BTC/EUR": cfg.get("exchange.dummy.btc_eur_price", 50000.0),
src/exchange/__init__.py:142:            "ETH/EUR": cfg.get("exchange.dummy.eth_eur_price", 3000.0),
src/exchange/__init__.py:143:            "BTC/USD": cfg.get("exchange.dummy.btc_usd_price", 55000.0),
src/exchange/__init__.py:145:        fee_bps = cfg.get("exchange.dummy.fee_bps", 10.0)
src/exchange/__init__.py:146:        slippage_bps = cfg.get("exchange.dummy.slippage_bps", 5.0)
src/exchange/__init__.py:154:    elif default_type == "kraken_testnet":
src/exchange/__init__.py:155:        from .kraken_testnet import create_kraken_testnet_client_from_config
src/exchange/__init__.py:157:        return create_kraken_testnet_client_from_config(cfg)
src/exchange/__init__.py:161:            f"Unbekannter exchange.default_type: {default_type!r}. "
src/exchange/__init__.py:162:            f"Verfügbar: 'dummy', 'kraken_testnet'"
src/reporting/live_status_report.py:84:    exchange_ok = data.health.get("exchange_ok", False)
src/reporting/live_status_report.py:85:    exchange_status = "OK" if exchange_ok else "FAIL"
src/reporting/live_status_report.py:86:    exchange_details = (
src/reporting/live_status_report.py:87:        "Exchange verbunden" if exchange_ok else ", ".join(data.health.get("exchange_errors", []))
src/reporting/live_status_report.py:89:    lines.append(f"| exchange | {exchange_status} | {exchange_details} |")
src/reporting/live_status_report.py:292:    exchange_ok = data.health.get("exchange_ok", False)
src/reporting/live_status_report.py:293:    exchange_status = "OK" if exchange_ok else "FAIL"
src/reporting/live_status_report.py:294:    exchange_details = (
src/reporting/live_status_report.py:295:        "Exchange verbunden" if exchange_ok else ", ".join(data.health.get("exchange_errors", []))
src/reporting/live_status_report.py:298:        f"      <tr><td>exchange</td><td>{exchange_status}</td><td>{exchange_details}</td></tr>"
src/docs/Peak_Trade_setup_notes.md:12:- Datenmodul `src/data/kraken.py` lädt OHLCV-Daten via **ccxt** in ein `pandas.DataFrame`.
src/docs/Peak_Trade_setup_notes.md:31:    │   └── kraken.py
src/docs/Peak_Trade_setup_notes.md:55:pip install tomli ccxt pandas numpy backtrader cvxpy matplotlib python-dotenv
src/docs/Peak_Trade_setup_notes.md:84:[exchange]
src/docs/Peak_Trade_setup_notes.md:85:name = "kraken"
src/docs/Peak_Trade_setup_notes.md:108:  - Parsen der Sektionen `[risk]`, `[backtest]`, `[exchange]`, `[[strategies]]`
src/docs/Peak_Trade_setup_notes.md:110:  - Funktion `get_exchange_credentials()` → holt API-Key/Secret aus Environment
src/docs/Peak_Trade_setup_notes.md:190:        supported = ["kraken", "binance"]
src/docs/Peak_Trade_setup_notes.md:218:        self.exchange = self._parse_exchange()
src/docs/Peak_Trade_setup_notes.md:255:    def _parse_exchange(self) -> ExchangeConfig:
src/docs/Peak_Trade_setup_notes.md:256:        data = self._raw_config.get("exchange", {})
src/docs/Peak_Trade_setup_notes.md:258:            name=data.get("name", "kraken"),
src/docs/Peak_Trade_setup_notes.md:286:    def get_exchange_credentials(self) -> tuple[str, str]:
src/docs/Peak_Trade_setup_notes.md:287:        key = os.getenv(self.exchange.api_key_env)
src/docs/Peak_Trade_setup_notes.md:288:        secret = os.getenv(self.exchange.api_secret_env)
src/docs/Peak_Trade_setup_notes.md:291:                f"API-Credentials nicht gesetzt. Bitte {self.exchange.api_key_env} und "
src/docs/Peak_Trade_setup_notes.md:292:                f"{self.exchange.api_secret_env} im Environment setzen."
src/docs/Peak_Trade_setup_notes.md:305:        if not self.exchange.testnet:
src/docs/Peak_Trade_setup_notes.md:332:        print(f"  Name: {cfg.exchange.name}")
src/docs/Peak_Trade_setup_notes.md:333:        print(f"  Testnet: {cfg.exchange.testnet}")
src/docs/Peak_Trade_setup_notes.md:338:            key, _ = cfg.get_exchange_credentials()
src/docs/Peak_Trade_setup_notes.md:386:## 7. `src/data/kraken.py` – OHLCV-Daten holen
src/docs/Peak_Trade_setup_notes.md:392:import ccxt
src/docs/Peak_Trade_setup_notes.md:398:def get_kraken_client() -> ccxt.kraken:
src/docs/Peak_Trade_setup_notes.md:404:        "rateLimit": cfg.exchange.rate_limit_ms,
src/docs/Peak_Trade_setup_notes.md:409:        api_key, api_secret = cfg.get_exchange_credentials()
src/docs/Peak_Trade_setup_notes.md:415:    exchange = ccxt.kraken(options)
src/docs/Peak_Trade_setup_notes.md:417:    if cfg.exchange.testnet and hasattr(exchange, "set_sandbox_mode"):
src/docs/Peak_Trade_setup_notes.md:418:        exchange.set_sandbox_mode(True)
src/docs/Peak_Trade_setup_notes.md:420:    return exchange
src/docs/Peak_Trade_setup_notes.md:430:    exchange = get_kraken_client()
src/docs/Peak_Trade_setup_notes.md:433:        ohlcv = exchange.fetch_ohlcv(
src/docs/Peak_Trade_setup_notes.md:439:    except ccxt.BaseError as e:
src/docs/Peak_Trade_setup_notes.md:485:python -m src.data.kraken BTC/EUR 1h
src/data/shadow/models.py:23:        source: Datenquelle (default: "kraken_ws")
src/data/shadow/models.py:30:    source: str = "kraken_ws"
src/execution/audit_log.py:32:    - Query by client_order_id, event_type, time range
src/execution/audit_log.py:69:    def get_entries_for_order(self, client_order_id: str) -> List[LedgerEntry]:
src/execution/audit_log.py:74:            client_order_id: Client order ID
src/execution/audit_log.py:79:        return [e for e in self._entries if e.client_order_id == client_order_id]
src/execution/audit_log.py:158:            client_order_id="",
src/execution/audit_log.py:183:                client_order_id=diff.client_order_id,
src/data/providers/ccxt_exchange_client.py:2:ccxt Exchange Client (Provider Module)
src/data/providers/ccxt_exchange_client.py:5:Dieses Modul ist absichtlich unter src/data/providers/ platziert, damit ccxt
src/data/providers/ccxt_exchange_client.py:15:import ccxt
src/data/providers/ccxt_exchange_client.py:18:from src.exchange.base import Balance, Ticker
src/data/providers/ccxt_exchange_client.py:23:    Read-only ccxt-basierter Exchange-Client (Provider-Implementierung).
src/data/providers/ccxt_exchange_client.py:25:    Diese Klasse entspricht der bisherigen API aus `src.exchange.ccxt_client`.
src/data/providers/ccxt_exchange_client.py:30:        exchange_id: str,
src/data/providers/ccxt_exchange_client.py:38:        if not hasattr(ccxt, exchange_id):
src/data/providers/ccxt_exchange_client.py:39:            available = [x for x in dir(ccxt) if not x.startswith("_") and x.islower()]
src/data/providers/ccxt_exchange_client.py:41:                f"Unknown ccxt exchange id: {exchange_id!r}. "
src/data/providers/ccxt_exchange_client.py:45:        klass = getattr(ccxt, exchange_id)
src/data/providers/ccxt_exchange_client.py:50:        self._exchange: ccxt.Exchange = klass(config)
src/data/providers/ccxt_exchange_client.py:53:            self._exchange.apiKey = api_key
src/data/providers/ccxt_exchange_client.py:55:            self._exchange.secret = secret
src/data/providers/ccxt_exchange_client.py:59:                if hasattr(self._exchange, "set_sandbox_mode"):
src/data/providers/ccxt_exchange_client.py:60:                    self._exchange.set_sandbox_mode(True)
src/data/providers/ccxt_exchange_client.py:64:        # ccxt types are not available/stable across versions; keep runtime behavior, relax typing.
src/data/providers/ccxt_exchange_client.py:65:        setattr(self._exchange, "checkRequiredCredentials", False)
src/data/providers/ccxt_exchange_client.py:68:    def exchange(self) -> ccxt.Exchange:
src/data/providers/ccxt_exchange_client.py:69:        return self._exchange
src/data/providers/ccxt_exchange_client.py:72:        return str(self._exchange.id)
src/data/providers/ccxt_exchange_client.py:75:        """Load markets via ccxt (may hit network depending on ccxt cache)."""
src/data/providers/ccxt_exchange_client.py:76:        return self._exchange.load_markets()
src/data/providers/ccxt_exchange_client.py:79:        raw = self._exchange.fetch_ticker(symbol)
src/data/providers/ccxt_exchange_client.py:96:        ohlcv = self._exchange.fetch_ohlcv(
src/data/providers/ccxt_exchange_client.py:118:        raw = self._exchange.fetch_balance()
src/data/providers/ccxt_exchange_client.py:134:            return self._exchange.fetch_open_orders(symbol)
src/data/providers/ccxt_exchange_client.py:135:        return self._exchange.fetch_open_orders()
src/data/providers/ccxt_exchange_client.py:138:        return self._exchange.fetch_markets()
src/data/providers/ccxt_exchange_client.py:141:        return list(self._exchange.timeframes.keys()) if self._exchange.timeframes else []
src/data/providers/ccxt_exchange_client.py:144:        has_key = "with API-Key" if self._exchange.apiKey else "no API-Key"
src/data/providers/ccxt_exchange_client.py:145:        return f"<CcxtExchangeClient({self._exchange.id}, {has_key})>"
src/data/feeds/live_feed.py:4:WebSocket feed client with:
src/data/feeds/live_feed.py:23:from src.data.shadow.tick_normalizer import parse_kraken_trade_message
src/data/feeds/live_feed.py:45:        exchange: Exchange name (e.g., "kraken")
src/data/feeds/live_feed.py:54:    exchange: str = "kraken"
src/data/feeds/live_feed.py:103:        >>> client = LiveFeedClient(config)
src/data/feeds/live_feed.py:104:        >>> client.on_tick = lambda tick: print(f"Tick: {tick}")
src/data/feeds/live_feed.py:105:        >>> client.connect()
src/data/feeds/live_feed.py:106:        >>> # ... client.disconnect()
src/data/feeds/live_feed.py:138:        logger.info(f"Connecting to {self.config.exchange} feed (symbols: {self.config.symbols})")
src/data/feeds/live_feed.py:205:            self.metrics.record_reconnect(labels={"exchange": self.config.exchange})
src/data/feeds/live_feed.py:249:        ticks = parse_kraken_trade_message(message)
src/live/broker_base.py:64:                    client_order_id=order.client_order_id,
src/live/broker_base.py:307:                    "client_order_id": order.client_order_id,
src/live/broker_base.py:316:                    client_order_id=order.client_order_id,
src/live/broker_base.py:401:                    "client_order_id",
src/meta/infostream/run_cycle.py:128:def create_ai_client() -> Optional[Any]:
src/meta/infostream/run_cycle.py:142:    - SAFETY: persist full evidence locally (out/ops); outbound via model_client redaction only.
src/meta/infostream/run_cycle.py:154:        from src.ai_orchestration.model_client import create_model_client
src/meta/infostream/run_cycle.py:156:        client = create_model_client("live")
src/meta/infostream/run_cycle.py:158:        return client
src/meta/infostream/run_cycle.py:183:        - call_ai_for_event(event, client) aufrufen
src/meta/infostream/run_cycle.py:264:        client = create_ai_client()
src/meta/infostream/run_cycle.py:266:        if client is None:
src/meta/infostream/run_cycle.py:282:                    intel_eval, learning = call_ai_for_event(event, client)
src/strategies/diagnostics.py:52:DataSource = Literal["synthetic", "kraken_cache"]
src/strategies/diagnostics.py:63:        data_source: Datenquelle ("synthetic" oder "kraken_cache")
src/strategies/diagnostics.py:250:def load_kraken_cache_ohlcv(
src/strategies/diagnostics.py:372:        data_source: "synthetic" oder "kraken_cache"
src/strategies/diagnostics.py:383:        - KrakenDataHealth: Health-Report (nur bei kraken_cache, sonst None)
src/strategies/diagnostics.py:394:    elif data_source == "kraken_cache":
src/strategies/diagnostics.py:396:        from src.data.kraken_cache_loader import (
src/strategies/diagnostics.py:397:            load_kraken_cache_window,
src/strategies/diagnostics.py:406:        test_base_path = Path(rms_cfg.get("test_base_path", "tests/data/kraken_smoke"))
src/strategies/diagnostics.py:414:        df, health = load_kraken_cache_window(
src/strategies/diagnostics.py:431:            f"Unbekannte Datenquelle: '{data_source}'. Erlaubt: 'synthetic', 'kraken_cache'"
src/strategies/diagnostics.py:450:        data_source: Datenquelle ("synthetic" oder "kraken_cache")
src/strategies/diagnostics.py:592:        data_source: Datenquelle ("synthetic" oder "kraken_cache")
src/strategies/diagnostics.py:600:        - data_source="kraken_cache": Echte Daten aus lokalem Kraken-Cache
src/strategies/diagnostics.py:602:        - Bei kraken_cache werden Data-Health-Felder gefuellt (Phase 79)
src/strategies/diagnostics.py:660:    # Health-Info extrahieren (fuer kraken_cache)
src/market_sentinel/v0_daily_outlook.py:740:        from src.ai_orchestration.model_client import create_model_client, ModelRequest
src/market_sentinel/v0_daily_outlook.py:742:        client = create_model_client("live")
src/market_sentinel/v0_daily_outlook.py:749:        response = client.complete(request)
src/risk_layer/kill_switch/triggers/base.py:79:                    "exchange_connected": True,
src/docs/Peak_Trade_Data_Layer_Doku.md:39:│     └─ kraken.py             # (bereits vorher vorhanden, Kraken-spezifisch)
src/docs/Peak_Trade_Data_Layer_Doku.md:68:from .kraken import get_kraken_client, fetch_ohlcv_df, clear_cache
src/docs/Peak_Trade_Data_Layer_Doku.md:75:    "get_kraken_client",
src/docs/Peak_Trade_Data_Layer_Doku.md:312:   - Kraken-Client (`src/data/kraken.py`) mit dem neuen Data-Layer verheiraten,
src/live/alert_manager.py:84:            source: Quelle des Alerts (z.B. "monitoring", "risk", "exchange")
src/meta/infostream/evaluator.py:11:    from src.ai_orchestration.model_client import create_model_client
src/meta/infostream/evaluator.py:13:    client = create_model_client("live")
src/meta/infostream/evaluator.py:14:    intel_eval, learning = call_ai_for_event(event, client)
src/meta/infostream/evaluator.py:398:    client: Any,
src/meta/infostream/evaluator.py:408:    client : Any
src/meta/infostream/evaluator.py:420:    ModelClient aus ai_orchestration (client.complete(ModelRequest(...))).
src/meta/infostream/evaluator.py:434:        from src.ai_orchestration.model_client import ModelRequest
src/meta/infostream/evaluator.py:443:        resp = client.complete(req)
src/data/providers/kraken_ccxt_backend.py:10:        f"This backend depends on 'ccxt' (Kraken via ccxt).\n"
src/data/providers/kraken_ccxt_backend.py:11:        f"Install ccxt (or the project's optional extra that includes ccxt) and retry.\n\n"
src/data/providers/kraken_ccxt_backend.py:13:        f"  pip install ccxt\n"
src/data/providers/kraken_ccxt_backend.py:15:        f'  pip install -e ".[<extra-that-includes-ccxt>]"\n'
src/data/providers/kraken_ccxt_backend.py:30:    Read-only Kraken OHLCV Backend via ccxt.
src/data/providers/kraken_ccxt_backend.py:33:    - importierbar ohne ccxt (lazy import in _exchange())
src/data/providers/kraken_ccxt_backend.py:44:        self._exchange_instance: Any | None = None
src/data/providers/kraken_ccxt_backend.py:46:    def _exchange(self) -> Any:
src/data/providers/kraken_ccxt_backend.py:48:        Erstellt (lazy) eine ccxt.kraken Instanz.
src/data/providers/kraken_ccxt_backend.py:50:        if self._exchange_instance is not None:
src/data/providers/kraken_ccxt_backend.py:51:            return self._exchange_instance
src/data/providers/kraken_ccxt_backend.py:56:            ccxt = importlib.import_module("ccxt")
src/data/providers/kraken_ccxt_backend.py:69:        ex = ccxt.kraken(cfg)  # pyright: ignore[reportArgumentType]
src/data/providers/kraken_ccxt_backend.py:78:        self._exchange_instance = ex
src/data/providers/kraken_ccxt_backend.py:93:        ex = self._exchange()
src/data/providers/kraken_ccxt_backend.py:95:        # ccxt signature: fetch_ohlcv(symbol, timeframe='1m', since=None, limit=None, params={})
src/risk_layer/kill_switch/triggers/external.py:3:Triggers based on external system state (exchange connection, network, etc.).
src/risk_layer/kill_switch/triggers/external.py:55:                - exchange_connected: bool
src/risk_layer/kill_switch/triggers/external.py:82:        # Check exchange connection
src/risk_layer/kill_switch/triggers/external.py:83:        exchange_connected = context.get("exchange_connected", True)
src/risk_layer/kill_switch/triggers/external.py:84:        metadata["exchange_connected"] = exchange_connected
src/risk_layer/kill_switch/triggers/external.py:86:        if not exchange_connected:
src/data/providers/__init__.py:5:Provider-Implementierungen (z.B. Kraken über ccxt), die optionalen Dependencies
src/data/providers/__init__.py:14:from .kraken_ccxt_backend import KrakenCcxtBackend
src/data/__init__.py:7:# Do NOT import optional provider modules (e.g. kraken -> ccxt) at import time.
src/data/__init__.py:16:    # Kraken / ccxt (optional)
src/data/__init__.py:17:    "get_kraken_client",
src/data/__init__.py:21:    "fetch_kraken_data",
src/data/__init__.py:22:    "test_kraken_connection",
src/data/__init__.py:29:    "load_live_exchange_config",
src/data/__init__.py:30:    "create_kraken_source_from_config",
src/data/__init__.py:32:    "load_kraken_cache_window",
src/data/__init__.py:36:    # Core data utilities (non-ccxt, but still lazy to keep src.data import light)
src/data/__init__.py:50:    # Kraken provider (+ pipelines) -> may depend on ccxt
src/data/__init__.py:51:    "get_kraken_client": ("src.data.kraken", "get_kraken_client"),
src/data/__init__.py:52:    "fetch_ohlcv_df": ("src.data.kraken", "fetch_ohlcv_df"),
src/data/__init__.py:53:    "clear_cache": ("src.data.kraken", "clear_cache"),
src/data/__init__.py:54:    "KrakenDataPipeline": ("src.data.kraken_pipeline", "KrakenDataPipeline"),
src/data/__init__.py:55:    "fetch_kraken_data": ("src.data.kraken_pipeline", "fetch_kraken_data"),
src/data/__init__.py:56:    "test_kraken_connection": ("src.data.kraken_pipeline", "test_kraken_connection"),
src/data/__init__.py:57:    "KrakenLiveCandleSource": ("src.data.kraken_live", "KrakenLiveCandleSource"),
src/data/__init__.py:58:    "FakeCandleSource": ("src.data.kraken_live", "FakeCandleSource"),
src/data/__init__.py:59:    "LiveCandle": ("src.data.kraken_live", "LiveCandle"),
src/data/__init__.py:60:    "ShadowPaperConfig": ("src.data.kraken_live", "ShadowPaperConfig"),
src/data/__init__.py:61:    "LiveExchangeConfig": ("src.data.kraken_live", "LiveExchangeConfig"),
src/data/__init__.py:62:    "load_shadow_paper_config": ("src.data.kraken_live", "load_shadow_paper_config"),
src/data/__init__.py:63:    "load_live_exchange_config": ("src.data.kraken_live", "load_live_exchange_config"),
src/data/__init__.py:64:    "create_kraken_source_from_config": (
src/data/__init__.py:65:        "src.data.kraken_live",
src/data/__init__.py:66:        "create_kraken_source_from_config",
src/data/__init__.py:68:    "KrakenDataHealth": ("src.data.kraken_cache_loader", "KrakenDataHealth"),
src/data/__init__.py:69:    "load_kraken_cache_window": ("src.data.kraken_cache_loader", "load_kraken_cache_window"),
src/data/__init__.py:70:    "check_data_health_only": ("src.data.kraken_cache_loader", "check_data_health_only"),
src/data/__init__.py:72:        "src.data.kraken_cache_loader",
src/data/__init__.py:75:    "list_available_cache_files": ("src.data.kraken_cache_loader", "list_available_cache_files"),
src/data/__init__.py:93:    Wir zielen hier explizit auf den häufigsten Fall: ccxt fehlt.
src/data/__init__.py:97:        f"This symbol is provided by the Kraken data provider, which depends on 'ccxt'.\n"
src/data/__init__.py:98:        f"Install ccxt (or the project's optional extra that includes ccxt) and retry.\n\n"
src/data/__init__.py:100:        f"  pip install ccxt\n"
src/data/__init__.py:102:        f'  pip install -e ".[<extra-that-includes-ccxt>]"\n'
src/data/__init__.py:112:    without optional deps like ccxt.
src/data/__init__.py:124:        # Wrap only ccxt-missing with a helpful message; otherwise preserve original error.
src/data/__init__.py:126:        if exc_name == "ccxt" or "ccxt" in str(exc):
src/data/providers/resilient_ccxt_exchange_client.py:5:ccxt ist optional und darf nur in Provider-Modulen importiert werden.
src/data/providers/resilient_ccxt_exchange_client.py:14:import ccxt
src/data/providers/resilient_ccxt_exchange_client.py:23:    Exchange client with circuit breaker and retry logic (read-only).
src/data/providers/resilient_ccxt_exchange_client.py:26:    def __init__(self, exchange_id: str = "kraken", config: Optional[Dict[str, Any]] = None):
src/data/providers/resilient_ccxt_exchange_client.py:27:        self.exchange_id = exchange_id
src/data/providers/resilient_ccxt_exchange_client.py:31:            exchange_class = getattr(ccxt, exchange_id)
src/data/providers/resilient_ccxt_exchange_client.py:32:            self.exchange = exchange_class(self.config)
src/data/providers/resilient_ccxt_exchange_client.py:33:            logger.info(f"ResilientExchangeClient initialized for {exchange_id}")
src/data/providers/resilient_ccxt_exchange_client.py:35:            raise ValueError(f"Unknown exchange: {exchange_id}")
src/data/providers/resilient_ccxt_exchange_client.py:37:        health_check.register(f"exchange_{exchange_id}", self._health_check)
src/data/providers/resilient_ccxt_exchange_client.py:46:            ohlcv = self.exchange.fetch_ohlcv(
src/data/providers/resilient_ccxt_exchange_client.py:51:        except ccxt.NetworkError as e:
src/data/providers/resilient_ccxt_exchange_client.py:54:        except ccxt.ExchangeError as e:
src/data/providers/resilient_ccxt_exchange_client.py:66:            balance = self.exchange.fetch_balance()
src/data/providers/resilient_ccxt_exchange_client.py:69:        except ccxt.AuthenticationError as e:
src/data/providers/resilient_ccxt_exchange_client.py:72:        except ccxt.NetworkError as e:
src/data/providers/resilient_ccxt_exchange_client.py:75:        except ccxt.ExchangeError as e:
src/data/providers/resilient_ccxt_exchange_client.py:87:            ticker = self.exchange.fetch_ticker(symbol)
src/data/providers/resilient_ccxt_exchange_client.py:90:        except ccxt.NetworkError as e:
src/data/providers/resilient_ccxt_exchange_client.py:93:        except ccxt.ExchangeError as e:
src/data/providers/resilient_ccxt_exchange_client.py:102:            if hasattr(self.exchange, "fetch_status"):
src/data/providers/resilient_ccxt_exchange_client.py:103:                status = self.exchange.fetch_status()
src/data/providers/resilient_ccxt_exchange_client.py:105:                    return True, f"Exchange {self.exchange_id} is operational"
src/data/providers/resilient_ccxt_exchange_client.py:106:                return False, f"Exchange {self.exchange_id} status: {status.get('status')}"
src/data/providers/resilient_ccxt_exchange_client.py:107:            self.exchange.load_markets()
src/data/providers/resilient_ccxt_exchange_client.py:108:            return True, f"Exchange {self.exchange_id} API is accessible"
src/data/providers/resilient_ccxt_exchange_client.py:111:            return False, f"Exchange {self.exchange_id} health check failed: {str(e)}"
src/live/testnet_orchestrator.py:246:        from ..data.kraken_live import (
src/live/testnet_orchestrator.py:249:            create_kraken_source_from_config,
src/live/testnet_orchestrator.py:269:        exchange_cfg = LiveExchangeConfig()
src/live/testnet_orchestrator.py:272:        data_source = create_kraken_source_from_config(shadow_cfg, exchange_cfg)
src/live/testnet_orchestrator.py:294:            exchange_cfg=exchange_cfg,
src/ingress/normalized_event.py:21:      source: origin descriptor (e.g. "binance.ws", "kraken.rest", "shadow.sim")
src/data/kraken_pipeline.py:18:from .kraken import fetch_ohlcv_df, get_kraken_client
src/data/kraken_pipeline.py:216:def fetch_kraken_data(
src/data/kraken_pipeline.py:232:        >>> from src.data import fetch_kraken_data
src/data/kraken_pipeline.py:233:        >>> df = fetch_kraken_data("BTC/USD", "1h", limit=100)
src/data/kraken_pipeline.py:239:def test_kraken_connection() -> bool:
src/data/kraken_pipeline.py:247:        >>> from src.data import test_kraken_connection
src/data/kraken_pipeline.py:248:        >>> if test_kraken_connection():
src/data/kraken_pipeline.py:252:        client = get_kraken_client()
src/data/kraken_pipeline.py:254:        client.fetch_ticker("BTC/USD")
src/execution/risk_hook_impl.py:157:            client_order_id="temp_position_change",
src/execution/order_ledger.py:9:- Fast lookups by client_order_id and exchange_order_id
src/execution/order_ledger.py:47:    - Track all orders by client_order_id
src/execution/order_ledger.py:48:    - Track by exchange_order_id (after ACK)
src/execution/order_ledger.py:55:        # Primary index: client_order_id → Order
src/execution/order_ledger.py:58:        # Secondary index: exchange_order_id → client_order_id
src/execution/order_ledger.py:59:        self._exchange_to_client: Dict[str, str] = {}
src/execution/order_ledger.py:61:        # Order history: client_order_id → List[OrderHistoryEntry]
src/execution/order_ledger.py:77:        if order.client_order_id in self._orders:
src/execution/order_ledger.py:80:        self._orders[order.client_order_id] = order
src/execution/order_ledger.py:81:        self._history[order.client_order_id] = []
src/execution/order_ledger.py:103:        if order.client_order_id not in self._orders:
src/execution/order_ledger.py:106:        self._orders[order.client_order_id] = order
src/execution/order_ledger.py:108:        # Update exchange_order_id index if set
src/execution/order_ledger.py:109:        if order.exchange_order_id:
src/execution/order_ledger.py:110:            self._exchange_to_client[order.exchange_order_id] = order.client_order_id
src/execution/order_ledger.py:117:    def get_order(self, client_order_id: str) -> Optional[Order]:
src/execution/order_ledger.py:119:        Get order by client_order_id.
src/execution/order_ledger.py:122:            client_order_id: Client order ID
src/execution/order_ledger.py:127:        return self._orders.get(client_order_id)
src/execution/order_ledger.py:129:    def get_order_by_exchange_id(self, exchange_order_id: str) -> Optional[Order]:
src/execution/order_ledger.py:131:        Get order by exchange_order_id.
src/execution/order_ledger.py:134:            exchange_order_id: Exchange order ID
src/execution/order_ledger.py:139:        client_id = self._exchange_to_client.get(exchange_order_id)
src/execution/order_ledger.py:140:        if client_id:
src/execution/order_ledger.py:141:            return self._orders.get(client_id)
src/execution/order_ledger.py:144:    def get_order_history(self, client_order_id: str) -> List[OrderHistoryEntry]:
src/execution/order_ledger.py:149:            client_order_id: Client order ID
src/execution/order_ledger.py:154:        return self._history.get(client_order_id, [])
src/execution/order_ledger.py:222:        if order.client_order_id not in self._history:
src/execution/order_ledger.py:223:            self._history[order.client_order_id] = []
src/execution/order_ledger.py:232:        self._history[order.client_order_id].append(entry)
src/risk_layer/kill_switch/config.py:47:        "require_exchange_connection": True,
src/execution/paper/broker.py:108:            f"Paper order submitted: {order.client_order_id} "
src/execution/paper/broker.py:169:            client_order_id=order.client_order_id,
src/execution/paper/broker.py:170:            exchange_order_id=order.exchange_order_id or str(uuid4()),
src/execution/paper/broker.py:237:            client_order_id=order.client_order_id,
src/execution/paper/broker.py:238:            exchange_order_id=order.exchange_order_id or str(uuid4()),
src/execution/live_session.py:64:    from ..exchange.dummy_client import DummyExchangeClient
src/execution/live_session.py:65:    from ..exchange.kraken_testnet import KrakenTestnetClient
src/execution/live_session.py:602:            from ..data.kraken_live import (
src/execution_simple/gates.py:129:    Rounds quantity to exchange lot size constraints.
src/execution_simple/gates.py:131:    Modifies quantity to meet exchange minimum lot size requirements.
src/live/web/app.py:623:    # - Default is fail-open when prometheus_client is not installed (keeps local runs working).
src/live/web/app.py:625:    #   prometheus_client is unavailable (prevents "green fake metrics" in Grafana/Prometheus).
src/live/web/app.py:635:            from prometheus_client import CONTENT_TYPE_LATEST, generate_latest  # type: ignore
src/live/web/app.py:640:                # Strict: signal scrape failure when prometheus_client is missing/unavailable.
src/live/web/app.py:643:                    b"prometheus_client required but unavailable\n",
src/live/web/app.py:647:            # Fail-open: keep endpoint available even when prometheus_client is missing.
src/live/web/app.py:651:                "# HELP peak_trade_metrics_fallback 1 when prometheus_client is unavailable.\n"
src/execution/ledger_mapper.py:69:            client_order_id=execution_event.order_id,
src/execution/ledger_mapper.py:74:                "exchange_order_id": execution_event.exchange_order_id,
src/execution/ledger_mapper.py:114:            client_order_id=order_id,
src/execution/ledger_mapper.py:160:            client_order_id=order_id,
src/live/web/metrics_prom.py:9:    import prometheus_client  # type: ignore
src/live/web/metrics_prom.py:10:    from prometheus_client import CONTENT_TYPE_LATEST, Counter, Gauge, Histogram  # type: ignore
src/live/web/metrics_prom.py:11:    from prometheus_client.exposition import generate_latest  # type: ignore
src/live/web/metrics_prom.py:15:    prometheus_client = None  # type: ignore
src/live/web/metrics_prom.py:53:    # Defensive: should only be called when prometheus_client is available
src/live/web/metrics_prom.py:103:        logger.info("Prometheus metrics disabled (prometheus_client missing).")
src/execution/orchestrator.py:215:    Adapters encapsulate external interaction (exchange API, paper simulation, etc.).
src/execution/orchestrator.py:240:        exchange_order_id: Exchange order ID (if ACK)
src/execution/orchestrator.py:248:    exchange_order_id: Optional[str] = None
src/execution/orchestrator.py:270:            order_id=order.client_order_id,
src/execution/orchestrator.py:271:            exchange_order_id=f"null_exch_{order.client_order_id}",
src/execution/orchestrator.py:388:        client_order_id: Optional[str] = None,
src/execution/orchestrator.py:406:            "client_order_id": client_order_id,
src/execution/orchestrator.py:423:            "client_order_id": client_order_id,
src/execution/orchestrator.py:653:                f"order_id={order.client_order_id}, state={order.state.value}"
src/execution/orchestrator.py:694:        # Generate deterministic client_order_id (no uuid)
src/execution/orchestrator.py:696:        client_order_id = f"order_{stable_id(kind='order', fields={'run_id': run_id, 'session_id': session_id, 'intent_id': intent_id})[:16]}"
src/execution/orchestrator.py:700:            client_order_id=client_order_id,
src/execution/orchestrator.py:742:                    client_order_id=order.client_order_id,
src/execution/orchestrator.py:759:            client_order_id=client_order_id,
src/execution/orchestrator.py:786:            f"order_id={client_order_id}"
src/execution/orchestrator.py:1044:                client_order_id=order.client_order_id,
src/execution/orchestrator.py:1125:                order, exchange_order_id=execution_event.exchange_order_id or "unknown"
src/execution/orchestrator.py:1141:                        client_order_id=order.client_order_id,
src/execution/orchestrator.py:1143:                            "exchange_order_id": execution_event.exchange_order_id or "unknown"
src/execution/orchestrator.py:1174:                        client_order_id=order.client_order_id,
src/execution/orchestrator.py:1208:                    order, exchange_order_id=execution_event.exchange_order_id or "unknown"
src/execution/orchestrator.py:1223:                            client_order_id=order.client_order_id,
src/execution/orchestrator.py:1225:                                "exchange_order_id": execution_event.exchange_order_id or "unknown"
src/execution/orchestrator.py:1245:                    client_order_id=order.client_order_id,
src/execution/orchestrator.py:1395:        Phase 0: Conceptual/smoke test (no real exchange data)
src/execution/paper/engine.py:124:        client_order_id: Optional[str] = None,
src/execution/paper/engine.py:135:            client_order_id: Optional client order ID
src/execution/paper/engine.py:140:        # Generate client order ID if not provided
src/execution/paper/engine.py:141:        if client_order_id is None:
src/execution/paper/engine.py:144:            client_order_id = f"paper_{uuid.uuid4().hex[:8]}"
src/execution/paper/engine.py:148:            client_order_id=client_order_id,
src/execution/paper/engine.py:171:                    f"Order {order.client_order_id} REJECTED by risk: {risk_result.reason}"
src/execution/paper/engine.py:178:                    entry_id=f"risk_{order.client_order_id}",
src/execution/paper/engine.py:180:                    client_order_id=order.client_order_id,
src/execution/paper/engine.py:192:                logger.error(f"Order {order.client_order_id} HALTED by risk: {risk_result.reason}")
src/execution/paper/engine.py:198:                    entry_id=f"risk_{order.client_order_id}",
src/execution/paper/engine.py:200:                    client_order_id=order.client_order_id,
src/execution/paper/engine.py:234:                    client_order_id=order.client_order_id,
src/execution/paper/engine.py:250:            f"Order {order.client_order_id} submitted: state={order.state.value} fills={len(fills)}"
src/execution/paper/engine.py:288:            client_order_id=fill.client_order_id,
src/execution/broker/base.py:24:    client_order_id: str
src/backtest/engine.py:250:            generate_client_ids=True,
src/execution/venue_adapters/base.py:27:    - (Future) LiveVenueAdapter: Real exchange execution (Phase 2+)
src/execution/venue_adapters/simulated.py:117:            f"id={order.client_order_id}, symbol={order.symbol}, "
src/execution/venue_adapters/simulated.py:136:                order_id=order.client_order_id,
src/execution/venue_adapters/simulated.py:148:                order_id=order.client_order_id,
src/execution/venue_adapters/simulated.py:149:                exchange_order_id=f"sim_ack_{order.client_order_id}",
src/execution/venue_adapters/simulated.py:164:                order_id=order.client_order_id,
src/execution/venue_adapters/simulated.py:176:            fill_id=f"sim_fill_{order.client_order_id}",
src/execution/venue_adapters/simulated.py:177:            client_order_id=order.client_order_id,
src/execution/venue_adapters/simulated.py:178:            exchange_order_id=f"sim_exch_{order.client_order_id}",
src/execution/venue_adapters/simulated.py:190:            order_id=order.client_order_id,
src/execution/venue_adapters/simulated.py:191:            exchange_order_id=f"sim_exch_{order.client_order_id}",
src/execution/venue_adapters/simulated.py:201:            f"id={order.client_order_id}, qty={fill.quantity}, "
src/execution/broker/fake_broker.py:94:            client_order_id=stored.order.client_order_id,
src/execution/broker/fake_broker.py:131:            client_order_id=order.client_order_id,
src/execution/broker/fake_broker.py:132:            exchange_order_id=stored.broker_order_id,
src/execution/beta_bridge/schema.py:74:    d["client_order_id"] = _as_str_or_none(d.get("client_order_id"))
src/execution/pipeline.py:190:    or exchange inconsistency).
src/execution/pipeline.py:274:    def to_order_request(self, client_id: Optional[str] = None) -> OrderRequest:
src/execution/pipeline.py:288:            client_id=client_id,
src/execution/pipeline.py:448:        generate_client_ids: Ob automatisch Client-IDs generiert werden sollen
src/execution/pipeline.py:458:    generate_client_ids: bool = True
src/execution/pipeline.py:664:    def _generate_client_id(self, symbol: str) -> str:
src/execution/pipeline.py:779:                        client_id=(
src/execution/pipeline.py:780:                            self._generate_client_id(event.symbol)
src/execution/pipeline.py:781:                            if self._config.generate_client_ids
src/execution/pipeline.py:796:                        client_id=(
src/execution/pipeline.py:797:                            self._generate_client_id(event.symbol)
src/execution/pipeline.py:798:                            if self._config.generate_client_ids
src/execution/pipeline.py:814:                        client_id=(
src/execution/pipeline.py:815:                            self._generate_client_id(event.symbol)
src/execution/pipeline.py:816:                            if self._config.generate_client_ids
src/execution/pipeline.py:833:                        client_id=(
src/execution/pipeline.py:834:                            self._generate_client_id(event.symbol)
src/execution/pipeline.py:835:                            if self._config.generate_client_ids
src/execution/pipeline.py:850:                        client_id=(
src/execution/pipeline.py:851:                            self._generate_client_id(event.symbol)
src/execution/pipeline.py:852:                            if self._config.generate_client_ids
src/execution/pipeline.py:868:                        client_id=(
src/execution/pipeline.py:869:                            self._generate_client_id(event.symbol)
src/execution/pipeline.py:870:                            if self._config.generate_client_ids
src/execution/pipeline.py:1007:            client_id = (
src/execution/pipeline.py:1008:                self._generate_client_id(symbol) if self._config.generate_client_ids else None
src/execution/pipeline.py:1017:                client_id=client_id,
src/execution/pipeline.py:1181:        client_id = self._generate_client_id(intent.symbol)
src/execution/pipeline.py:1182:        order = intent.to_order_request(client_id=client_id)
src/execution/pipeline.py:1190:                "client_id": client_id,
src/execution/pipeline.py:1213:                            "client_id": exec_order.request.client_id,  # client_id is in request
src/execution/pipeline.py:1546:                client_order_id=order.client_id or f"exec_{i}_{uuid.uuid4().hex[:8]}",
src/execution/reconciliation.py:6:Phase 0: Paper/Shadow mode - no real exchange data.
src/execution/reconciliation.py:8:- External snapshot: Mocked/stubbed (no real exchange API)
src/execution/reconciliation.py:12:Future: Phase 1+ integration with exchange API.
src/execution/reconciliation.py:31:    Represents exchange-reported state for reconciliation.
src/execution/reconciliation.py:33:    In Phase 1+, populated from exchange API.
src/execution/reconciliation.py:114:        In Phase 1+, this would fetch from exchange API.
src/execution/reconciliation.py:176:                    client_order_id="",  # Position-level, no specific order
src/execution/reconciliation.py:177:                    exchange_order_id=None,
src/execution/reconciliation.py:179:                    exchange_state=None,
src/execution/reconciliation.py:227:                client_order_id="",
src/execution/reconciliation.py:228:                exchange_order_id=None,
src/execution/reconciliation.py:230:                exchange_state=None,
src/execution/ledger/engine.py:239:        client_order_id = str(event.get("client_order_id") or "")
src/execution/ledger/engine.py:250:                "client_order_id": client_order_id,
src/execution/venue_adapters/fill_models.py:128:    Typical exchange fees:
src/execution/paper/journal.py:27:        client_order_id: Order ID
src/execution/paper/journal.py:38:    client_order_id: str
src/execution/paper/journal.py:51:            "client_order_id": self.client_order_id,
src/execution/paper/journal.py:100:            f"Journal entry added: {entry.client_order_id} "
src/execution/order_state_machine.py:100:            "order_id": self.order.client_order_id,
src/execution/order_state_machine.py:142:        client_order_id: str,
src/execution/order_state_machine.py:152:            client_order_id: Unique client order ID
src/execution/order_state_machine.py:165:            client_order_id=client_order_id,
src/execution/order_state_machine.py:197:            message=f"Order {client_order_id} created",
src/execution/order_state_machine.py:223:                    message=f"Order {order.client_order_id} already submitted",
src/execution/order_state_machine.py:249:            message=f"Order {order.client_order_id} submitted",
src/execution/order_state_machine.py:255:        exchange_order_id: str,
src/execution/order_state_machine.py:262:            exchange_order_id: Exchange-provided order ID
src/execution/order_state_machine.py:272:                message=f"Order {order.client_order_id} already acknowledged",
src/execution/order_state_machine.py:284:        # Update exchange order ID
src/execution/order_state_machine.py:285:        order.exchange_order_id = exchange_order_id
src/execution/order_state_machine.py:292:            message=f"Order {order.client_order_id} acknowledged by exchange",
src/execution/order_state_machine.py:293:            metadata={"exchange_order_id": exchange_order_id},
src/execution/order_state_machine.py:330:            message = f"Order {order.client_order_id} fully filled"
src/execution/order_state_machine.py:335:                f"Order {order.client_order_id} partially filled ({fill.quantity}/{order.quantity})"
src/execution/order_state_machine.py:363:                message=f"Order {order.client_order_id} already cancelled",
src/execution/order_state_machine.py:389:            message=f"Order {order.client_order_id} cancelled: {reason}",
src/execution/order_state_machine.py:416:            message=f"Order {order.client_order_id} rejected: {reason}",
src/execution/order_state_machine.py:435:                message=f"Order {order.client_order_id} already in terminal state",
src/execution/order_state_machine.py:443:            message=f"Order {order.client_order_id} failed: {reason}",
src/execution/order_state_machine.py:528:            entry_id=f"{order.client_order_id}_{self._ledger_sequence}",
src/execution/order_state_machine.py:531:            client_order_id=order.client_order_id,
src/execution/contracts.py:31:    SUBMITTED = "SUBMITTED"  # Sent to exchange, awaiting acknowledgment
src/execution/contracts.py:96:    - client_order_id is our stable identifier
src/execution/contracts.py:97:    - exchange_order_id is assigned by exchange after ACK
src/execution/contracts.py:101:    client_order_id: str
src/execution/contracts.py:102:    exchange_order_id: Optional[str] = None
src/execution/contracts.py:143:            f"Order(client_order_id={self.client_order_id!r}, "
src/execution/contracts.py:161:    - fill_id is exchange-provided unique identifier
src/execution/contracts.py:166:    client_order_id: str
src/execution/contracts.py:167:    exchange_order_id: str
src/execution/contracts.py:206:        Canonical tuple: (client_order_id, symbol, side, quantity, price,
src/execution/contracts.py:219:            f"{self.client_order_id}|"
src/execution/contracts.py:234:            f"client_order_id={self.client_order_id!r}, "
src/execution/contracts.py:261:    client_order_id: str = ""
src/execution/contracts.py:301:    Represents a divergence between local and exchange state.
src/execution/contracts.py:312:    client_order_id: str = ""
src/execution/contracts.py:313:    exchange_order_id: Optional[str] = None
src/execution/contracts.py:317:    exchange_state: Optional[str] = None
src/execution/contracts.py:363:    Phase 0: SIM/PAPER only (no live exchange data)
src/execution/contracts.py:477:    if not order.client_order_id:
src/execution/contracts.py:497:        client_order_id="test_order_001",
src/execution/contracts.py:507:        client_order_id="test_order_001",
src/execution/contracts.py:508:        exchange_order_id="exch_001",
src/execution/contracts.py:519:        client_order_id="test_order_001",
src/execution/contracts.py:526:        client_order_id="test_order_001",
src/execution/contracts.py:528:        exchange_state="PARTIALLY_FILLED",
src/core/experiments.py:321:        data_source: Datenquelle (z.B. "kraken_csv", "binance_api")
src/core/experiments.py:436:    exchange_name: Optional[str] = None,
src/core/experiments.py:456:        exchange_name: Name des Exchange-Clients (z.B. "kraken")
src/core/experiments.py:502:        "exchange_name": exchange_name,
src/execution/telemetry_viewer.py:278:            entry["order_id"] = payload.get("client_id", "")
src/execution/telemetry_viewer.py:284:            entry["order_id"] = payload.get("client_id", "")
src/core/config_pydantic.py:82:    exchange: str = Field(default="kraken")
src/core/config_pydantic.py:103:        default_type: Client-Typ ("dummy", "kraken_testnet", später "kraken_live")
src/core/config_pydantic.py:109:        pattern="^(dummy|kraken_testnet|kraken_live)$",
src/core/config_pydantic.py:158:    exchange: ExchangeConfig = Field(default_factory=ExchangeConfig)
src/obs/metrics_server.py:13:    - Fail-open: if prometheus_client is unavailable, return False and do nothing.
src/obs/metrics_server.py:26:        from prometheus_client import start_http_server  # type: ignore
src/execution/ledger/engine_legacy.py:249:        client_order_id = str(event.get("client_order_id") or "")
src/execution/ledger/engine_legacy.py:260:                "client_order_id": client_order_id,
src/execution/risk_runtime/decisions.py:79:            d["modified_order_id"] = self.modified_order.client_order_id
src/core/metrics.py:36:# Try to import prometheus_client, but make it optional
src/core/metrics.py:38:    from prometheus_client import (
src/core/metrics.py:51:        "prometheus_client not installed. Metrics will be collected in-memory only. "
src/core/metrics.py:52:        "Install with: pip install prometheus-client"
src/core/metrics.py:93:    If prometheus_client is available, exposes metrics for Prometheus scraping.
src/core/metrics.py:391:            return ("# Prometheus client not installed\n", "text/plain; charset=utf-8")
src/execution/risk_runtime/runtime.py:259:        client_order_id = ""
src/execution/risk_runtime/runtime.py:261:            client_order_id = order.client_order_id
src/execution/risk_runtime/runtime.py:263:            client_order_id = fill.client_order_id
src/execution/risk_runtime/runtime.py:268:            client_order_id=client_order_id,
src/obs/otel.py:42:    from src.data.lake.client import LakeClient
src/obs/otel.py:295:    client: "LakeClient",
src/obs/otel.py:305:        client: LakeClient instance to instrument.
src/obs/otel.py:309:        The same client instance with instrumented methods.
src/obs/otel.py:312:        If OTel is not available, returns the client unchanged (no-op).
src/obs/otel.py:320:        >>> client = LakeClient(":memory:")
src/obs/otel.py:321:        >>> client = instrument_lake(client)
src/obs/otel.py:322:        >>> client.query("SELECT 1")  # Creates a span
src/obs/otel.py:327:    original_query = client.query
src/obs/otel.py:328:    original_execute = client.execute
src/obs/otel.py:329:    original_register_parquet_file = client.register_parquet_file
src/obs/otel.py:330:    original_register_parquet_folder = client.register_parquet_folder
src/obs/otel.py:331:    original_create_table_from_df = client.create_table_from_df
src/obs/otel.py:398:    client.query = traced_query  # type: ignore
src/obs/otel.py:399:    client.execute = traced_execute  # type: ignore
src/obs/otel.py:400:    client.register_parquet_file = traced_register_parquet_file  # type: ignore
src/obs/otel.py:401:    client.register_parquet_folder = traced_register_parquet_folder  # type: ignore
src/obs/otel.py:402:    client.create_table_from_df = traced_create_table_from_df  # type: ignore
src/obs/otel.py:405:    client._otel_instrumented = True  # type: ignore
src/obs/otel.py:407:    return client
src/obs/metricsd.py:63:    prom = importlib.import_module("prometheus_client")
src/obs/metricsd.py:64:    multiproc = importlib.import_module("prometheus_client.multiprocess")
src/obs/metricsd.py:82:    - Uses prometheus_client multiprocess mode (PROMETHEUS_MULTIPROC_DIR)
src/obs/metricsd.py:84:    - Fail-open when prometheus_client is unavailable
src/obs/metricsd.py:93:        prom = importlib.import_module("prometheus_client")
src/execution/risk_runtime/context.py:68:            d["order_id"] = self.order.client_order_id
src/observability/metrics.py:113:            description="Total number of exchange reconnections",
src/observability/metrics.py:152:        Record an exchange reconnection.
src/observability/metrics.py:155:            labels: Optional labels (e.g., {"exchange": "kraken"})
src/execution/metrics/execution_latency.py:47:    exchange_ack_timestamp : Optional[pd.Timestamp]
src/execution/metrics/execution_latency.py:68:    exchange_ack_timestamp: Optional[pd.Timestamp] = None
src/execution/metrics/execution_latency.py:224:    if timestamps.exchange_ack_timestamp is not None:
src/execution/metrics/execution_latency.py:225:        delta = timestamps.exchange_ack_timestamp - timestamps.order_sent_timestamp
src/execution/metrics/execution_latency.py:493:    - exchange_ack_timestamp bleibt None (kein echter Exchange)
src/execution/metrics/execution_latency.py:563:                exchange_ack_timestamp=None,  # Offline: Kein Exchange-Ack
src/obs/trade_flow_telemetry.py:13:- Graceful degradation: no-op if prometheus_client is unavailable or registration fails.
src/obs/trade_flow_telemetry.py:24:    from prometheus_client import Counter  # type: ignore
src/obs/ai_telemetry.py:16:- Graceful Degradation: no-op wenn prometheus_client nicht verfügbar
src/obs/ai_telemetry.py:28:    from prometheus_client import Counter, Gauge, Histogram
src/obs/ai_telemetry.py:29:    from prometheus_client.core import REGISTRY
src/markets/cme/contracts.py:29:        exchange: Exchange Identifier (default: CME)
src/markets/cme/contracts.py:36:    exchange: str = "CME"
src/obs/strategy_risk_telemetry.py:10:- Graceful degradation: no-op if prometheus_client unavailable or registration fails.
src/obs/strategy_risk_telemetry.py:166:    # importing prometheus_client.
src/obs/strategy_risk_telemetry.py:171:        from prometheus_client import Counter as _Counter, Gauge as _Gauge  # type: ignore
src/obs/strategy_risk_telemetry.py:245:    This is safe to call even when prometheus_client is unavailable (no-op),
src/knowledge/timeseries_db.py:115:            from influxdb_client import InfluxDBClient, Point
src/knowledge/timeseries_db.py:116:            from influxdb_client.client.write_api import SYNCHRONOUS
src/knowledge/timeseries_db.py:119:                "influxdb-client not installed. Install with: pip install influxdb-client"
src/knowledge/timeseries_db.py:130:        self.client = InfluxDBClient(url=self.url, token=self.token, org=self.org)
src/knowledge/timeseries_db.py:131:        self.write_api = self.client.write_api(write_options=SYNCHRONOUS)
src/knowledge/timeseries_db.py:132:        self.query_api = self.client.query_api()
src/knowledge/timeseries_db.py:141:        from influxdb_client import Point
src/knowledge/timeseries_db.py:167:        from influxdb_client import Point
src/knowledge/vector_db.py:111:        self.client = chromadb.PersistentClient(path=self.persist_directory)
src/knowledge/vector_db.py:112:        self.collection = self.client.get_or_create_collection(name=self.collection_name)
src/knowledge/vector_db.py:154:        self.client.delete_collection(name=self.collection_name)
src/knowledge/vector_db.py:155:        self.collection = self.client.create_collection(name=self.collection_name)
src/knowledge/vector_db.py:173:            from qdrant_client import QdrantClient
src/knowledge/vector_db.py:174:            from qdrant_client.models import Distance, VectorParams
src/knowledge/vector_db.py:177:                "qdrant-client not installed. Install with: pip install qdrant-client"
src/knowledge/vector_db.py:184:        # Initialize client
src/knowledge/vector_db.py:185:        self.client = QdrantClient(url=self.url, api_key=self.api_key)
src/knowledge/vector_db.py:188:        collections = self.client.get_collections().collections
src/knowledge/vector_db.py:190:            self.client.create_collection(
src/knowledge/vector_db.py:220:        from qdrant_client.models import PointIdsList
src/knowledge/vector_db.py:222:        self.client.delete(collection_name=self.collection_name, points_selector=PointIdsList(ids))
src/knowledge/vector_db.py:228:        self.client.delete_collection(collection_name=self.collection_name)
src/knowledge/vector_db.py:249:                "pinecone-client not installed. Install with: pip install pinecone-client"
src/knowledge/rag.py:193:            conversation_history: List of previous exchanges (role, content)
