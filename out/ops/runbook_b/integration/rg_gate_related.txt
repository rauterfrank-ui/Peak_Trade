src/analytics/__init__.py:24:from .risk_monitor import (
src/analytics/__init__.py:26:    load_experiments_df as load_experiments_df_risk,
src/analytics/__init__.py:28:    annotate_runs_with_risk,
src/analytics/__init__.py:29:    aggregate_strategy_risk,
src/analytics/__init__.py:30:    aggregate_portfolio_risk,
src/analytics/__init__.py:111:    "load_experiments_df_risk",
src/analytics/__init__.py:113:    "annotate_runs_with_risk",
src/analytics/__init__.py:114:    "aggregate_strategy_risk",
src/analytics/__init__.py:115:    "aggregate_portfolio_risk",
src/analytics/risk_monitor.py:1:# src/analytics/risk_monitor.py
src/analytics/risk_monitor.py:37:            lookback_days=int(cfg.get("risk_monitor.lookback_days", 365)),
src/analytics/risk_monitor.py:38:            min_runs_per_strategy=int(cfg.get("risk_monitor.min_runs_per_strategy", 5)),
src/analytics/risk_monitor.py:39:            min_runs_per_portfolio=int(cfg.get("risk_monitor.min_runs_per_portfolio", 3)),
src/analytics/risk_monitor.py:40:            max_drawdown_warn=float(cfg.get("risk_monitor.max_drawdown_warn", 0.30)),
src/analytics/risk_monitor.py:41:            max_drawdown_block=float(cfg.get("risk_monitor.max_drawdown_block", 0.50)),
src/analytics/risk_monitor.py:42:            min_sharpe_ok=float(cfg.get("risk_monitor.min_sharpe_ok", 0.5)),
src/analytics/risk_monitor.py:43:            min_sharpe_good=float(cfg.get("risk_monitor.min_sharpe_good", 1.0)),
src/analytics/risk_monitor.py:44:            min_total_return=float(cfg.get("risk_monitor.min_total_return", -1.0)),
src/analytics/risk_monitor.py:149:def annotate_runs_with_risk(df: pd.DataFrame, policy: RiskPolicy) -> pd.DataFrame:
src/analytics/risk_monitor.py:152:        - risk_status_run
src/analytics/risk_monitor.py:153:        - risk_reasons_run
src/analytics/risk_monitor.py:165:    df["risk_status_run"] = statuses
src/analytics/risk_monitor.py:166:    df["risk_reasons_run"] = reasons_list
src/analytics/risk_monitor.py:170:def _aggregate_group_risk(
src/analytics/risk_monitor.py:187:                "risk_status_group",
src/analytics/risk_monitor.py:202:        n_blocked = int((grp["risk_status_run"] == "BLOCKED").sum())
src/analytics/risk_monitor.py:203:        n_watch = int((grp["risk_status_run"] == "WATCH").sum())
src/analytics/risk_monitor.py:204:        n_ok = int((grp["risk_status_run"] == "OK").sum())
src/analytics/risk_monitor.py:205:        n_unknown = int((grp["risk_status_run"] == "UNKNOWN").sum())
src/analytics/risk_monitor.py:226:                "risk_status_group": status_group,
src/analytics/risk_monitor.py:246:                "risk_status_group",
src/analytics/risk_monitor.py:256:def aggregate_strategy_risk(df_runs: pd.DataFrame, policy: RiskPolicy) -> pd.DataFrame:
src/analytics/risk_monitor.py:260:    return _aggregate_group_risk(
src/analytics/risk_monitor.py:267:def aggregate_portfolio_risk(df_runs: pd.DataFrame, policy: RiskPolicy) -> pd.DataFrame:
src/analytics/risk_monitor.py:272:    return _aggregate_group_risk(
src/analytics/filter_flow.py:22:    - Risk-Aggregation (risk_status_group)
src/analytics/filter_flow.py:27:    allowed_risk_statuses: Tuple[str, ...] = ("OK",)
src/analytics/filter_flow.py:37:        raw_allowed = cfg.get("filter_flow.allowed_risk_statuses", ["OK"])
src/analytics/filter_flow.py:47:            allowed_risk_statuses=allowed,
src/analytics/filter_flow.py:64:    - risk_status_group
src/analytics/filter_flow.py:68:    risk_status = row.get("risk_status_group", np.nan)
src/analytics/filter_flow.py:78:    if isinstance(risk_status, str) and risk_status == "BLOCKED":
src/analytics/filter_flow.py:80:        reasons.append("risk_blocked")
src/analytics/filter_flow.py:83:    if isinstance(risk_status, str) and risk_status not in policy.allowed_risk_statuses:
src/analytics/filter_flow.py:86:        reasons.append(f"risk_status_not_allowed({risk_status})")
src/analytics/filter_flow.py:116:    df_strat_risk: pd.DataFrame,
src/analytics/filter_flow.py:125:    - df_strat_risk: Aggregation aus risk_monitor.aggregate_strategy_risk(...)
src/analytics/filter_flow.py:126:        mit Spalten: strategy_key, risk_status_group, n_runs, ...
src/analytics/filter_flow.py:135:        risk_status_group
src/analytics/filter_flow.py:143:    keys_risk = (
src/analytics/filter_flow.py:144:        set(df_strat_risk["strategy_key"].dropna())
src/analytics/filter_flow.py:145:        if "strategy_key" in df_strat_risk.columns
src/analytics/filter_flow.py:148:    all_keys = sorted(keys_runs | keys_risk)
src/analytics/filter_flow.py:158:                "risk_status_group",
src/analytics/filter_flow.py:206:    if not df_strat_risk.empty:
src/analytics/filter_flow.py:208:            df_strat_risk[["strategy_key", "risk_status_group", "n_runs"]],
src/analytics/filter_flow.py:211:            suffixes=("", "_risk"),
src/analytics/filter_flow.py:214:        df_sel["risk_status_group"] = np.nan
src/regime/detectors.py:63:        ...     enabled=True,
src/regime/detectors.py:252:        ...     enabled=True,
src/regime/detectors.py:416:        >>> config = RegimeDetectorConfig(enabled=True, detector_name="volatility_breakout")
src/regime/detectors.py:421:    if not config.enabled:
src/regime/detectors.py:422:        logger.debug("Regime Detection ist deaktiviert (enabled=false)")
src/observability/drift/comparator.py:159:        # Calculate aggregate metrics
src/regime/__init__.py:28:    >>> detector_config = RegimeDetectorConfig(enabled=True)
src/regime/__init__.py:35:    >>> switching_config = StrategySwitchingConfig(enabled=True)
src/notifications/slack.py:31:        enabled: Ob Notifier aktiv ist (False wenn webhook_url fehlt)
src/notifications/slack.py:54:        self.enabled = webhook_url is not None and len(webhook_url) > 0
src/notifications/slack.py:86:        - Wenn enabled=False, wird nichts gesendet
src/notifications/slack.py:88:        if not self.enabled:
src/notifications/slack.py:94:            # Fail-safe: Slack-Fehler killen nicht die Pipeline
src/notifications/slack.py:211:    if not notifier.enabled:
src/notifications/slack.py:263:        # Fail-safe: Slack-Fehler killen nicht die Pipeline
src/notifications/slack.py:307:        # Fail-safe: Slack-Fehler killen nicht die Pipeline
src/observability/drift/daily_report.py:204:                "ðŸ›‘ **Consider pausing shadow trading** until drift is investigated."
src/observability/drift/daily_report.py:207:                "ðŸ” **Investigate root cause:** Check data quality, timing, and execution logic."
src/regime/switching.py:56:        ...     enabled=True,
src/regime/switching.py:212:        >>> config = StrategySwitchingConfig(enabled=True)
src/regime/switching.py:217:    if not config.enabled:
src/regime/switching.py:218:        logger.debug("Strategy Switching ist deaktiviert (enabled=false)")
src/notifications/base.py:10:    - source: Ursprung des Alerts (z.B. "forward_signal", "live_risk", "analytics")
src/notifications/base.py:38:        source: Ursprung des Alerts (z.B. "forward_signal", "live_risk", "analytics")
src/notifications/base.py:123:        ...     source="live_risk",
src/risk_layer/audit_log.py:5:Writes risk decisions to a JSONL (JSON Lines) audit log.
src/risk_layer/audit_log.py:15:    Writes risk audit events to a JSONL file.
src/regime/config.py:13:    enabled = true
src/regime/config.py:18:    enabled = true
src/regime/config.py:45:        enabled: Ob Regime-Detection aktiviert ist
src/regime/config.py:65:        ...     enabled=True,
src/regime/config.py:71:    enabled: bool = False
src/regime/config.py:94:            "enabled": self.enabled,
src/regime/config.py:124:            enabled=bool(cfg.get(f"{section}.enabled", False)),
src/regime/config.py:149:        enabled: Ob Strategy Switching aktiviert ist
src/regime/config.py:157:        ...     enabled=True,
src/regime/config.py:169:    enabled: bool = False
src/regime/config.py:196:            "enabled": self.enabled,
src/regime/config.py:242:            enabled = true
src/regime/config.py:260:        enabled = bool(cfg.get(f"{section}.enabled", False))
src/regime/config.py:293:            enabled=enabled,
src/experiments/portfolio_presets.py:524:        risk_profile="moderate",
src/experiments/portfolio_presets.py:583:        risk_profile="aggressive",
src/risk_layer/exceptions.py:5:Custom exceptions for risk management operations.
src/risk_layer/exceptions.py:11:    """Base exception for all risk layer errors."""
src/risk_layer/exceptions.py:18:    Raised when insufficient data is available for risk calculation.
src/risk_layer/exceptions.py:31:    Raised when risk configuration is invalid or incomplete.
src/risk_layer/exceptions.py:36:    - Conflicting risk limit settings
src/risk_layer/exceptions.py:44:    Raised when a risk calculation fails unexpectedly.
src/risk_layer/exceptions.py:57:    Raised when a risk limit is violated and operation cannot proceed.
src/knowledge/rag.py:81:            ReadonlyModeError: If KNOWLEDGE_READONLY is enabled
src/knowledge/rag.py:216:            ReadonlyModeError: If KNOWLEDGE_READONLY is enabled
src/infra/escalation/manager.py:33:    - Konfiguration (enabled, critical_severities, enabled_environments)
src/infra/escalation/manager.py:42:        ...     enabled=True,
src/infra/escalation/manager.py:43:        ...     enabled_environments={"live"},
src/infra/escalation/manager.py:54:        enabled: bool = True,
src/infra/escalation/manager.py:55:        enabled_environments: Optional[Set[str]] = None,
src/infra/escalation/manager.py:65:            enabled: Ob Eskalation global aktiviert ist
src/infra/escalation/manager.py:66:            enabled_environments: Set von Environments in denen eskaliert wird
src/infra/escalation/manager.py:72:        self._enabled = enabled
src/infra/escalation/manager.py:73:        self._enabled_environments = enabled_environments or {"live"}
src/infra/escalation/manager.py:79:    def enabled(self) -> bool:
src/infra/escalation/manager.py:81:        return self._enabled
src/infra/escalation/manager.py:89:    def enabled_environments(self) -> Set[str]:
src/infra/escalation/manager.py:91:        return self._enabled_environments
src/infra/escalation/manager.py:103:        1. enabled = True
src/infra/escalation/manager.py:104:        2. current_environment in enabled_environments
src/infra/escalation/manager.py:117:            if not self._enabled:
src/infra/escalation/manager.py:121:            # Gate 2: Environment nicht in enabled_environments?
src/infra/escalation/manager.py:122:            if self._current_environment not in self._enabled_environments:
src/infra/escalation/manager.py:125:                    f"(enabled: {self._enabled_environments})"
src/infra/escalation/manager.py:162:            if not target.enabled:
src/infra/escalation/manager.py:218:        enabled = true
src/infra/escalation/manager.py:219:        enabled_environments = ["live"]
src/infra/escalation/manager.py:228:        enabled = true
src/infra/escalation/manager.py:232:        enable_real_calls = false
src/infra/escalation/manager.py:244:    enabled = escalation_config.get("enabled", False)
src/infra/escalation/manager.py:252:    enabled_envs_raw = escalation_config.get("enabled_environments", ["live"])
src/infra/escalation/manager.py:253:    if isinstance(enabled_envs_raw, str):
src/infra/escalation/manager.py:254:        enabled_environments = {enabled_envs_raw}
src/infra/escalation/manager.py:256:        enabled_environments = set(enabled_envs_raw)
src/infra/escalation/manager.py:282:                    enabled=target_data.get("enabled", True),
src/infra/escalation/manager.py:296:        f"Escalation manager configured: enabled={enabled}, "
src/infra/escalation/manager.py:304:        enabled=enabled,
src/infra/escalation/manager.py:305:        enabled_environments=enabled_environments,
src/risk/validation/kupiec_pof.py:5:Prefer importing from: src.risk_layer.var_backtest.kupiec_pof
src/risk/validation/kupiec_pof.py:7:The canonical implementation lives in src/risk_layer/var_backtest/kupiec_pof.py
src/risk/validation/kupiec_pof.py:25:from src.risk_layer.var_backtest.kupiec_pof import (
src/risk/validation/kupiec_pof.py:51:        "src.risk.validation.kupiec_pof is deprecated; "
src/risk/validation/kupiec_pof.py:52:        "prefer src.risk_layer.var_backtest.kupiec_pof",
src/risk/validation/kupiec_pof.py:143:    **WRAPPER**: This function now delegates to the canonical engine
src/risk/validation/kupiec_pof.py:144:    (src.risk_layer.var_backtest.kupiec_pof.kupiec_lr_uc) for all computation.
src/risk/validation/kupiec_pof.py:195:    # Delegate to canonical engine
src/risk/validation/kupiec_pof.py:227:    **WRAPPER**: This function now delegates to the canonical engine
src/risk/validation/kupiec_pof.py:228:    (src.risk_layer.var_backtest.kupiec_pof._compute_lr_statistic).
src/risk/validation/kupiec_pof.py:247:    # Delegate to canonical engine
src/risk/validation/kupiec_pof.py:255:    **WRAPPER**: This function now delegates to the canonical engine
src/risk/validation/kupiec_pof.py:256:    (src.risk_layer.var_backtest.kupiec_pof.chi2_df1_sf).
src/risk/validation/kupiec_pof.py:272:    # Delegate to canonical engine
src/risk_layer/kill_switch/health_check.py:3:Validates system health before allowing recovery from killed state.
src/risk_layer/risk_gate.py:5:Central orchestrator for risk evaluation and audit logging.
src/risk_layer/risk_gate.py:15:from src.risk_layer.adapters import order_to_dict, to_order
src/risk_layer/risk_gate.py:16:from src.risk_layer.audit_log import AuditLogWriter
src/risk_layer/risk_gate.py:17:from src.risk_layer.models import RiskDecision, RiskResult, Violation
src/risk_layer/risk_gate.py:22:    Orchestrates risk evaluation and audit logging.
src/risk_layer/risk_gate.py:26:    risk models.
src/risk_layer/risk_gate.py:31:        Initialize the risk gate.
src/risk_layer/risk_gate.py:39:        audit_path = cfg.get("risk.audit_log.path", "./logs/risk_audit.jsonl")
src/risk_layer/risk_gate.py:44:        Evaluate an order against risk rules.
src/risk_layer/risk_gate.py:104:            decision: The risk decision
src/ai_orchestration/l2_runner.py:374:            "change risk limit",
src/experiments/tracking/peaktrade_run.py:53:        enable_mlflow: Optional[bool] = None,
src/experiments/tracking/peaktrade_run.py:64:            enable_mlflow: Explicitly enable/disable MLflow (overrides env)
src/experiments/tracking/peaktrade_run.py:73:        if enable_mlflow is not None:
src/experiments/tracking/peaktrade_run.py:74:            self.enable_mlflow = enable_mlflow
src/experiments/tracking/peaktrade_run.py:76:            self.enable_mlflow = os.getenv("PEAK_TRADE_MLFLOW_ENABLE", "").lower() in (
src/experiments/tracking/peaktrade_run.py:98:        # Try to import mlflow if enabled
src/experiments/tracking/peaktrade_run.py:99:        if self.enable_mlflow:
src/meta/infostream/run_cycle.py:370:        "--dry-run",
src/ops/__init__.py:16:    aggregate_health,
src/ops/__init__.py:34:    "aggregate_health",
src/risk_layer/kill_switch/cli.py:3:Provides command-line interface for operators to manage kill switch.
src/risk_layer/kill_switch/cli.py:7:    - trigger: Manually trigger kill switch
src/risk_layer/kill_switch/cli.py:24:from src.risk_layer.kill_switch import KillSwitch, load_config, get_approval_code
src/risk_layer/kill_switch/cli.py:25:from src.risk_layer.kill_switch.audit import AuditTrail
src/risk_layer/kill_switch/cli.py:26:from src.risk_layer.kill_switch.health_check import HealthChecker
src/risk_layer/kill_switch/cli.py:27:from src.risk_layer.kill_switch.persistence import StatePersistence
src/risk_layer/kill_switch/cli.py:28:from src.risk_layer.kill_switch.recovery import RecoveryManager
src/risk_layer/kill_switch/cli.py:40:def cmd_status(args, kill_switch: KillSwitch):
src/risk_layer/kill_switch/cli.py:41:    """Show kill switch status."""
src/risk_layer/kill_switch/cli.py:42:    status = kill_switch.get_status()
src/risk_layer/kill_switch/cli.py:62:    if status["killed_at"]:
src/risk_layer/kill_switch/cli.py:63:        killed_at = datetime.fromisoformat(status["killed_at"])
src/risk_layer/kill_switch/cli.py:64:        print(f"â”‚ Last Trigger:  {killed_at.strftime('%Y-%m-%d %H:%M:%S'):<20} â”‚")
src/risk_layer/kill_switch/cli.py:79:def cmd_trigger(args, kill_switch: KillSwitch):
src/risk_layer/kill_switch/cli.py:80:    """Manually trigger kill switch."""
src/risk_layer/kill_switch/cli.py:93:    success = kill_switch.trigger(reason, triggered_by="manual_cli")
src/risk_layer/kill_switch/cli.py:99:        print("âŒ Failed to trigger (already killed or disabled)")
src/risk_layer/kill_switch/cli.py:102:def cmd_recover(args, kill_switch: KillSwitch):
src/risk_layer/kill_switch/cli.py:103:    """Request kill switch recovery."""
src/risk_layer/kill_switch/cli.py:112:    success = kill_switch.request_recovery(
src/risk_layer/kill_switch/cli.py:130:    audit_dir = config.get("kill_switch", {}).get("audit_dir", "data/kill_switch/audit")
src/risk_layer/kill_switch/cli.py:178:    recovery_config = config.get("kill_switch.recovery", {})
src/risk_layer/kill_switch/cli.py:222:    subparsers.add_parser("status", help="Show kill switch status")
src/risk_layer/kill_switch/cli.py:225:    trigger_parser = subparsers.add_parser("trigger", help="Trigger kill switch")
src/risk_layer/kill_switch/cli.py:254:        kill_switch_config = config.get("kill_switch", {})
src/risk_layer/kill_switch/cli.py:259:    # Initialize kill switch for most commands
src/risk_layer/kill_switch/cli.py:262:            kill_switch = KillSwitch(kill_switch_config, logger=logger)
src/risk_layer/kill_switch/cli.py:264:            logger.error(f"Failed to initialize kill switch: {e}")
src/risk_layer/kill_switch/cli.py:270:            cmd_status(args, kill_switch)
src/risk_layer/kill_switch/cli.py:272:            cmd_trigger(args, kill_switch)
src/risk_layer/kill_switch/cli.py:274:            cmd_recover(args, kill_switch)
src/risk/validation/backtest_runner.py:11:from src.risk.validation.kupiec_pof import KupiecResult, kupiec_pof_test
src/risk/validation/backtest_runner.py:12:from src.risk.validation.traffic_light import TrafficLightResult, basel_traffic_light
src/risk/validation/backtest_runner.py:13:from src.risk.validation.breach_analysis import BreachAnalysis, analyze_breaches
src/ops/test_health_runner.py:126:        enabled: Ob Strategy-Coverage-Checks aktiviert sind
src/ops/test_health_runner.py:134:    enabled: bool = True
src/ops/test_health_runner.py:166:        enabled: Ob Coverage-Check aktiviert war
src/ops/test_health_runner.py:174:    enabled: bool
src/ops/test_health_runner.py:193:        enabled: Ob Sanity-Check aktiviert ist
src/ops/test_health_runner.py:202:    enabled: bool = True
src/ops/test_health_runner.py:226:        enabled: Ob Check aktiviert war
src/ops/test_health_runner.py:234:    enabled: bool
src/ops/test_health_runner.py:529:def aggregate_health(profile_name: str, results: list[TestCheckResult]) -> TestHealthSummary:
src/ops/test_health_runner.py:719:        enabled=coverage_cfg.get("enabled", True),
src/ops/test_health_runner.py:867:    if not config.enabled:
src/ops/test_health_runner.py:869:            enabled=False,
src/ops/test_health_runner.py:916:        enabled=True,
src/ops/test_health_runner.py:950:        enabled=sanity_cfg.get("enabled", True),
src/ops/test_health_runner.py:993:    if not cfg.enabled:
src/ops/test_health_runner.py:995:            enabled=False,
src/ops/test_health_runner.py:1011:            enabled=True,
src/ops/test_health_runner.py:1024:            enabled=True,
src/ops/test_health_runner.py:1040:                enabled=True,
src/ops/test_health_runner.py:1050:            enabled=True,
src/ops/test_health_runner.py:1082:        enabled=True,
src/ops/test_health_runner.py:1224:    if summary.strategy_coverage and summary.strategy_coverage.enabled:
src/ops/test_health_runner.py:1266:    if summary.switch_sanity and summary.switch_sanity.enabled:
src/ops/test_health_runner.py:1698:    summary = aggregate_health(profile_name, results)
src/ops/test_health_runner.py:1724:            if coverage_cfg.enabled:
src/ops/test_health_runner.py:1762:            if sanity_cfg.enabled:
src/ops/test_health_runner.py:1828:        enabled = slack_config.get("enabled", False)
src/ops/test_health_runner.py:1830:        if not enabled:
src/ops/test_health_runner.py:1886:        # Fail-safe: Slack-Fehler killen nicht die Pipeline
src/ops/test_health_runner.py:1952:        if coverage.enabled and not coverage.is_healthy:
src/ops/test_health_runner.py:1967:        if sanity.enabled and not sanity.is_ok:
src/risk_layer/kill_switch/execution_gate.py:3:Provides the gate interface that blocks trading when kill switch is active.
src/risk_layer/kill_switch/execution_gate.py:12:    """Protocol for execution gate.
src/risk_layer/kill_switch/execution_gate.py:14:    This defines the contract that any execution gate must implement.
src/risk_layer/kill_switch/execution_gate.py:32:    Integrates kill switch with the execution layer.
src/risk_layer/kill_switch/execution_gate.py:33:    Every order MUST pass through this gate.
src/risk_layer/kill_switch/execution_gate.py:36:        >>> gate = ExecutionGate(kill_switch)
src/risk_layer/kill_switch/execution_gate.py:40:        ...     gate.check_can_execute()
src/risk_layer/kill_switch/execution_gate.py:46:        >>> with gate:
src/risk_layer/kill_switch/execution_gate.py:50:    def __init__(self, kill_switch: KillSwitch):
src/risk_layer/kill_switch/execution_gate.py:51:        """Initialize execution gate.
src/risk_layer/kill_switch/execution_gate.py:54:            kill_switch: KillSwitch instance
src/risk_layer/kill_switch/execution_gate.py:56:        self._kill_switch = kill_switch
src/risk_layer/kill_switch/execution_gate.py:65:            TradingBlockedError if kill switch is active
src/risk_layer/kill_switch/execution_gate.py:67:        if self._kill_switch.check_and_block():
src/risk_layer/kill_switch/execution_gate.py:69:                f"Trading blocked: Kill Switch is {self._kill_switch.state.name}"
src/risk_layer/kill_switch/execution_gate.py:74:    def execute_with_gate(self, order_func, *args, **kwargs):
src/risk_layer/kill_switch/execution_gate.py:75:        """Execute order function with gate check.
src/risk_layer/kill_switch/execution_gate.py:96:        return self._kill_switch.check_and_block()
src/risk_layer/kill_switch/execution_gate.py:107:        status = self._kill_switch.get_status()
src/risk_layer/kill_switch/execution_gate.py:111:            return f"Kill Switch triggered at {status.get('killed_at', 'unknown')}"
src/risk_layer/kill_switch/execution_gate.py:120:        """Enter context - check gate."""
src/infra/escalation/network_gate.py:21:    Default must deny when allow_network=True unless explicit gates are satisfied.
src/infra/escalation/network_gate.py:22:    Gates are config-based (no env vars): confirm_token + armed/enabled flags.
src/infra/escalation/network_gate.py:35:    # Use the same live-gate primitives as PR-02: armed/enabled + confirm token.
src/infra/escalation/network_gate.py:37:    # but network escalation can still be gated with the same confirm-token discipline.
src/infra/escalation/network_gate.py:38:    if not getattr(cfg, "enable_live_trading", False):
src/infra/escalation/network_gate.py:40:            f"Network escalation blocked: enable_live_trading=false (context={context})"
src/infra/escalation/network_gate.py:42:    if not getattr(cfg, "live_mode_armed", False):
src/infra/escalation/network_gate.py:43:        raise RuntimeError(f"Network escalation blocked: live_mode_armed=false (context={context})")
src/scheduler/models.py:50:        enabled: Ob der Job aktiv ist
src/scheduler/models.py:61:    enabled: bool = True
src/knowledge/vector_db.py:51:            "Set KNOWLEDGE_READONLY=false to enable writes."
src/ai_orchestration/orchestrator.py:119:        self.enabled = os.getenv("ORCHESTRATOR_ENABLED", "false").lower() == "true"
src/ai_orchestration/orchestrator.py:280:        # Safety check: Orchestrator enabled?
src/ai_orchestration/orchestrator.py:281:        if not self.enabled:
src/ai_orchestration/orchestrator.py:284:                "Set ORCHESTRATOR_ENABLED=true to enable."
src/ai_orchestration/orchestrator.py:362:            "enabled": self.enabled,
src/ai_orchestration/orchestrator.py:367:            "status": "healthy" if self.enabled else "disabled",
src/scheduler/runner.py:99:    if not job.enabled:
src/meta/infostream/evaluator.py:91:risk_assessment:
src/meta/infostream/evaluator.py:128:- risk_level: low
src/meta/infostream/evaluator.py:259:        - risk_level: str
src/meta/infostream/evaluator.py:260:        - risk_notes: str
src/meta/infostream/evaluator.py:273:        "risk_level": "none",
src/meta/infostream/evaluator.py:274:        "risk_notes": "",
src/meta/infostream/evaluator.py:315:        elif line.startswith("risk_assessment:"):
src/meta/infostream/evaluator.py:319:            current_section = "risk_assessment"
src/meta/infostream/evaluator.py:322:            result["risk_level"] = line.split(":", 1)[1].strip()
src/meta/infostream/evaluator.py:324:            result["risk_notes"] = line.split(":", 1)[1].strip()
src/meta/infostream/evaluator.py:464:        risk_level=eval_data.get("risk_level", "none"),
src/meta/infostream/evaluator.py:465:        risk_notes=eval_data.get("risk_notes", ""),
src/execution_simple/pipeline.py:5:Orchestrates order generation, gate validation, and execution.
src/execution_simple/pipeline.py:13:from .gates import Gate
src/execution_simple/pipeline.py:32:    3. Validate through gates (in order)
src/execution_simple/pipeline.py:46:        gates: list[Gate],
src/execution_simple/pipeline.py:53:            gates: List of gates to apply (in order)
src/execution_simple/pipeline.py:56:        self.gates = gates
src/execution_simple/pipeline.py:74:            ExecutionResult with orders, fills, and gate decisions
src/execution_simple/pipeline.py:106:        # 5. Apply gates in order
src/execution_simple/pipeline.py:107:        for gate in self.gates:
src/execution_simple/pipeline.py:108:            decision = gate.check(intent, context)
src/execution_simple/pipeline.py:109:            result.gate_decisions.append(decision)
src/execution_simple/pipeline.py:111:            # If gate blocks, stop pipeline
src/execution_simple/pipeline.py:114:                result.block_reason = f"{gate.name}: {decision.reason}"
src/execution_simple/pipeline.py:117:            # If gate modifies quantity, update intent
src/execution_simple/pipeline.py:121:        # 6. All gates passed - create validated order
src/infra/escalation/providers.py:10:from src.infra.escalation.network_gate import ensure_may_use_network_escalation
src/infra/escalation/providers.py:19:    """allow_network=true is explicit risk acceptance. Retries/backoff small and deterministic; no infinite loops."""
src/infra/escalation/providers.py:114:        # SAFETY: never send raw risk/strategy payload; send reason codes + hashes only (custom_details filtered).
src/infra/escalation/providers.py:273:        enable_real_calls: bool = False,
src/infra/escalation/providers.py:277:        self._enable_real_calls = enable_real_calls
src/infra/escalation/providers.py:289:        if self._enable_real_calls and self._api_url:
src/infra/escalation/providers.py:291:                "[PAGERDUTY-STUB] Real calls enabled but not implemented in Phase 85"
src/scheduler/config_loader.py:43:        enabled = true
src/scheduler/config_loader.py:70:            enabled=raw.get("enabled", True),
src/experiments/regime_sweeps.py:29:    ...         "enabled": True,
src/risk/validation/__init__.py:25:>>> from src.risk.validation import kupiec_pof_test, run_var_backtest_suite
src/risk/validation/__init__.py:39:from src.risk.validation.kupiec_pof import (
src/risk/validation/__init__.py:46:from src.risk.validation.traffic_light import (
src/risk/validation/__init__.py:52:from src.risk.validation.backtest_runner import (
src/risk/validation/__init__.py:58:from src.risk.validation.breach_analysis import (
src/risk/validation/__init__.py:64:from src.risk.validation.christoffersen import (
src/risk/validation/__init__.py:71:from src.risk.validation.suite_runner import (
src/risk/validation/__init__.py:76:from src.risk.validation.report_formatter import (
src/risk/validation/__init__.py:81:from src.risk.validation.report_index import (
src/risk/validation/__init__.py:91:from src.risk.validation.report_compare import (
src/risk_layer/kill_switch/core.py:58:        # Compatibility: Override flag for enabled property (does NOT mutate config)
src/risk_layer/kill_switch/core.py:59:        self._enabled_override: Optional[bool] = None
src/risk_layer/kill_switch/core.py:72:        self._on_kill_callbacks: List[Callable[[KillSwitchEvent], None]] = []
src/risk_layer/kill_switch/core.py:76:        self._killed_at: Optional[datetime] = None
src/risk_layer/kill_switch/core.py:93:    def is_killed(self) -> bool:
src/risk_layer/kill_switch/core.py:103:    def enabled(self) -> bool:
src/risk_layer/kill_switch/core.py:104:        """Check if Kill Switch is enabled.
src/risk_layer/kill_switch/core.py:110:            2. Config "enabled" key
src/risk_layer/kill_switch/core.py:114:            True if enabled, False if disabled
src/risk_layer/kill_switch/core.py:117:        if self._enabled_override is not None:
src/risk_layer/kill_switch/core.py:118:            return bool(self._enabled_override)
src/risk_layer/kill_switch/core.py:127:            return bool(cfg.get("enabled", True))
src/risk_layer/kill_switch/core.py:129:        return bool(getattr(cfg, "enabled", True))
src/risk_layer/kill_switch/core.py:131:    @enabled.setter
src/risk_layer/kill_switch/core.py:132:    def enabled(self, value: bool) -> None:
src/risk_layer/kill_switch/core.py:133:        """Set enabled override.
src/risk_layer/kill_switch/core.py:138:            value: True to enable, False to disable
src/risk_layer/kill_switch/core.py:141:            self._enabled_override = bool(value)
src/risk_layer/kill_switch/core.py:142:            self._logger.debug(f"Kill Switch enabled override set to: {value}")
src/risk_layer/kill_switch/core.py:146:        """True if kill switch is disabled (backtest mode)."""
src/risk_layer/kill_switch/core.py:165:            True if successfully triggered or already killed
src/risk_layer/kill_switch/core.py:180:            self._killed_at = datetime.utcnow()
src/risk_layer/kill_switch/core.py:184:                timestamp=self._killed_at,
src/risk_layer/kill_switch/core.py:199:            callbacks = list(self._on_kill_callbacks)
src/risk_layer/kill_switch/core.py:301:            self._killed_at = None
src/risk_layer/kill_switch/core.py:318:            True if trading is BLOCKED (killed or recovering)
src/risk_layer/kill_switch/core.py:322:            if kill_switch.check_and_block():
src/risk_layer/kill_switch/core.py:325:        return self.is_killed
src/risk_layer/kill_switch/core.py:327:    def register_on_kill(self, callback: Callable[[KillSwitchEvent], None]):
src/risk_layer/kill_switch/core.py:328:        """Register callback for kill events.
src/risk_layer/kill_switch/core.py:331:            callback: Function to call when kill switch is triggered
src/risk_layer/kill_switch/core.py:334:            self._on_kill_callbacks.append(callback)
src/risk_layer/kill_switch/core.py:349:            List of all kill switch events
src/risk_layer/kill_switch/core.py:363:                "is_killed": self.is_killed,
src/risk_layer/kill_switch/core.py:365:                "killed_at": self._killed_at.isoformat() if self._killed_at else None,
src/meta/infostream/collector.py:141:    if strategy_coverage and strategy_coverage.get("enabled"):
src/meta/infostream/collector.py:147:    if switch_sanity and switch_sanity.get("enabled"):
src/knowledge/timeseries_db.py:60:            "Set KNOWLEDGE_READONLY=false to enable writes."
src/meta/infostream/models.py:126:        risk_level: Risiko-EinschÃ¤tzung ("none", "low", "medium", "high", "critical")
src/meta/infostream/models.py:127:        risk_notes: ErlÃ¤uterungen zur Risiko-EinschÃ¤tzung
src/meta/infostream/models.py:135:    risk_level: RiskLevel = "none"
src/meta/infostream/models.py:136:    risk_notes: str = ""
src/risk_layer/var_backtest/duration_diagnostics.py:26:This is a DIAGNOSTIC tool, not a primary validation gate.
src/risk_layer/var_backtest/duration_diagnostics.py:225:    enable_exponential_test: bool = False,
src/risk_layer/var_backtest/duration_diagnostics.py:231:    This is a DIAGNOSTIC tool, not a formal hypothesis test gate.
src/risk_layer/var_backtest/duration_diagnostics.py:239:        enable_exponential_test: Whether to run exponential goodness-of-fit test
src/risk_layer/var_backtest/duration_diagnostics.py:339:    if enable_exponential_test and n_durations >= 3:
src/risk_layer/var_backtest/duration_diagnostics.py:379:        - Provided as optional diagnostic, not primary gate
src/ai_orchestration/l4_critic_determinism_contract.py:183:    - Normalize paths (if enabled)
src/risk_layer/kill_switch/__init__.py:7:    - KillSwitch: Main kill switch class
src/risk_layer/kill_switch/__init__.py:13:    >>> from src.risk_layer.kill_switch import KillSwitch
src/risk_layer/kill_switch/__init__.py:37:from .execution_gate import ExecutionGate
src/risk_layer/kill_switch/__init__.py:41:# Legacy compatibility stubs for old risk_gate integration
src/risk_layer/kill_switch/__init__.py:42:def to_violations(kill_switch_status):
src/risk_layer/kill_switch/__init__.py:43:    """Convert kill switch status to violations (legacy compatibility stub)."""
src/risk_layer/kill_switch/__init__.py:44:    from src.risk_layer.models import Violation
src/risk_layer/kill_switch/__init__.py:46:    if hasattr(kill_switch_status, "armed") and kill_switch_status.armed:
src/risk_layer/kill_switch/__init__.py:50:                message=getattr(kill_switch_status, "reason", "Kill switch is armed"),
src/risk_layer/kill_switch/__init__.py:68:    # Extract kill_switch config from PeakConfig if needed
src/risk_layer/kill_switch/__init__.py:71:        kill_switch_config = config.get("risk.kill_switch", {})
src/risk_layer/kill_switch/__init__.py:72:    elif isinstance(config, dict) and "risk" in config:
src/risk_layer/kill_switch/__init__.py:74:        kill_switch_config = config.get("risk", {}).get("kill_switch", {})
src/risk_layer/kill_switch/__init__.py:76:        # Already a kill_switch config dict
src/risk_layer/kill_switch/__init__.py:77:        kill_switch_config = config if isinstance(config, dict) else {}
src/risk_layer/kill_switch/__init__.py:79:    return KillSwitchAdapter(KillSwitch(kill_switch_config))
src/infra/escalation/__init__.py:25:    # Event eskalieren (nur wenn kritisch + enabled)
src/ai_orchestration/trends/trend_ledger.py:70:        counters: Aggregated counters (checks, findings, etc.)
src/ai_orchestration/trends/trend_ledger.py:259:    Build aggregated counters from seed.
src/ops/gates/armed_gate.py:11:    enabled: bool
src/ops/gates/armed_gate.py:12:    armed: bool
src/ops/gates/armed_gate.py:13:    armed_since_epoch: Optional[int]
src/ops/gates/armed_gate.py:19:    Two-stage execution gate:
src/ops/gates/armed_gate.py:20:      - enabled: feature toggle (config-controlled)
src/ops/gates/armed_gate.py:21:      - armed: runtime state requiring short-lived confirm token
src/ops/gates/armed_gate.py:61:        if not state.enabled:
src/ops/gates/armed_gate.py:67:            enabled=True,
src/ops/gates/armed_gate.py:68:            armed=True,
src/ops/gates/armed_gate.py:69:            armed_since_epoch=int(now_epoch),
src/ops/gates/armed_gate.py:75:            enabled=bool(state.enabled),
src/ops/gates/armed_gate.py:76:            armed=False,
src/ops/gates/armed_gate.py:77:            armed_since_epoch=None,
src/ops/gates/armed_gate.py:82:    def require_armed(state: ArmedState) -> None:
src/ops/gates/armed_gate.py:83:        if not (state.enabled and state.armed):
src/ops/gates/armed_gate.py:84:            raise RuntimeError("Execution blocked: gate not armed")
src/experiments/regime_aware_portfolio_sweeps.py:18:    ['risk_on_scale', 'neutral_scale', 'risk_off_scale']
src/experiments/regime_aware_portfolio_sweeps.py:50:    - risk_on_scale: Skalierungsfaktor fÃ¼r Risk-On-Regime
src/experiments/regime_aware_portfolio_sweeps.py:52:    - risk_off_scale: Skalierungsfaktor fÃ¼r Risk-Off-Regime
src/experiments/regime_aware_portfolio_sweeps.py:59:        sweeps.append(ParamSweep("risk_on_scale", [1.0], "Risk-On Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:61:        sweeps.append(ParamSweep("risk_off_scale", [0.0, 0.1, 0.2], "Risk-Off Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:64:        sweeps.append(ParamSweep("risk_on_scale", [1.0], "Risk-On Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:66:        sweeps.append(ParamSweep("risk_off_scale", [0.0, 0.1, 0.2, 0.3], "Risk-Off Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:70:        sweeps.append(ParamSweep("risk_on_scale", [0.9, 1.0], "Risk-On Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:72:        sweeps.append(ParamSweep.from_range("risk_off_scale", 0.0, 0.4, 0.1, "Risk-Off Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:119:        sweeps.append(ParamSweep("risk_on_scale", [1.0], "Risk-On Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:123:        sweeps.append(ParamSweep("risk_off_scale", [0.0, 0.1], "Risk-Off Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:126:        sweeps.append(ParamSweep("risk_on_scale", [1.0], "Risk-On Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:128:        sweeps.append(ParamSweep("risk_off_scale", [0.0, 0.05, 0.1, 0.15, 0.2], "Risk-Off Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:132:        sweeps.append(ParamSweep("risk_on_scale", [1.0], "Risk-On Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:134:        sweeps.append(ParamSweep.from_range("risk_off_scale", 0.0, 0.25, 0.05, "Risk-Off Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:164:        sweeps.append(ParamSweep("risk_on_scale", [1.0], "Risk-On Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:168:        sweeps.append(ParamSweep("risk_off_scale", [0.0], "Risk-Off Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:171:        sweeps.append(ParamSweep("risk_on_scale", [1.0], "Risk-On Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:173:        sweeps.append(ParamSweep("risk_off_scale", [0.0], "Risk-Off Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:177:        sweeps.append(ParamSweep("risk_on_scale", [1.0], "Risk-On Scale"))
src/experiments/regime_aware_portfolio_sweeps.py:179:        sweeps.append(ParamSweep("risk_off_scale", [0.0], "Risk-Off Scale"))
src/ai_orchestration/runner.py:73:        Perform dry-run: validate orchestration + generate artifacts.
src/ai_orchestration/runner.py:146:            run_type="dry-run",
src/risk_layer/kill_switch/adapter.py:6:and the old KillSwitchLayer (Evaluator API) used by risk_gate.
src/risk_layer/kill_switch/adapter.py:8:**This adapter is TEMPORARY and should be removed once risk_gate is refactored
src/risk_layer/kill_switch/adapter.py:12:- Refactor risk_gate to use KillSwitch State Machine API directly
src/risk_layer/kill_switch/adapter.py:18:- Target Removal: Q1 2026 (after risk_gate refactoring)
src/risk_layer/kill_switch/adapter.py:32:    armed: bool
src/risk_layer/kill_switch/adapter.py:34:    enabled: bool = True
src/risk_layer/kill_switch/adapter.py:56:      - evaluate(risk_metrics) -> KillSwitchStatus (armed/reason)
src/risk_layer/kill_switch/adapter.py:61:    def __init__(self, kill_switch: Any):
src/risk_layer/kill_switch/adapter.py:62:        self._kill_switch = kill_switch
src/risk_layer/kill_switch/adapter.py:65:    # --- enabled passthrough ---
src/risk_layer/kill_switch/adapter.py:67:    def enabled(self) -> bool:
src/risk_layer/kill_switch/adapter.py:68:        return bool(getattr(self._kill_switch, "enabled", True))
src/risk_layer/kill_switch/adapter.py:70:    @enabled.setter
src/risk_layer/kill_switch/adapter.py:71:    def enabled(self, value: bool) -> None:
src/risk_layer/kill_switch/adapter.py:72:        setattr(self._kill_switch, "enabled", bool(value))
src/risk_layer/kill_switch/adapter.py:76:    def is_armed(self) -> bool:
src/risk_layer/kill_switch/adapter.py:77:        """Legacy property: True if kill switch is armed."""
src/risk_layer/kill_switch/adapter.py:78:        return bool(getattr(self._kill_switch, "is_killed", False))
src/risk_layer/kill_switch/adapter.py:83:        state_enum = getattr(self._kill_switch, "state", None)
src/risk_layer/kill_switch/adapter.py:92:    def evaluate(self, risk_metrics: Any) -> KillSwitchStatus:
src/risk_layer/kill_switch/adapter.py:93:        """Evaluate kill switch based on risk metrics (legacy API)."""
src/risk_layer/kill_switch/adapter.py:94:        # Convert risk_metrics to dict if needed
src/risk_layer/kill_switch/adapter.py:95:        metrics_dict = self._to_dict(risk_metrics)
src/risk_layer/kill_switch/adapter.py:97:        # Disabled â†’ nie armed
src/risk_layer/kill_switch/adapter.py:98:        if not self.enabled:
src/risk_layer/kill_switch/adapter.py:100:                armed=False,
src/risk_layer/kill_switch/adapter.py:107:        # 1) Wenn schon killed â†’ sofort armed
src/risk_layer/kill_switch/adapter.py:108:        if bool(getattr(self._kill_switch, "is_killed", False)):
src/risk_layer/kill_switch/adapter.py:110:                armed=True,
src/risk_layer/kill_switch/adapter.py:117:        # 2) Trigger anhand risk_metrics prÃ¼fen
src/risk_layer/kill_switch/adapter.py:120:        armed_now = bool(getattr(self._kill_switch, "is_killed", False))
src/risk_layer/kill_switch/adapter.py:121:        if armed_now:
src/risk_layer/kill_switch/adapter.py:123:                armed=True,
src/risk_layer/kill_switch/adapter.py:131:            armed=False,
src/risk_layer/kill_switch/adapter.py:140:        if not self.enabled:
src/risk_layer/kill_switch/adapter.py:142:                armed=False,
src/risk_layer/kill_switch/adapter.py:149:        state_enum = getattr(self._kill_switch, "state", None)
src/risk_layer/kill_switch/adapter.py:150:        is_killed = bool(getattr(self._kill_switch, "is_killed", False))
src/risk_layer/kill_switch/adapter.py:152:        if is_killed:
src/risk_layer/kill_switch/adapter.py:159:            armed=False,
src/risk_layer/kill_switch/adapter.py:168:        """Convert risk_metrics to dict."""
src/risk_layer/kill_switch/adapter.py:179:        armed: bool,
src/risk_layer/kill_switch/adapter.py:187:        state_enum = getattr(self._kill_switch, "state", None)
src/risk_layer/kill_switch/adapter.py:191:            armed=bool(armed),
src/risk_layer/kill_switch/adapter.py:193:            enabled=self.enabled,
src/risk_layer/kill_switch/adapter.py:207:        reg = getattr(self._kill_switch, "trigger_registry", None) or getattr(
src/risk_layer/kill_switch/adapter.py:208:            self._kill_switch, "_trigger_registry", None
src/risk_layer/kill_switch/adapter.py:226:        triggers = getattr(self._kill_switch, "triggers", None) or getattr(
src/risk_layer/kill_switch/adapter.py:227:            self._kill_switch, "_triggers", None
src/risk_layer/kill_switch/adapter.py:273:                meta.setdefault("risk_metrics", dict(context))
src/risk_layer/kill_switch/adapter.py:275:                trig = getattr(self._kill_switch, "trigger", None)
src/risk_layer/kill_switch/adapter.py:289:            trig = getattr(self._kill_switch, "trigger", None)
src/risk_layer/kill_switch/adapter.py:292:                    trig(reason, triggered_by=trigger_name, metadata={"risk_metrics": context})
src/risk_layer/kill_switch/adapter.py:307:        lock = getattr(self._kill_switch, "_lock", None)
src/risk_layer/kill_switch/adapter.py:316:        state_enum = getattr(self._kill_switch, "state", None)
src/risk_layer/kill_switch/adapter.py:320:        setattr(self._kill_switch, "_state", KillSwitchState.ACTIVE)
src/risk_layer/kill_switch/adapter.py:321:        setattr(self._kill_switch, "_killed_at", None)
src/risk_layer/kill_switch/adapter.py:322:        setattr(self._kill_switch, "_recovery_started_at", None)
src/risk_layer/kill_switch/adapter.py:325:        logger = getattr(self._kill_switch, "_logger", None)
src/risk_layer/kill_switch/adapter.py:332:        events = getattr(self._kill_switch, "_events", None)
src/risk_layer/kill_switch/adapter.py:339:                triggered_by="risk_gate",
src/execution_simple/builder.py:13:from .gates import LotSizeGate, MinNotionalGate, PriceSanityGate, ResearchOnlyGate
src/execution_simple/builder.py:32:    [execution.gates]
src/execution_simple/builder.py:53:    block_research_in_live = bool(cfg.get("execution.gates.block_research_in_live", True))
src/execution_simple/builder.py:64:    # Build gates in order:
src/execution_simple/builder.py:69:    gates = [
src/execution_simple/builder.py:85:    pipeline = ExecutionPipeline(gates=gates, adapter=adapter)
src/sweeps/engine.py:34:from src.core.risk import build_risk_manager_from_config
src/sweeps/engine.py:514:        risk_manager = build_risk_manager_from_config(cfg, section="risk_management")
src/sweeps/engine.py:530:            risk_manager=risk_manager,
src/risk/validation/traffic_light.py:5:Prefer importing from: src.risk_layer.var_backtest.traffic_light
src/risk/validation/traffic_light.py:7:The canonical implementation lives in src/risk_layer/var_backtest/traffic_light.py
src/risk/validation/traffic_light.py:22:from src.risk_layer.var_backtest.traffic_light import (
src/risk/validation/traffic_light.py:47:        "src.risk.validation.traffic_light is deprecated; "
src/risk/validation/traffic_light.py:48:        "prefer src.risk_layer.var_backtest.traffic_light",
src/risk/validation/traffic_light.py:126:    **WRAPPER**: This function now delegates to the canonical engine
src/risk/validation/traffic_light.py:127:    (src.risk_layer.var_backtest.traffic_light.basel_traffic_light) for all computation.
src/risk/validation/traffic_light.py:173:    # Delegate to canonical engine
src/risk/validation/traffic_light.py:204:    **WRAPPER**: This function now delegates to the canonical engine
src/risk/validation/traffic_light.py:205:    (src.risk_layer.var_backtest.traffic_light.compute_zone_thresholds).
src/risk/validation/traffic_light.py:227:    # Delegate to canonical engine
src/risk_layer/var_backtest/kupiec_pof.py:480:        - Delegates to kupiec_lr_uc() for computation
src/ai_orchestration/model_client.py:267:    SAFETY: convert rich runtime payload (risk/strategy details) into a minimal allowlisted envelope.
src/ai_orchestration/model_client.py:292:        "risk",
src/ai_orchestration/model_client.py:294:        "gate",
src/infra/escalation/models.py:91:        enabled: Ob dieses Target aktiv ist
src/infra/escalation/models.py:98:    enabled: bool = True
src/infra/escalation/models.py:107:            "enabled": self.enabled,
src/infra/escalation/models.py:118:            enabled=data.get("enabled", True),
src/experiments/r_and_d_presets.py:53:        enabled: Ob das Preset aktiviert ist
src/experiments/r_and_d_presets.py:69:    enabled: bool = False
src/experiments/r_and_d_presets.py:97:            "enabled": self.enabled,
src/experiments/r_and_d_presets.py:165:        enabled=preset_data.get("enabled", False),
src/docs/Peak_Trade_0_trades_debug_summary.md:9:- klarer Modulstruktur (`core`, `data`, `risk`, `strategies`, `backtest`, `features`, `theory`)
src/docs/Peak_Trade_0_trades_debug_summary.md:30:  - `risk/` â€“ Position Sizing
src/docs/Peak_Trade_0_trades_debug_summary.md:47:    - `risk` (z.B. `risk_per_trade`, `max_position_size`, `min_position_value`)
src/docs/Peak_Trade_0_trades_debug_summary.md:58:  python -c "from src.core import get_config; cfg = get_config(); print('Risk:', cfg.risk.risk_per_trade)"
src/docs/Peak_Trade_0_trades_debug_summary.md:81:- `src/risk/position_sizer.py`
src/docs/Peak_Trade_0_trades_debug_summary.md:87:      - `risk_per_trade` (z.B. 1 % des Kapitals)
src/ops/gates/risk_gate.py:15:    KILL_SWITCH = "kill_switch"
src/ops/gates/risk_gate.py:21:    enabled: bool = True
src/ops/gates/risk_gate.py:22:    kill_switch: bool = False
src/ops/gates/risk_gate.py:48:def evaluate_risk(limits: RiskLimits, ctx: RiskContext) -> RiskDecision:
src/ops/gates/risk_gate.py:49:    if not limits.enabled:
src/ops/gates/risk_gate.py:50:        return RiskDecision(False, RiskDenyReason.DISABLED, {"enabled": "false"})
src/ops/gates/risk_gate.py:51:    if limits.kill_switch:
src/ops/gates/risk_gate.py:52:        return RiskDecision(False, RiskDenyReason.KILL_SWITCH, {"kill_switch": "true"})
src/risk_layer/kill_switch/triggers/base.py:17:        should_trigger: Whether kill switch should be triggered
src/risk_layer/kill_switch/triggers/base.py:50:        enabled: Whether trigger is enabled
src/risk_layer/kill_switch/triggers/base.py:62:        self.enabled = config.get("enabled", True)
src/risk_layer/kill_switch/triggers/base.py:120:            f"enabled={self.enabled}, "
src/ai_orchestration/transcript_store.py:215:                                    "**Uncertainty Level:** HIGH (geopolitical risks)",
src/ai_orchestration/transcript_store.py:265:                                    "- Add quantitative risk metrics\n"
src/ai_orchestration/transcript_store.py:266:                                    "- Clarify geopolitical risk scenarios\n\n"
src/ai_orchestration/l4_critic.py:69:    risk_notes: List[str]
src/ai_orchestration/l4_critic.py:358:6. **Risk Notes**: What risks are present?
src/ai_orchestration/l4_critic.py:369:RISK_NOTES: <comma-separated risk notes>
src/ai_orchestration/l4_critic.py:399:        risk_notes_match = re.search(r"RISK_NOTES:\s*(.+?)(?=\n##)", critic_output, re.DOTALL)
src/ai_orchestration/l4_critic.py:413:        risk_notes = []
src/ai_orchestration/l4_critic.py:414:        if risk_notes_match:
src/ai_orchestration/l4_critic.py:415:            risk_notes = [r.strip() for r in risk_notes_match.group(1).split(",") if r.strip()]
src/ai_orchestration/l4_critic.py:425:            risk_notes=risk_notes,
src/ai_orchestration/l4_critic.py:477:        # Map severity to risk level
src/ai_orchestration/l4_critic.py:478:        risk_map = {
src/ai_orchestration/l4_critic.py:484:        risk_level = risk_map.get(decision.severity, RiskLevel.MEDIUM)
src/ai_orchestration/l4_critic.py:504:        # Add risk notes as separate findings
src/ai_orchestration/l4_critic.py:505:        for idx, risk_note in enumerate(decision.risk_notes, start=2):
src/ai_orchestration/l4_critic.py:509:                    title=f"Risk Note: {risk_note[:50]}...",
src/ai_orchestration/l4_critic.py:512:                    rationale=risk_note,
src/ai_orchestration/l4_critic.py:543:            risk_level=risk_level,
src/ai_orchestration/l4_critic.py:653:{chr(10).join(f"- {note}" for note in decision.risk_notes) if decision.risk_notes else "- None"}
src/ai_orchestration/l4_critic.py:675:            "risk_notes": decision.risk_notes,
src/execution_simple/types.py:5:Defines core types for order execution, gates, and results.
src/execution_simple/types.py:61:    Trading intent before gate validation.
src/execution_simple/types.py:78:    Passed all gates and ready to send to broker.
src/execution_simple/types.py:121:    Result from a gate check.
src/execution_simple/types.py:124:        gate_name: Name of the gate
src/execution_simple/types.py:125:        passed: Whether order passed gate
src/execution_simple/types.py:127:        modified_qty: If gate modified quantity (e.g., rounding)
src/execution_simple/types.py:130:    gate_name: str
src/execution_simple/types.py:144:        gate_decisions: All gate decisions
src/execution_simple/types.py:145:        orders: Validated orders (if any gates passed)
src/execution_simple/types.py:153:    gate_decisions: list[GateDecision] = field(default_factory=list)
src/risk/validation/suite_runner.py:4:Aggregates all VaR backtests (Kupiec POF, Basel Traffic Light, Christoffersen IND/CC)
src/risk/validation/suite_runner.py:26:    Aggregated result of all VaR backtest suite tests.
src/risk_layer/kill_switch/triggers/external.py:27:            "enabled": true,
src/risk_layer/kill_switch/triggers/external.py:62:        if not self.enabled:
src/risk_layer/kill_switch/triggers/external.py:150:            f"enabled={self.enabled}"
src/risk_layer/var_backtest/christoffersen_tests.py:331:    from src.risk_layer.var_backtest.kupiec_pof import _compute_lr_statistic
src/risk_layer/var_backtest/christoffersen_tests.py:558:    from src.risk_layer.var_backtest.kupiec_pof import chi2_df1_ppf
src/risk_layer/var_backtest/christoffersen_tests.py:669:    from src.risk_layer.var_backtest.kupiec_pof import kupiec_pof_test
src/docs/Peak_Trade_Registry_Engine_Overview.md:119:  default_base_risk = 0.01
src/docs/Peak_Trade_Registry_Engine_Overview.md:125:  enabled        = true
src/docs/Peak_Trade_Registry_Engine_Overview.md:133:  - `enabled`       â†’ globales Ein/Aus.
src/docs/Peak_Trade_Registry_Engine_Overview.md:145:  risk_per_trade = 0.01
src/docs/Peak_Trade_Registry_Engine_Overview.md:184:   - gefiltert nach `enabled = true`
src/docs/Peak_Trade_Registry_Engine_Overview.md:273:     - Strategien in `[strategies.*]` auf `enabled = true` setzen, die du nutzen willst.
src/backtest/stats.py:110:    equity: pd.Series, periods_per_year: int = 252, risk_free_rate: float = 0.0
src/backtest/stats.py:118:        risk_free_rate: Risikofreier Zinssatz (annualisiert)
src/backtest/stats.py:124:        Sharpe = (mean_return - risk_free) / std_return * sqrt(periods_per_year)
src/backtest/stats.py:139:    sharpe = (mean_return - risk_free_rate) / std_return
src/backtest/stats.py:232:    risk_free_rate: float = 0.0,
src/backtest/stats.py:247:        risk_free_rate: Risikofreier Zinssatz (annualisiert, default: 0)
src/backtest/stats.py:286:        equity_curve, periods_per_year=periods_per_year, risk_free_rate=risk_free_rate
src/backtest/stats.py:291:        equity_curve, periods_per_year=periods_per_year, risk_free_rate=risk_free_rate
src/backtest/stats.py:327:    risk_free_rate: float = 0.0,
src/backtest/stats.py:335:        risk_free_rate: Risikofreier Zinssatz (annualisiert)
src/backtest/stats.py:364:    sortino = (mean_return - risk_free_rate) / downside_std_annual
src/backtest/stats.py:400:        warnings.append(f"Sharpe Ratio {sharpe:.2f} < 1.5 (zu riskant)")
src/ai_orchestration/l1_runner.py:392:            "enable live",
src/ai_orchestration/l1_runner.py:393:            "modify risk limit",
src/experiments/strategy_profiles.py:247:        name: Regime-Name (z.B. "risk_on", "neutral", "risk_off")
src/autonomous/monitors.py:250:    Monitor for trading performance and risk metrics.
src/ai_orchestration/run_manifest.py:31:    run_type: str  # "dry-run" or "live-run"
src/ai_orchestration/run_manifest.py:148:        run_type: str = "dry-run",
src/ai_orchestration/run_manifest.py:169:            run_type: Run type (default: "dry-run")
src/risk/position_sizer_old_backup.py:7:    risk_amount = equity * risk_per_trade
src/risk/position_sizer_old_backup.py:8:    size = risk_amount / abs(entry_price - stop_price)
src/risk/position_sizer_old_backup.py:22:    risk_per_trade: float  # z.B. 0.01 = 1%
src/risk/position_sizer_old_backup.py:31:    risk_amount: float  # Risikobetrag in USD
src/risk/position_sizer_old_backup.py:32:    risk_percent: float  # Risiko in %
src/risk/position_sizer_old_backup.py:48:        req: PositionRequest mit equity, entry, stop, risk
src/risk/position_sizer_old_backup.py:54:        PositionResult mit size, value, risk, oder rejected=True
src/risk/position_sizer_old_backup.py:67:        ...     risk_per_trade=0.01
src/risk/position_sizer_old_backup.py:78:            risk_amount=0,
src/risk/position_sizer_old_backup.py:79:            risk_percent=0,
src/risk/position_sizer_old_backup.py:93:            risk_amount=0,
src/risk/position_sizer_old_backup.py:94:            risk_percent=0,
src/risk/position_sizer_old_backup.py:101:    risk_amount = req.equity * req.risk_per_trade
src/risk/position_sizer_old_backup.py:104:    size = risk_amount / stop_distance
src/risk/position_sizer_old_backup.py:113:            risk_amount=risk_amount,
src/risk/position_sizer_old_backup.py:114:            risk_percent=req.risk_per_trade,
src/risk/position_sizer_old_backup.py:125:            risk_amount=risk_amount,
src/risk/position_sizer_old_backup.py:126:            risk_percent=req.risk_per_trade,
src/risk/position_sizer_old_backup.py:136:        risk_amount=risk_amount,
src/risk/position_sizer_old_backup.py:137:        risk_percent=req.risk_per_trade,
src/risk_layer/kill_switch/triggers/threshold.py:22:            "enabled": true,
src/risk_layer/kill_switch/triggers/threshold.py:70:        if not self.enabled:
src/risk_layer/kill_switch/triggers/threshold.py:121:            f"enabled={self.enabled}"
src/backtest/engine.py:27:from ..core.risk import BaseRiskManager
src/backtest/engine.py:38:from ..risk import (
src/backtest/engine.py:78:        >>> from src.risk import PositionSizer, PositionSizerConfig, RiskLimits, RiskLimitsConfig
src/backtest/engine.py:81:        >>> position_sizer = PositionSizer(PositionSizerConfig(risk_pct=1.0))
src/backtest/engine.py:82:        >>> risk_limits = RiskLimits(RiskLimitsConfig(max_drawdown_pct=20.0))
src/backtest/engine.py:84:        >>> engine = BacktestEngine(position_sizer=position_sizer, risk_limits=risk_limits)
src/backtest/engine.py:92:        risk_limits: Optional[RiskLimits] = None,
src/backtest/engine.py:94:        risk_manager: Optional[BaseRiskManager] = None,
src/backtest/engine.py:106:            risk_limits: RiskLimits-Instanz (default: Default-Config)
src/backtest/engine.py:108:            risk_manager: Optional BaseRiskManager fÃ¼r Drawdown/Equity-Floor Management
src/backtest/engine.py:121:        self.risk_limits = risk_limits or RiskLimits(RiskLimitsConfig())
src/backtest/engine.py:127:        self.risk_manager = risk_manager
src/backtest/engine.py:183:    def _check_risk_limits(
src/backtest/engine.py:207:        ok = self.risk_limits.check_all(
src/backtest/engine.py:384:        if self.risk_manager is not None:
src/backtest/engine.py:385:            self.risk_manager.reset(start_equity=equity)
src/backtest/engine.py:436:                    if self.risk_manager is not None:
src/backtest/engine.py:438:                        risk_kwargs = {
src/backtest/engine.py:450:                                from ..risk import PositionSnapshot
src/backtest/engine.py:452:                                risk_kwargs["positions"] = [
src/backtest/engine.py:463:                        target_units = self.risk_manager.adjust_target_position(
src/backtest/engine.py:468:                            **risk_kwargs,
src/backtest/engine.py:485:                    min_pos_val = self.config["risk"].get("min_position_value", 50.0)
src/backtest/engine.py:491:                    max_pos_pct = self.config["risk"].get("max_position_size", 0.25)
src/backtest/engine.py:503:                        risk_ok = self._check_risk_limits(
src/backtest/engine.py:509:                        if risk_ok:
src/backtest/engine.py:521:                    # Old API: use legacy PositionSizer from risk module
src/backtest/engine.py:526:                        risk_per_trade=self.config["risk"]["risk_per_trade"],
src/backtest/engine.py:531:                        max_position_pct=self.config["risk"]["max_position_size"],
src/backtest/engine.py:532:                        min_position_value=self.config["risk"]["min_position_value"],
src/backtest/engine.py:533:                        min_stop_distance=self.config["risk"]["min_stop_distance"],
src/backtest/engine.py:544:                        risk_ok = self._check_risk_limits(
src/backtest/engine.py:550:                        if risk_ok:
src/backtest/engine.py:664:            "mode": "realistic_with_risk_management",
src/backtest/engine.py:835:        risk_per_trade = self.config["risk"].get("risk_per_trade", 0.02)
src/backtest/engine.py:836:        max_position_pct = self.config["risk"].get("max_position_size", 0.25)
src/backtest/engine.py:1080:    risk_limits: Optional[RiskLimits] = None,
src/backtest/engine.py:1082:    risk_manager: Optional[BaseRiskManager] = None,
src/backtest/engine.py:1098:        risk_limits: Optional custom RiskLimits
src/backtest/engine.py:1136:        risk_limits=risk_limits,
src/backtest/engine.py:1138:        risk_manager=risk_manager,
src/backtest/engine.py:1189:    risk_limits: Optional[RiskLimits] = None,
src/backtest/engine.py:1191:    risk_manager: Optional[BaseRiskManager] = None,
src/backtest/engine.py:1199:    3. Bestimmt Capital Allocation (equal/risk_parity/sharpe_weighted/manual)
src/backtest/engine.py:1211:        risk_limits: Optional custom RiskLimits fÃ¼r alle Strategien
src/backtest/engine.py:1237:    if not portfolio_cfg.get("enabled", False):
src/backtest/engine.py:1239:            "Portfolio-Mode ist deaktiviert. Setze portfolio.enabled=true in config.toml"
src/backtest/engine.py:1278:    if allocation_method in ("risk_parity", "sharpe_weighted"):
src/backtest/engine.py:1285:        risk_free_rate = float(portfolio_cfg.get("risk_free_rate", 0.0))
src/backtest/engine.py:1294:            risk_limits=risk_limits,
src/backtest/engine.py:1296:            risk_manager=risk_manager,
src/backtest/engine.py:1303:            risk_free_rate=risk_free_rate,
src/backtest/engine.py:1332:                risk_limits=risk_limits,
src/backtest/engine.py:1334:                risk_manager=risk_manager,
src/backtest/engine.py:1456:    """v1 inverse-vol weights (risk_parity approximation), long-only, deterministic."""
src/backtest/engine.py:1490:    risk_free_rate: float = 0.0,
src/backtest/engine.py:1499:    rf = float(risk_free_rate)
src/backtest/engine.py:1569:    risk_limits: Optional[RiskLimits],
src/backtest/engine.py:1571:    risk_manager: Optional[BaseRiskManager],
src/backtest/engine.py:1606:                risk_limits=risk_limits,
src/backtest/engine.py:1608:                risk_manager=risk_manager,
src/backtest/engine.py:1640:    risk_free_rate: float = 0.0,
src/backtest/engine.py:1647:    - risk_parity: inverse-vol weights (diag of cov / std floor)
src/backtest/engine.py:1670:    if method == "risk_parity":
src/backtest/engine.py:1679:            raise ValueError("Allocation preview: all-zero risk_parity weights (check returns)")
src/backtest/engine.py:1692:        mu = rets.mean(axis=0) - float(risk_free_rate)
src/backtest/engine.py:1703:                "Provide strategies with positive risk-adjusted returns or choose a different allocation_method."
src/backtest/engine.py:1717:        "Expected 'risk_parity' or 'sharpe_weighted'."
src/backtest/engine.py:1733:    - "risk_parity": NOTE: Siehe docs/TECH_DEBT_BACKLOG.md (gleiches Risk-Level pro Strategie)
src/backtest/engine.py:1768:    elif method == "risk_parity":
src/backtest/engine.py:1770:            "Allocation method 'risk_parity' requires a two-pass preview to estimate returns. "
src/backtest/engine.py:1783:            f"VerfÃ¼gbar: equal, manual, risk_parity, sharpe_weighted"
src/backtest/engine.py:1944:        >>> config = PortfolioConfig(enabled=True, name="equal_weight")
src/backtest/engine.py:1969:            portfolio_config = PortfolioConfig(enabled=True, name="equal_weight")
src/backtest/engine.py:1976:            "Portfolio-Layer ist deaktiviert. Setze portfolio.enabled=true in config.toml"
src/backtest/engine.py:2212:def compute_sharpe_ratio(equity_series: pd.Series, risk_free_rate: float = 0.0) -> float:
src/backtest/engine.py:2218:        risk_free_rate: Risikofreier Zinssatz (annualisiert)
src/backtest/engine.py:2234:    excess_returns = returns.mean() - risk_free_rate / 252
src/infra/runbooks/registry.py:10:- source: z.B. "live_risk_severity", "live_risk_limits"
src/infra/runbooks/registry.py:48:    "live_risk_severity": RunbookLink(
src/infra/runbooks/registry.py:49:        id="live_risk_severity",
src/infra/runbooks/registry.py:54:    "live_risk_limits": RunbookLink(
src/infra/runbooks/registry.py:55:        id="live_risk_limits",
src/infra/runbooks/registry.py:81:    # RISK + live_risk_severity
src/infra/runbooks/registry.py:82:    ("RISK", "live_risk_severity", "CRITICAL"): [
src/infra/runbooks/registry.py:83:        "live_risk_severity",
src/infra/runbooks/registry.py:87:    ("RISK", "live_risk_severity", "WARN"): [
src/infra/runbooks/registry.py:88:        "live_risk_severity",
src/infra/runbooks/registry.py:91:    ("RISK", "live_risk_severity", None): [
src/infra/runbooks/registry.py:92:        "live_risk_severity",
src/infra/runbooks/registry.py:95:    # RISK + live_risk_limits
src/infra/runbooks/registry.py:96:    ("RISK", "live_risk_limits", "CRITICAL"): [
src/infra/runbooks/registry.py:97:        "live_risk_limits",
src/infra/runbooks/registry.py:101:    ("RISK", "live_risk_limits", "WARN"): [
src/infra/runbooks/registry.py:102:        "live_risk_limits",
src/infra/runbooks/registry.py:105:    ("RISK", "live_risk_limits", None): [
src/infra/runbooks/registry.py:106:        "live_risk_limits",
src/infra/runbooks/registry.py:111:        "live_risk_limits",
src/infra/runbooks/registry.py:116:        "live_risk_limits",
src/infra/runbooks/registry.py:120:        "live_risk_limits",
src/docs/Peak_Trade_Projektuebersicht.md:37:â”‚  â”œâ”€ risk/
src/docs/Peak_Trade_Projektuebersicht.md:42:â”‚  â”œâ”€ demo_risk_limits.py
src/docs/Peak_Trade_Projektuebersicht.md:85:  - neue Risk-Module (`src/risk/limits.py`, `src/risk/position_sizer.py`, Backup-Version)
src/docs/Peak_Trade_Projektuebersicht.md:88:  - geÃ¤nderte Exports in `src/risk/__init__.py`, `src/data/__init__.py`
src/docs/Peak_Trade_Projektuebersicht.md:97:    - `max_risk_per_trade`
src/docs/Peak_Trade_Projektuebersicht.md:104:  - Konfiguration Ã¼ber `[risk]` in `config/config.toml`
src/docs/Peak_Trade_Projektuebersicht.md:105:  - Demos (`demo_risk_limits.py`, `demo_complete_pipeline.py`) und Tests (`tests/test_risk.py`, falls vorhanden)
src/docs/Peak_Trade_Projektuebersicht.md:154:python scripts/demo_risk_limits.py
src/docs/Peak_Trade_Projektuebersicht.md:189:  - Konfiguration zentral in `[risk]`  
src/backtest/walkforward.py:142:        aggregate_metrics: Aggregierte Metriken Ã¼ber alle Fenster (z.B. avg_sharpe, avg_return)
src/backtest/walkforward.py:150:    aggregate_metrics: Dict[str, float] = field(default_factory=dict)
src/backtest/walkforward.py:409:        >>> print(f"Durchschnitts-Sharpe: {result.aggregate_metrics.get('avg_sharpe', 0):.2f}")
src/backtest/walkforward.py:626:    aggregate_metrics = _compute_aggregate_metrics(window_results)
src/backtest/walkforward.py:633:        aggregate_metrics=aggregate_metrics,
src/backtest/walkforward.py:638:    # Artifacts (v1): only when optimization is enabled (param_grid provided).
src/backtest/walkforward.py:656:        f"Avg Sharpe: {aggregate_metrics.get('avg_sharpe', 0):.2f}, "
src/backtest/walkforward.py:657:        f"Avg Return: {aggregate_metrics.get('avg_return', 0):.2%}"
src/backtest/walkforward.py:663:def _compute_aggregate_metrics(
src/backtest/walkforward.py:707:    aggregate = {
src/backtest/walkforward.py:720:    return aggregate
src/backtest/walkforward.py:782:        ...     print(f"{result.config_id}: Avg Sharpe = {result.aggregate_metrics.get('avg_sharpe', 0):.2f}")
src/backtest/walkforward.py:840:            avg_sharpe = result.aggregate_metrics.get("avg_sharpe", 0.0)
src/backtest/walkforward.py:841:            avg_return = result.aggregate_metrics.get("avg_return", 0.0)
src/backtest/walkforward.py:842:            win_rate = result.aggregate_metrics.get("win_rate_windows", 0.0)
src/risk/component_var.py:88:        >>> from src.risk.covariance import CovarianceEstimator, CovarianceEstimatorConfig
src/risk/component_var.py:89:        >>> from src.risk.parametric_var import ParametricVaR, ParametricVaRConfig
src/execution_simple/gates.py:1:# src/execution_simple/gates.py
src/execution_simple/gates.py:27:        Check order intent against gate policy.
src/execution_simple/gates.py:63:                gate_name=self.name,
src/execution_simple/gates.py:69:            gate_name=self.name,
src/execution_simple/gates.py:84:        Initialize gate.
src/execution_simple/gates.py:100:                gate_name=self.name,
src/execution_simple/gates.py:108:                gate_name=self.name,
src/execution_simple/gates.py:115:                gate_name=self.name,
src/execution_simple/gates.py:121:            gate_name=self.name,
src/execution_simple/gates.py:136:        Initialize gate.
src/execution_simple/gates.py:164:                gate_name=self.name,
src/execution_simple/gates.py:173:                gate_name=self.name,
src/execution_simple/gates.py:180:            gate_name=self.name,
src/execution_simple/gates.py:196:        Initialize gate.
src/execution_simple/gates.py:213:                gate_name=self.name,
src/execution_simple/gates.py:219:            gate_name=self.name,
src/experiments/topn_promotion.py:629:            from src.governance.policy_critic.auto_apply_gate import (
src/docs/peak_trade_documentation.md:113:â”‚   â”œâ”€â”€ risk/
src/risk/position_sizer.py:11:    risk_amount = equity * risk_per_trade
src/risk/position_sizer.py:12:    size = risk_amount / abs(entry_price - stop_price)
src/risk/position_sizer.py:18:P0 Guardrails: This file is protected by CODEOWNERS (risk management review required).
src/risk/position_sizer.py:36:    risk_pct: float = 1.0  # Risiko pro Trade in %
src/risk/position_sizer.py:48:    risk_per_trade: float  # z.B. 0.01 = 1%
src/risk/position_sizer.py:57:    risk_amount: float  # Risikobetrag in USD
src/risk/position_sizer.py:58:    risk_percent: float  # Risiko in %
src/risk/position_sizer.py:78:    def fixed_fractional(capital: float, risk_pct: float, stop_distance: float) -> float:
src/risk/position_sizer.py:84:            risk_pct: Risiko pro Trade (als Dezimal, z.B. 0.01 = 1%)
src/risk/position_sizer.py:99:        risk_amount = capital * risk_pct
src/risk/position_sizer.py:100:        size = risk_amount / stop_distance
src/risk/position_sizer.py:155:        Nutzt config.risk_pct und config.max_position_pct, gibt Units zurÃ¼ck.
src/risk/position_sizer.py:169:        risk_pct_decimal = self.config.risk_pct / 100.0  # Convert % to decimal
src/risk/position_sizer.py:170:        size = self.fixed_fractional(capital, risk_pct_decimal, stop_distance)
src/risk/position_sizer.py:282:        req: PositionRequest mit equity, entry, stop, risk
src/risk/position_sizer.py:288:        PositionResult mit size, value, risk, oder rejected=True
src/risk/position_sizer.py:301:        ...     risk_per_trade=0.01
src/risk/position_sizer.py:312:            risk_amount=0,
src/risk/position_sizer.py:313:            risk_percent=0,
src/risk/position_sizer.py:327:            risk_amount=0,
src/risk/position_sizer.py:328:            risk_percent=0,
src/risk/position_sizer.py:335:    risk_amount = req.equity * req.risk_per_trade
src/risk/position_sizer.py:338:    size = risk_amount / stop_distance
src/risk/position_sizer.py:347:            risk_amount=risk_amount,
src/risk/position_sizer.py:348:            risk_percent=req.risk_per_trade,
src/risk/position_sizer.py:359:            risk_amount=risk_amount,
src/risk/position_sizer.py:360:            risk_percent=req.risk_per_trade,
src/risk/position_sizer.py:370:        risk_amount=risk_amount,
src/risk/position_sizer.py:371:        risk_percent=req.risk_per_trade,
src/autonomous/decision_engine.py:137:        self.criteria["risk_check"] = [
src/ai_orchestration/critic_report_schema.py:126:    risk_level: RiskLevel = Field(..., description="Overall risk level")
src/ai_orchestration/critic_report_schema.py:283:            f"- **Risk Level:** {self.summary.risk_level.value}",
src/risk_layer/kill_switch/triggers/manual.py:10:    """Manual trigger for operator-initiated kill switch.
src/risk_layer/kill_switch/triggers/manual.py:17:            "enabled": true,
src/risk_layer/kill_switch/triggers/manual.py:42:        if not self.enabled:
src/risk_layer/kill_switch/triggers/manual.py:64:        if not self.enabled:
src/experiments/portfolio_recipes.py:58:        risk_profile: Informatives Risiko-Profil (optional)
src/experiments/portfolio_recipes.py:80:    risk_profile: str | None = None
src/experiments/portfolio_recipes.py:212:                risk_profile=recipe_data.get("risk_profile"),
src/backtest/registry_engine.py:80:    risk_level_filter: Optional[str] = None,
src/backtest/registry_engine.py:99:        risk_level_filter: Nur Strategien mit diesem Risk-Level (z.B. "low", "medium")
src/backtest/registry_engine.py:143:    if timeframe_filter or risk_level_filter:
src/backtest/registry_engine.py:155:            if risk_level_filter and strat_cfg.metadata:
src/backtest/registry_engine.py:156:                risk_level = strat_cfg.metadata.get("risk_level", "")
src/backtest/registry_engine.py:157:                if risk_level != risk_level_filter:
src/backtest/registry_engine.py:168:            f"risk_level={risk_level_filter}"
src/execution_simple/__init__.py:19:from .gates import Gate, LotSizeGate, MinNotionalGate, PriceSanityGate, ResearchOnlyGate
src/risk_layer/var_backtest/__init__.py:15:from src.risk_layer.var_backtest.kupiec_pof import (
src/risk_layer/var_backtest/__init__.py:25:from src.risk_layer.var_backtest.var_backtest_runner import (
src/risk_layer/var_backtest/__init__.py:29:from src.risk_layer.var_backtest.violation_detector import (
src/risk_layer/var_backtest/__init__.py:35:from src.risk_layer.var_backtest.christoffersen_tests import (
src/risk_layer/var_backtest/__init__.py:47:from src.risk_layer.var_backtest.traffic_light import (
src/risk_layer/var_backtest/__init__.py:57:from src.risk_layer.var_backtest.duration_diagnostics import (
src/risk_layer/var_backtest/__init__.py:66:from src.risk_layer.var_backtest.rolling_evaluation import (
src/governance/policy_critic/packs.py:5:- CI: balanced (block critical, warn on risky)
src/governance/policy_critic/packs.py:29:    enabled_rules: List[str]
src/governance/policy_critic/packs.py:41:            f"{sorted(self.enabled_rules)}:"
src/governance/policy_critic/packs.py:91:        required = ["pack_id", "version", "description", "enabled_rules"]
src/governance/policy_critic/packs.py:100:            enabled_rules=data["enabled_rules"],
src/governance/policy_critic/packs.py:160:    # Filter rules based on pack's enabled_rules
src/governance/policy_critic/packs.py:161:    enabled_rules = [r for r in rules if r.rule_id in pack.enabled_rules]
src/governance/policy_critic/packs.py:164:    pack_aware_rules = [PackAwareRule(rule, pack) for rule in enabled_rules]
src/autonomous/workflow_engine.py:112:            workflow_type: Type of workflow (e.g., 'signal_analysis', 'risk_check')
src/autonomous/workflow_engine.py:211:        Simulate workflow execution (dry-run).
src/autonomous/workflow_engine.py:243:            "risk_check": "scripts/check_live_risk_limits.py",
src/docs/architecture.md:48:â”‚  â”œâ”€ risk/
src/docs/architecture.md:119:### 3.4 `src/risk/` â€“ Risk- & Money-Management
src/docs/architecture.md:126:  - konfiguriertem `risk_per_trade` (z. B. 1 %)
src/exchange/ccxt_client.py:78:        enable_rate_limit: bool = True,
src/exchange/ccxt_client.py:87:            enable_rate_limit=enable_rate_limit,
src/risk/portfolio_var.py:17:    >>> from src.risk.portfolio_var import build_portfolio_var_config_from_config, parametric_var
src/risk/portfolio_var.py:58:        enabled: Enable portfolio VaR calculations
src/risk/portfolio_var.py:67:    enabled: bool = True
src/risk/portfolio_var.py:97:        [risk.portfolio_var]
src/risk/portfolio_var.py:98:        enabled = true
src/risk/portfolio_var.py:112:        enabled=bool(cfg.get("risk.portfolio_var.enabled", True)),
src/risk/portfolio_var.py:113:        method=str(cfg.get("risk.portfolio_var.method", "parametric")),
src/risk/portfolio_var.py:114:        confidence=float(cfg.get("risk.portfolio_var.confidence", 0.99)),
src/risk/portfolio_var.py:115:        horizon_days=int(cfg.get("risk.portfolio_var.horizon_days", 1)),
src/risk/portfolio_var.py:116:        lookback_bars=int(cfg.get("risk.portfolio_var.lookback_bars", 500)),
src/risk/portfolio_var.py:117:        symbol_mode=str(cfg.get("risk.portfolio_var.symbol_mode", "base")),
src/risk/portfolio_var.py:118:        use_mean=bool(cfg.get("risk.portfolio_var.use_mean", False)),
src/risk/portfolio_var.py:410:        - Take quantile of aggregated returns
src/risk/portfolio_var.py:457:    # 5. VaR as positive number (negate loss)
src/risk_layer/kill_switch/triggers/__init__.py:3:This module provides various trigger mechanisms for the kill switch:
src/risk_layer/kill_switch/triggers/__init__.py:27:    """Registry for all kill switch triggers.
src/risk_layer/kill_switch/triggers/__init__.py:41:        ...     # Trigger kill switch
src/risk_layer/kill_switch/triggers/__init__.py:80:        """Check all enabled triggers.
src/risk_layer/kill_switch/triggers/__init__.py:91:            if not trigger.enabled:
src/risk_layer/kill_switch/triggers/__init__.py:103:                # Don't propagate trigger errors - fail safe
src/risk_layer/kill_switch/triggers/__init__.py:151:                "enabled": trigger.enabled,
src/risk_layer/kill_switch/triggers/__init__.py:172:        triggers_config = config.get("kill_switch.triggers", {})
src/risk_layer/var_backtest/rolling_evaluation.py:39:from src.risk_layer.var_backtest.christoffersen_tests import (
src/risk_layer/var_backtest/rolling_evaluation.py:44:from src.risk_layer.var_backtest.kupiec_pof import KupiecPOFOutput, kupiec_pof_test
src/risk_layer/var_backtest/rolling_evaluation.py:362:        RollingSummary with aggregate metrics
src/risk_layer/var_backtest/rolling_evaluation.py:396:            "Some instability detected. Investigate failing windows."
src/governance/policy_critic/critic.py:5:against security, risk, and operational policies.
src/governance/policy_critic/critic.py:202:        # Check for risk-related changes
src/governance/policy_critic/critic.py:203:        risk_violations = [v for v in violations if "RISK" in v.rule_id]
src/governance/policy_critic/critic.py:204:        if risk_violations:
src/governance/policy_critic/critic.py:205:            test_plan.append("Verify risk limit enforcement with edge cases")
src/governance/policy_critic/critic.py:206:            test_plan.append("Document risk limit changes in changelog")
src/governance/policy_critic/critic.py:218:            risk_violations = [v for v in violations if "RISK_LIMIT" in v.rule_id]
src/governance/policy_critic/critic.py:219:            if risk_violations:
src/governance/policy_critic/critic.py:221:                    "Why are risk limits being changed? What data/metrics support this?"
src/governance/policy_critic/rules.py:93:    """Block attempts to enable live trading or remove safety locks."""
src/governance/policy_critic/rules.py:97:    description = "Detects attempts to enable live trading or remove safety gates"
src/governance/policy_critic/rules.py:100:        (r"enable_live_trading\s*[=:]\s*[Tt]rue", "Attempt to enable live trading"),
src/governance/policy_critic/rules.py:101:        (r"live_mode_armed\s*[=:]\s*[Tt]rue", "Attempt to arm live mode"),
src/governance/policy_critic/rules.py:104:        (r"\.unlock\(\)", "Attempt to unlock a safety gate"),
src/governance/policy_critic/rules.py:202:    """Warn when risk limits are raised without justification."""
src/governance/policy_critic/rules.py:206:    description = "Detects risk limit increases without documented justification"
src/governance/policy_critic/rules.py:275:        "src/risk/",
src/governance/promotion_loop/engine.py:53:        if "risk" in target_lower:
src/governance/promotion_loop/engine.py:54:            tags.append("risk")
src/governance/promotion_loop/engine.py:372:    lines.append("- [ ] Verify risk limits and leverage bounds.")
src/experiments/research_playground.py:549:            "risk_on_scale": 1.0,
src/experiments/research_playground.py:551:            "risk_off_scale": 0.0,
src/experiments/research_playground.py:566:            "risk_on_scale": [1.0],
src/experiments/research_playground.py:568:            "risk_off_scale": [0.0],
src/experiments/research_playground.py:576:        description="Neutral-Scale Sensitivity Sweep bei risk_off_scale = 0.0",
src/experiments/research_playground.py:590:            "risk_on_scale": [1.0],
src/experiments/research_playground.py:592:            "risk_off_scale": [0.0],
src/core/resilience.py:92:        def risky_operation():
src/portfolio/base.py:289:        return f"<{self.name}(enabled={self.config.enabled}, strategy={self.config.name})>"
src/portfolio/base.py:307:        >>> cfg = PortfolioConfig(enabled=True, name="equal_weight")
src/portfolio/base.py:312:    if not config.enabled:
src/risk_layer/kill_switch/triggers/watchdog.py:35:            "enabled": true,
src/risk_layer/kill_switch/triggers/watchdog.py:62:            self.enabled = False
src/risk_layer/kill_switch/triggers/watchdog.py:90:        if not self.enabled or not PSUTIL_AVAILABLE:
src/risk_layer/kill_switch/triggers/watchdog.py:156:            f"enabled={self.enabled}"
src/risk_layer/var_backtest/var_backtest_runner.py:17:from src.risk_layer.var_backtest.kupiec_pof import (
src/risk_layer/var_backtest/var_backtest_runner.py:21:from src.risk_layer.var_backtest.violation_detector import (
src/exchange/__init__.py:83:    enable_rate_limit = cfg.get("exchange.enable_rate_limit", True)
src/exchange/__init__.py:107:        enable_rate_limit=enable_rate_limit,
src/governance/policy_critic/auto_apply_gate.py:36:    This is the output of the policy critic gate that controls
src/governance/policy_critic/auto_apply_gate.py:73:    3. If policy_critic returns ALLOW, auto-apply MAY proceed (hard gates still apply)
src/governance/policy_critic/auto_apply_gate.py:160:                reason=f"Policy critic failed but fail-open mode enabled: {str(e)}",
src/governance/policy_critic/auto_apply_gate.py:178:    - ALLOW â†’ may proceed (but hard gates still apply)
src/risk/README.md:3:**Location:** `src/risk/`  
src/risk/README.md:4:**Purpose:** Core risk management for backtesting and portfolio analysis  
src/risk/README.md:11:This module provides **core risk management functionality** for:
src/risk/README.md:13:2. **Portfolio Analysis:** Position sizing, risk limits
src/risk/README.md:17:- Backtest risk metrics (Sharpe ratio, drawdown, win rate)
src/risk/README.md:24:## Relationship to `src/risk_layer/`
src/risk/README.md:28:| Aspect | `src/risk/` (This Module) | `src/risk_layer/` |
src/risk/README.md:37:- **`src/risk/`** = "What risk did we take?" (post-hoc analysis)
src/risk/README.md:38:- **`src/risk_layer/`** = "Should we take this risk now?" (pre-trade gate)
src/risk/README.md:45:Calculates position sizes based on risk parameters:
src/risk/README.md:52:### RiskLimits (`risk_limits.py`)
src/risk/README.md:53:Enforces risk limits in backtest:
src/risk/README.md:65:- Component VaR (risk attribution)
src/risk/README.md:67:**Used In:** Portfolio analysis, risk reporting
src/risk/README.md:89:**Use `src/risk/` for:**
src/risk/README.md:90:- âœ… Backtest risk metrics (Sharpe, DD, VaR)
src/risk/README.md:92:- âœ… Portfolio risk analysis
src/risk/README.md:96:**Use `src/risk_layer/` for:**
src/risk/README.md:97:- âœ… Live trading order gates
src/risk/README.md:99:- âœ… Real-time risk monitoring
src/risk/README.md:101:- âœ… Operational risk management
src/risk/README.md:108:- `src/risk/` is for **analytical risk** (what happened, what could happen)
src/risk/README.md:109:- `src/risk_layer/` is for **operational risk** (should we do this now)
src/risk/README.md:112:- `src/risk/` enforces limits in **simulated backtest**
src/risk/README.md:113:- `src/risk_layer/` enforces limits on **real orders**
src/risk/README.md:120:- `src.risk.PositionSizer` - Used in backtest engine
src/risk/README.md:121:- `src.risk.RiskLimits` - Used in backtest engine
src/risk/README.md:122:- `src.risk.calc_var` - Used in reporting
src/risk/README.md:125:- `src/risk_layer/` - Completely independent
src/risk/README.md:134:from src.risk import PositionSizer, PositionSizerConfig
src/risk/README.md:137:    risk_pct=0.02,  # 2% risk per trade
src/risk/README.md:155:from src.risk import calc_var
src/risk/README.md:167:src/risk/
src/risk/README.md:170:â”œâ”€â”€ risk_limits.py          # Risk limits (backtest)
src/risk/README.md:176:â”œâ”€â”€ portfolio.py            # Portfolio risk metrics
src/risk/README.md:189:**Do NOT use this module directly for live trading order gates.**
src/risk/README.md:191:Use `src/risk_layer/` instead:
src/risk/README.md:192:- `src.risk_layer.kill_switch` - Emergency halt
src/risk/README.md:193:- `src.live.risk_limits.LiveRiskLimits` - Live order checks
src/risk/README.md:199:- **"Which module for live trading?"** â†’ `src/risk_layer/`
src/risk/README.md:200:- **"Which module for backtest metrics?"** â†’ `src/risk/` (this module)
src/portfolio/manager.py:49:    - Capital Allocation (equal, risk_parity, sharpe_weighted)
src/portfolio/manager.py:102:            method: "equal", "risk_parity", "manual"
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:66:â”‚  â”œâ”€ risk/
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:99:[risk]
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:100:risk_per_trade = 0.01          # 1% pro Trade
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:134:    risk_per_trade: float = Field(default=0.01, gt=0, le=0.05)
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:146:    risk: RiskConfig
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:170:### 2. src/risk/position_sizer.py
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:182:    risk_per_trade: float   # z.B. 0.01 = 1%
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:188:    risk_amount: float             # Risikobetrag USD
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:189:    risk_percent: float            # Risiko in %
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:202:    risk_per_trade * equity bis zum Stop verloren wird.
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:205:        risk_amount = equity * risk_per_trade
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:206:        size = risk_amount / |entry_price - stop_price|
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:238:        "enableRateLimit": True,
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:342:    return (mean_return - risk_free_rate) / std_return
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:480:risk_amount = equity * risk_per_trade  # z.B. 10000 * 0.01 = 100 USD
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:486:size = risk_amount / stop_distance  # 100 / 2000 = 0.05 BTC
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:578:Risk berechnen: equity * risk_per_trade (z.B. 100 USD)
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:582:Size berechnen: risk / distance (z.B. 0.05 BTC)
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:623:- src/risk/position_sizer.py â€“ Position Sizing
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:654:- `src/risk/position_sizer.py` â€“ Position Sizing
src/docs/PEAK_TRADE_PROJECT_SUMMARY.md:739:**Built with â¤ï¸ and strict risk management**
src/governance/policy_critic/__init__.py:1:"""Policy Critic - Governance gate for automated proposals."""
src/governance/policy_critic/README.md:7:The Policy Critic is a deterministic, evidence-based governance tool that reviews proposed changes (diffs) against security, risk, and operational policies. It complements (never replaces) hard deterministic gates and can only increase friction, never reduce it.
src/governance/policy_critic/README.md:14:4. **Can brake, never accelerate**: Can block auto-apply, but cannot override hard gates
src/governance/policy_critic/README.md:26:Blocks attempts to enable live trading or remove safety locks:
src/governance/policy_critic/README.md:27:- `enable_live_trading = true`
src/governance/policy_critic/README.md:28:- `live_mode_armed = true`
src/governance/policy_critic/README.md:130:- `src/risk/**`
src/governance/promotion_loop/policy.py:39:        """Check if bounded auto-apply is enabled."""
src/core/tracking.py:201:      - enabled / disabled: bool
src/core/tracking.py:214:    enabled = cfg_map.get("enabled", None)
src/core/tracking.py:216:    if enabled is False or disabled is True:
src/risk_layer/kill_switch/recovery.py:3:Manages the multi-stage recovery process after kill switch activation.
src/risk_layer/kill_switch/recovery.py:62:    """Manages kill switch recovery process.
src/risk_layer/kill_switch/recovery.py:70:        >>> config = load_config()["kill_switch.recovery"]
src/risk_layer/kill_switch/recovery.py:105:        self._gradual_enabled = config.get("gradual_restart_enabled", True)
src/risk_layer/kill_switch/recovery.py:225:        if not self._gradual_enabled:
src/portfolio/vol_target.py:51:        ...     enabled=True,
src/obs/strategy_risk_telemetry.py:8:- NO-LIVE: telemetry only; must never enable trading or change decisions.
src/obs/strategy_risk_telemetry.py:16:- peaktrade_risk_checks_total{check, result}
src/obs/strategy_risk_telemetry.py:17:- peaktrade_risk_limit_utilization{limit_id}  (gauge 0..1, clamped)
src/obs/strategy_risk_telemetry.py:18:- peaktrade_risk_blocks_total{reason}
src/obs/strategy_risk_telemetry.py:65:_ALLOWED_RISK_CHECKS = {"live_limits.check_orders", "runtime_risk.evaluate_pre_order"}
src/obs/strategy_risk_telemetry.py:89:    Normalize label values to reduce cardinality risks:
src/obs/strategy_risk_telemetry.py:129:def _sanitize_risk_check(check: str) -> Optional[str]:
src/obs/strategy_risk_telemetry.py:134:def _sanitize_risk_result(result: str) -> Optional[str]:
src/obs/strategy_risk_telemetry.py:206:            "peaktrade_risk_checks_total",
src/obs/strategy_risk_telemetry.py:207:            "Total number of risk check evaluations (watch/paper/shadow).",
src/obs/strategy_risk_telemetry.py:212:                "peaktrade_risk_limit_utilization",
src/obs/strategy_risk_telemetry.py:219:                "peaktrade_risk_limit_utilization",
src/obs/strategy_risk_telemetry.py:224:            "peaktrade_risk_blocks_total",
src/obs/strategy_risk_telemetry.py:225:            "Total number of risk blocks by finite reason allowlist.",
src/obs/strategy_risk_telemetry.py:230:            "Strategy/risk telemetry metrics init failed; telemetry will be no-op.",
src/obs/strategy_risk_telemetry.py:294:def inc_risk_check(*, check: str, result: str, n: int = 1) -> None:
src/obs/strategy_risk_telemetry.py:299:        chk = _sanitize_risk_check(check)
src/obs/strategy_risk_telemetry.py:300:        res = _sanitize_risk_result(result)
src/obs/strategy_risk_telemetry.py:305:        logger.debug("inc_risk_check failed (ignored).", exc_info=True)
src/obs/strategy_risk_telemetry.py:308:def set_risk_limit_utilization(*, limit_id: str, utilization_0_1: float) -> None:
src/obs/strategy_risk_telemetry.py:323:        logger.debug("set_risk_limit_utilization failed (ignored).", exc_info=True)
src/obs/strategy_risk_telemetry.py:326:def inc_risk_block(*, reason: str, n: int = 1) -> None:
src/obs/strategy_risk_telemetry.py:336:        logger.debug("inc_risk_block failed (ignored).", exc_info=True)
src/obs/strategy_risk_telemetry.py:344:    "inc_risk_check",
src/obs/strategy_risk_telemetry.py:345:    "set_risk_limit_utilization",
src/obs/strategy_risk_telemetry.py:346:    "inc_risk_block",
src/risk/monte_carlo.py:499:    returns: pd.DataFrame, cfg: any, section: str = "risk.monte_carlo"
src/risk/monte_carlo.py:510:        MonteCarloVaRCalculator if enabled, else None
src/risk/monte_carlo.py:514:    [risk.monte_carlo]
src/risk/monte_carlo.py:515:    enabled = true
src/risk/monte_carlo.py:542:    # Check if Monte Carlo VaR is enabled
src/risk/monte_carlo.py:543:    enabled = bool(get_fn(f"{section}.enabled", False))
src/risk/monte_carlo.py:544:    if not enabled:
src/docs/Peak_Trade_setup_notes.md:34:    â”œâ”€â”€ risk/
src/docs/Peak_Trade_setup_notes.md:69:[risk]
src/docs/Peak_Trade_setup_notes.md:108:  - Parsen der Sektionen `[risk]`, `[backtest]`, `[exchange]`, `[[strategies]]`
src/docs/Peak_Trade_setup_notes.md:216:        self.risk = self._parse_risk()
src/docs/Peak_Trade_setup_notes.md:233:    def _parse_risk(self) -> RiskConfig:
src/docs/Peak_Trade_setup_notes.md:234:        data = self._raw_config.get("risk", {})
src/docs/Peak_Trade_setup_notes.md:297:        if self.risk.max_position_size_pct >= self.risk.max_total_exposure_pct:
src/docs/Peak_Trade_setup_notes.md:324:        print(f"  Max Position: {cfg.risk.max_position_size_pct}%")
src/docs/Peak_Trade_setup_notes.md:325:        print(f"  Max Drawdown: {cfg.risk.max_drawdown_pct}%");
src/docs/Peak_Trade_setup_notes.md:403:        "enableRateLimit": True,
src/risk_layer/var_backtest/traffic_light.py:255:         - Report to risk committee"
src/risk_layer/var_backtest/traffic_light.py:284:            f"   3. REPORT to risk committee and regulators\n"
src/governance/live_mode_gate.py:36:        """Check if environment is considered 'live' (real capital at risk)."""
src/governance/live_mode_gate.py:73:    """Current state of the live mode gate."""
src/governance/live_mode_gate.py:127:        """Get current gate state."""
src/governance/live_mode_gate.py:143:            required_keys = ["session_id", "strategy_id", "risk_limits"]
src/governance/live_mode_gate.py:149:            if "risk_limits" in self.config:
src/governance/live_mode_gate.py:150:                risk_limits = self.config["risk_limits"]
src/governance/live_mode_gate.py:151:                if not isinstance(risk_limits, dict):
src/governance/live_mode_gate.py:152:                    errors.append("risk_limits must be a dict")
src/governance/live_mode_gate.py:153:                elif not risk_limits:
src/governance/live_mode_gate.py:154:                    errors.append("risk_limits cannot be empty for live env")
src/governance/live_mode_gate.py:169:            if "risk_limits" not in self.config:
src/governance/live_mode_gate.py:170:                warnings.append("risk_limits recommended even for non-live envs")
src/governance/live_mode_gate.py:255:        """Reset gate to default blocked state."""
src/governance/live_mode_gate.py:261:        self._log_audit_event("gate_reset", {})
src/governance/live_mode_gate.py:286:def create_gate(
src/governance/live_mode_gate.py:312:def is_live_allowed(gate: LiveModeGate) -> bool:
src/governance/live_mode_gate.py:318:    return gate.get_state().is_allowed()
src/governance/live_mode_gate.py:322:    """Exception raised when live mode gate rules are violated."""
src/governance/live_mode_gate.py:327:def enforce_live_mode_gate(config: Dict[str, Any], env: str) -> None:
src/governance/live_mode_gate.py:329:    Enforce live mode gate rules (fail-fast).
src/governance/live_mode_gate.py:334:    1. live.enabled defaults to False
src/governance/live_mode_gate.py:335:    2. If live.enabled is True:
src/governance/live_mode_gate.py:338:       - risk_runtime must be importable (basic check)
src/governance/live_mode_gate.py:344:                    "enabled": bool,
src/governance/live_mode_gate.py:358:        ...         "enabled": True,
src/governance/live_mode_gate.py:363:        ...     "risk_limits": {"max_position_size": 1000},
src/governance/live_mode_gate.py:365:        >>> enforce_live_mode_gate(config, env="prod")  # OK
src/governance/live_mode_gate.py:366:        >>> enforce_live_mode_gate(config, env="dev")   # Raises!
src/governance/live_mode_gate.py:368:    # 1. Check if live mode is enabled
src/governance/live_mode_gate.py:370:    live_enabled = live_config.get("enabled", False)  # Default: False
src/governance/live_mode_gate.py:372:    if not live_enabled:
src/governance/live_mode_gate.py:376:    # 2. Live mode is enabled => enforce strict rules
src/governance/live_mode_gate.py:383:            f"Live mode enabled but env is '{env}'. "
src/governance/live_mode_gate.py:392:            f"Live mode enabled but operator_ack is missing or incorrect. "
src/governance/live_mode_gate.py:396:    # Rule 2.3: risk_runtime must be importable (basic sanity check)
src/governance/live_mode_gate.py:398:        import src.execution.risk_runtime  # noqa: F401
src/governance/live_mode_gate.py:400:        errors.append(f"Live mode enabled but risk_runtime module cannot be imported: {e}")
src/governance/live_mode_gate.py:405:            "Live mode gate violation(s):\n" + "\n".join(f"  - {err}" for err in errors)
src/portfolio/fixed_weights.py:36:        enabled = true
src/portfolio/fixed_weights.py:50:        ...     enabled=True,
src/reporting/status_snapshot_schema.py:50:        id: Unique panel identifier (e.g., "system", "portfolio", "risk")
src/obs/trade_flow_telemetry.py:39:_ALLOWED_BLOCK_REASONS = {"risk_manager", "governance", "limits", "cooldown", "unknown"}
src/obs/trade_flow_telemetry.py:44:    Normalize label values to reduce cardinality risks:
src/obs/trade_flow_telemetry.py:79:            "Total number of orders approved after risk/governance gates (watch-only).",
src/obs/trade_flow_telemetry.py:84:            "Total number of orders blocked/rejected by gates (finite reason allowlist).",
src/obs/trade_flow_telemetry.py:112:      {risk_manager, governance, limits, cooldown, unknown}
src/obs/trade_flow_telemetry.py:120:    if "blocked_by_risk" in st:
src/obs/trade_flow_telemetry.py:121:        # In this codebase, risk blocks are typically risk-limits violations.
src/obs/trade_flow_telemetry.py:132:    if "risk_limit" in rr or "risk_limits" in rr or "limit" in rr:
src/obs/trade_flow_telemetry.py:134:    if "risk" in rr:
src/obs/trade_flow_telemetry.py:135:        return "risk_manager"
src/risk_layer/kill_switch/audit.py:21:    """Append-only audit log for kill switch events.
src/risk_layer/kill_switch/audit.py:30:        >>> audit = AuditTrail("data/kill_switch/audit")
src/risk_layer/kill_switch/audit.py:70:        return self.audit_dir / f"kill_switch_audit_{today}.jsonl"
src/risk_layer/kill_switch/audit.py:113:        audit_files = sorted(self.audit_dir.glob("kill_switch_audit_*.jsonl"))
src/risk_layer/kill_switch/audit.py:116:        gz_files = sorted(self.audit_dir.glob("kill_switch_audit_*.jsonl.gz"))
src/risk_layer/kill_switch/audit.py:179:        audit_files = sorted(self.audit_dir.glob("kill_switch_audit_*.jsonl"), reverse=True)
src/risk_layer/kill_switch/audit.py:180:        gz_files = sorted(self.audit_dir.glob("kill_switch_audit_*.jsonl.gz"), reverse=True)
src/risk_layer/kill_switch/audit.py:263:        for file in self.audit_dir.glob("kill_switch_audit_*"):
src/risk_layer/kill_switch/audit.py:266:                # Format: kill_switch_audit_YYYY-MM-DD.jsonl[.gz]
src/risk_layer/kill_switch/audit.py:295:        files = list(self.audit_dir.glob("kill_switch_audit_*"))
src/risk/__init__.py:99:from .risk_layer_manager import (
src/risk/__init__.py:102:    build_risk_layer_manager_from_config,
src/risk/__init__.py:174:    "build_risk_layer_manager_from_config",
src/governance/__init__.py:14:from .live_mode_gate import (
src/governance/__init__.py:20:    create_gate,
src/governance/__init__.py:23:    enforce_live_mode_gate,
src/governance/__init__.py:49:    "create_gate",
src/governance/__init__.py:52:    "enforce_live_mode_gate",
src/portfolio/equal_weight.py:41:        >>> config = PortfolioConfig(enabled=True, name="equal_weight")
src/portfolio/config.py:24:        enabled: Aktiviert/Deaktiviert den Portfolio-Layer
src/portfolio/config.py:36:    enabled: bool = False
src/portfolio/config.py:80:        enabled = cfg.get("portfolio.enabled", False)
src/portfolio/config.py:91:            elif allocation_method in ("risk_parity", "vol_target"):
src/portfolio/config.py:128:            enabled=enabled,
src/portfolio/config.py:152:            enabled=data.get("enabled", False),
src/portfolio/config.py:172:            "enabled": self.enabled,
src/portfolio/__init__.py:35:    >>> config = PortfolioConfig(enabled=True, name="equal_weight")
src/risk/covariance.py:157:                "Install with: pip install -e '.[risk]' or pip install scikit-learn"
src/risk_layer/kill_switch/config.py:24:    "kill_switch": {
src/risk_layer/kill_switch/config.py:25:        "enabled": True,
src/risk_layer/kill_switch/config.py:31:        "state_file": "data/kill_switch/state.json",
src/risk_layer/kill_switch/config.py:32:        "audit_dir": "data/kill_switch/audit",
src/risk_layer/kill_switch/config.py:36:    "kill_switch.recovery": {
src/risk_layer/kill_switch/config.py:41:        "gradual_restart_enabled": True,
src/risk_layer/kill_switch/config.py:65:            "config/risk/kill_switch.toml",
src/risk_layer/kill_switch/config.py:66:            "../config/risk/kill_switch.toml",
src/risk_layer/kill_switch/config.py:67:            "../../config/risk/kill_switch.toml",
src/risk_layer/kill_switch/config.py:104:    env_var = config.get("kill_switch", {}).get("approval_code_env", "KILL_SWITCH_APPROVAL_CODE")
src/risk_layer/kill_switch/config.py:108:    if not code and config.get("kill_switch", {}).get("require_approval_code"):
src/risk_layer/kill_switch/config.py:114:def get_kill_switch_config(config: dict) -> dict:
src/risk_layer/kill_switch/config.py:115:    """Extract kill_switch section from config.
src/risk_layer/kill_switch/config.py:123:    return config.get("kill_switch", DEFAULT_CONFIG["kill_switch"])
src/risk_layer/kill_switch/config.py:135:    return config.get("kill_switch.recovery", DEFAULT_CONFIG["kill_switch.recovery"])
src/risk_layer/models.py:5:Core data structures for risk decisions and violations.
src/risk_layer/models.py:15:    Represents a single risk violation.
src/risk_layer/models.py:33:    Result of a risk evaluation.
src/risk_layer/models.py:51:    Complete result of risk gate evaluation including audit trail.
src/risk_layer/models.py:54:        decision: The risk decision
src/strategies/armstrong/cycle_model.py:107:    risk_multipliers: Dict[str, float] = field(
src/strategies/armstrong/cycle_model.py:142:            "risk_multipliers": self.risk_multipliers,
src/strategies/armstrong/cycle_model.py:169:        >>> multiplier = model.risk_multiplier_for_date(date(2024, 1, 15))
src/strategies/armstrong/cycle_model.py:221:        # Override risk_multipliers wenn vorhanden
src/strategies/armstrong/cycle_model.py:222:        if "risk_multipliers" in config_dict:
src/strategies/armstrong/cycle_model.py:223:            config.risk_multipliers = config_dict["risk_multipliers"]
src/strategies/armstrong/cycle_model.py:319:    def risk_multiplier_for_date(self, dt: Union[date, datetime, pd.Timestamp]) -> float:
src/strategies/armstrong/cycle_model.py:337:            >>> mult = model.risk_multiplier_for_date(date(2024, 1, 15))
src/strategies/armstrong/cycle_model.py:343:        multipliers = self.config.risk_multipliers
src/strategies/armstrong/cycle_model.py:375:            - risk_multiplier: Risk-Multiplier fÃ¼r diese Phase
src/strategies/armstrong/cycle_model.py:399:            "risk_multiplier": self.risk_multiplier_for_date(dt_date),
src/strategies/armstrong/cycle_model.py:444:def get_risk_multiplier_for_date(
src/strategies/armstrong/cycle_model.py:466:    return model.risk_multiplier_for_date(dt)
src/strategies/armstrong/cycle_model.py:482:    "get_risk_multiplier_for_date",
src/reporting/live_run_report.py:108:    report.add_section(_build_risk_events_section(events_df))
src/reporting/live_run_report.py:283:def _build_risk_events_section(events_df: pd.DataFrame) -> ReportSection:
src/reporting/live_run_report.py:285:    if "risk_allowed" not in events_df.columns:
src/reporting/live_run_report.py:288:            content_markdown="*No risk data available*",
src/reporting/live_run_report.py:292:    blocked_events = events_df[events_df["risk_allowed"] == False]  # noqa: E712
src/reporting/live_run_report.py:297:            content_markdown="**No risk violations during this run.**",
src/reporting/live_run_report.py:306:    if "risk_reasons" in blocked_events.columns:
src/reporting/live_run_report.py:307:        all_reasons = blocked_events["risk_reasons"].dropna().unique()
src/core/performance.py:10:- MetricsCollector: Aggregates and reports performance metrics
src/execution_pipeline/contracts.py:6:- NO-LIVE enablement (adapters are required to be side-effect safe in CI)
src/risk_layer/kill_switch/persistence.py:20:    """Persists kill switch state to disk.
src/risk_layer/kill_switch/persistence.py:28:        >>> persistence = StatePersistence("data/kill_switch/state.json")
src/risk_layer/kill_switch/persistence.py:33:        ...     killed_at=datetime.utcnow(),
src/risk_layer/kill_switch/persistence.py:67:        killed_at: Optional[datetime] = None,
src/risk_layer/kill_switch/persistence.py:76:            state: Current kill switch state
src/risk_layer/kill_switch/persistence.py:77:            killed_at: Timestamp when killed (if KILLED)
src/risk_layer/kill_switch/persistence.py:84:            "killed_at": killed_at.isoformat() if killed_at else None,
src/risk/limits.py:60:    @with_resilience("risk", "check_drawdown", use_circuit_breaker=True)
src/governance/config_validation.py:35:        ...     "risk_limits": {"max_position_size": 1000},
src/governance/config_validation.py:58:    risk_limits = config.get("risk_limits")
src/governance/config_validation.py:59:    if risk_limits is None:
src/governance/config_validation.py:60:        errors.append("Missing required field: 'risk_limits'")
src/governance/config_validation.py:61:    elif not isinstance(risk_limits, dict):
src/governance/config_validation.py:62:        errors.append("Field 'risk_limits' must be a dict")
src/governance/config_validation.py:63:    elif not risk_limits:
src/governance/config_validation.py:90:        ConfigValidationError: If validation fails (with aggregated errors)
src/governance/config_validation.py:101:          - Missing required field: 'risk_limits'
src/obs/stage1/models.py:54:    """Aggregated statistics and go/no-go assessment."""
src/strategies/armstrong/__init__.py:22:    get_risk_multiplier_for_date,
src/strategies/armstrong/__init__.py:32:    "get_risk_multiplier_for_date",
src/core/errors.py:25:        risky_operation()
src/core/errors.py:160:        - Negative positions without shorting enabled
src/core/errors.py:200:    Raised when risk limits are violated or risk management fails.
src/core/errors.py:203:        - Position size exceeds risk limits
src/execution_pipeline/pipeline.py:28:    telemetry_enabled: bool = True
src/execution_pipeline/pipeline.py:46:        if not self._config.telemetry_enabled:
src/peak_trade/governance/validator.py:1:"""CLI wrapper for AI matrix vs registry validator (P0â€“P2). Delegates to src/governance/validate_ai_matrix_vs_registry.py."""
src/risk_layer/README.md:3:**Location:** `src/risk_layer/`  
src/risk_layer/README.md:4:**Purpose:** Operational risk management for live trading  
src/risk_layer/README.md:11:This module provides **operational risk management** for live trading:
src/risk_layer/README.md:17:- Emergency stop (kill switch trigger/recovery)
src/risk_layer/README.md:23:## Relationship to `src/risk/`
src/risk_layer/README.md:27:| Aspect | `src/risk_layer/` (This Module) | `src/risk/` |
src/risk_layer/README.md:36:- **`src/risk_layer/`** = "Should we take this risk now?" (pre-trade gate)
src/risk_layer/README.md:37:- **`src/risk/`** = "What risk did we take?" (post-hoc analysis)
src/risk_layer/README.md:43:### Kill Switch (`kill_switch/`)
src/risk_layer/README.md:50:- `execution_gate.py` - ExecutionGate (blocks orders when killed)
src/risk_layer/README.md:65:from src.risk_layer.kill_switch import KillSwitch, ExecutionGate
src/risk_layer/README.md:67:# Create kill switch
src/risk_layer/README.md:70:# Create execution gate
src/risk_layer/README.md:71:gate = ExecutionGate(ks)
src/risk_layer/README.md:75:    gate.check_can_execute()  # Raises TradingBlockedError if killed
src/risk_layer/README.md:85:python -m src.risk_layer.kill_switch.cli status
src/risk_layer/README.md:88:python -m src.risk_layer.kill_switch.cli trigger --reason "Emergency"
src/risk_layer/README.md:91:python -m src.risk_layer.kill_switch.cli recover --approved-by "operator"
src/risk_layer/README.md:92:python -m src.risk_layer.kill_switch.cli complete-recovery
src/risk_layer/README.md:118:from src.risk_layer.alerting import AlertManager, AlertSeverity
src/risk_layer/README.md:148:from src.risk_layer.var_backtest import VaRBacktestRunner
src/risk_layer/README.md:165:- `src/live/shadow_session.py` - Shadow/paper sessions check kill switch
src/risk_layer/README.md:166:- `src/live/risk_limits.py` - LiveRiskLimits can trigger kill switch
src/risk_layer/README.md:167:- `src/execution/pipeline.py` - ExecutionPipeline respects execution gate
src/risk_layer/README.md:184:- `src/live/risk_limits.py` - Sends alerts on risk violations
src/risk_layer/README.md:185:- `src/risk_layer/kill_switch/core.py` - Sends alerts on kill switch trigger
src/risk_layer/README.md:206:- âœ… Execution gate (order blocking)
src/risk_layer/README.md:207:- âœ… Alert dispatch (risk notifications)
src/risk_layer/README.md:211:- âŒ Backtest risk metrics (use `src/risk/` instead)
src/risk_layer/README.md:212:- âŒ Position sizing in backtest (use `src/risk/` instead)
src/risk_layer/README.md:213:- âŒ Monte Carlo simulations (use `src/risk/` instead)
src/risk_layer/README.md:231:# Run kill switch tests
src/risk_layer/README.md:232:uv run pytest tests/risk_layer/kill_switch/ -v
src/risk_layer/README.md:235:uv run pytest tests/risk_layer/alerting/ -v
src/risk_layer/README.md:238:uv run pytest tests/risk_layer/var_backtest/ -v
src/risk_layer/README.md:250:python -m src.risk_layer.kill_switch.cli trigger --reason "Emergency"
src/risk_layer/README.md:253:python -m src.risk_layer.kill_switch.cli status
src/risk_layer/README.md:256:python -m src.risk_layer.kill_switch.cli recover --approved-by "operator"
src/risk_layer/README.md:258:python -m src.risk_layer.kill_switch.cli complete-recovery
src/risk_layer/README.md:265:- **"Which module for live trading?"** â†’ `src/risk_layer/` (this module)
src/risk_layer/README.md:266:- **"Which module for backtest metrics?"** â†’ `src/risk/`
src/risk_layer/README.md:275:src/risk_layer/
src/risk_layer/README.md:277:â”œâ”€â”€ kill_switch/            # Kill Switch (Layer 4)
src/risk_layer/README.md:280:â”‚   â”œâ”€â”€ execution_gate.py
src/risk/risk_layer_manager.py:16:>>> from src.risk import RiskLayerManager
src/risk/risk_layer_manager.py:22:>>> assessment = manager.full_risk_assessment(
src/risk/risk_layer_manager.py:42:    Complete risk assessment result.
src/risk/risk_layer_manager.py:47:        component_var: Component VaR results (if enabled)
src/risk/risk_layer_manager.py:48:        monte_carlo: Monte Carlo VaR results (if enabled)
src/risk/risk_layer_manager.py:49:        stress_test: Stress test results (if enabled)
src/risk/risk_layer_manager.py:50:        backtest: VaR backtest results (if enabled)
src/risk/risk_layer_manager.py:52:        enabled_features: List of enabled features
src/risk/risk_layer_manager.py:62:    enabled_features: List[str] = field(default_factory=list)
src/risk/risk_layer_manager.py:69:            "enabled_features": self.enabled_features,
src/risk/risk_layer_manager.py:82:    Orchestrates all risk components based on config.
src/risk/risk_layer_manager.py:88:    [risk_layer_v1]
src/risk/risk_layer_manager.py:89:    enabled = true
src/risk/risk_layer_manager.py:91:    [risk_layer_v1.var]
src/risk/risk_layer_manager.py:92:    enabled = true
src/risk/risk_layer_manager.py:97:    [risk_layer_v1.component_var]
src/risk/risk_layer_manager.py:98:    enabled = true
src/risk/risk_layer_manager.py:100:    [risk_layer_v1.monte_carlo]
src/risk/risk_layer_manager.py:101:    enabled = true
src/risk/risk_layer_manager.py:106:    [risk_layer_v1.stress_test]
src/risk/risk_layer_manager.py:107:    enabled = true
src/risk/risk_layer_manager.py:110:    [risk_layer_v1.backtest]
src/risk/risk_layer_manager.py:111:    enabled = false  # Requires historical data
src/risk/risk_layer_manager.py:141:        logger.info(f"RiskLayerManager initialized with features: {self.enabled_features}")
src/risk/risk_layer_manager.py:167:        # Check if Risk Layer v1.0 is enabled
src/risk/risk_layer_manager.py:168:        enabled_value = self.get_fn("risk_layer_v1.enabled", False)
src/risk/risk_layer_manager.py:169:        self.enabled = bool(enabled_value)
src/risk/risk_layer_manager.py:172:        self.var_enabled = (
src/risk/risk_layer_manager.py:173:            bool(self.get_fn("risk_layer_v1.var.enabled", True)) if self.enabled else False
src/risk/risk_layer_manager.py:175:        self.component_var_enabled = (
src/risk/risk_layer_manager.py:176:            bool(self.get_fn("risk_layer_v1.component_var.enabled", False))
src/risk/risk_layer_manager.py:177:            if self.enabled
src/risk/risk_layer_manager.py:180:        self.monte_carlo_enabled = (
src/risk/risk_layer_manager.py:181:            bool(self.get_fn("risk_layer_v1.monte_carlo.enabled", False)) if self.enabled else False
src/risk/risk_layer_manager.py:183:        self.stress_test_enabled = (
src/risk/risk_layer_manager.py:184:            bool(self.get_fn("risk_layer_v1.stress_test.enabled", False)) if self.enabled else False
src/risk/risk_layer_manager.py:186:        self.backtest_enabled = (
src/risk/risk_layer_manager.py:187:            bool(self.get_fn("risk_layer_v1.backtest.enabled", False)) if self.enabled else False
src/risk/risk_layer_manager.py:190:        # Collect enabled features
src/risk/risk_layer_manager.py:191:        self.enabled_features = []
src/risk/risk_layer_manager.py:192:        if self.enabled:
src/risk/risk_layer_manager.py:193:            if self.var_enabled:
src/risk/risk_layer_manager.py:194:                self.enabled_features.append("var")
src/risk/risk_layer_manager.py:195:            if self.component_var_enabled:
src/risk/risk_layer_manager.py:196:                self.enabled_features.append("component_var")
src/risk/risk_layer_manager.py:197:            if self.monte_carlo_enabled:
src/risk/risk_layer_manager.py:198:                self.enabled_features.append("monte_carlo")
src/risk/risk_layer_manager.py:199:            if self.stress_test_enabled:
src/risk/risk_layer_manager.py:200:                self.enabled_features.append("stress_test")
src/risk/risk_layer_manager.py:201:            if self.backtest_enabled:
src/risk/risk_layer_manager.py:202:                self.enabled_features.append("backtest")
src/risk/risk_layer_manager.py:207:            from src.risk.covariance import (
src/risk/risk_layer_manager.py:214:                "risk_layer_v1.component_var.covariance_method", "sample"
src/risk/risk_layer_manager.py:218:                min_history=self._get_from_dict("risk_layer_v1.component_var.min_history", 60),
src/risk/risk_layer_manager.py:227:            from src.risk.parametric_var import ParametricVaR, ParametricVaRConfig
src/risk/risk_layer_manager.py:230:                confidence_level=self._get_from_dict("risk_layer_v1.var.confidence_level", 0.95),
src/risk/risk_layer_manager.py:231:                horizon_days=self._get_from_dict("risk_layer_v1.var.horizon_days", 1),
src/risk/risk_layer_manager.py:238:        """Initialize enabled components."""
src/risk/risk_layer_manager.py:239:        # Only initialize if Risk Layer is enabled
src/risk/risk_layer_manager.py:240:        if not self.enabled:
src/risk/risk_layer_manager.py:243:        # We'll rebuild enabled_features after initialization
src/risk/risk_layer_manager.py:244:        self.enabled_features = []
src/risk/risk_layer_manager.py:247:        from src.risk.var import (
src/risk/risk_layer_manager.py:269:        if self.component_var_enabled:
src/risk/risk_layer_manager.py:271:                from src.risk import ComponentVaRCalculator
src/risk/risk_layer_manager.py:283:                self.component_var_enabled = False
src/risk/risk_layer_manager.py:286:        if self.monte_carlo_enabled:
src/risk/risk_layer_manager.py:288:                from src.risk import MonteCarloVaRCalculator, MonteCarloVaRConfig, MonteCarloMethod
src/risk/risk_layer_manager.py:298:                self.monte_carlo_enabled = False
src/risk/risk_layer_manager.py:301:        if self.stress_test_enabled:
src/risk/risk_layer_manager.py:303:                from src.risk import StressTester
src/risk/risk_layer_manager.py:306:                    self.get_fn("risk_layer_v1.stress_test.scenarios_dir", "data/scenarios")
src/risk/risk_layer_manager.py:316:                    self.stress_test_enabled = False
src/risk/risk_layer_manager.py:324:                self.stress_test_enabled = False
src/risk/risk_layer_manager.py:327:        if self.backtest_enabled:
src/risk/risk_layer_manager.py:329:                from src.risk_layer.var_backtest import VaRBacktestRunner
src/risk/risk_layer_manager.py:335:                self.backtest_enabled = False
src/risk/risk_layer_manager.py:337:        # Rebuild enabled_features based on actual initialization
src/risk/risk_layer_manager.py:338:        if self.var_enabled and self.var_functions:
src/risk/risk_layer_manager.py:339:            self.enabled_features.append("var")
src/risk/risk_layer_manager.py:340:        if self.component_var_enabled and self.component_var_calculator:
src/risk/risk_layer_manager.py:341:            self.enabled_features.append("component_var")
src/risk/risk_layer_manager.py:342:        if self.monte_carlo_enabled and self.monte_carlo_calculator_class:
src/risk/risk_layer_manager.py:343:            self.enabled_features.append("monte_carlo")
src/risk/risk_layer_manager.py:344:        if self.stress_test_enabled and self.stress_tester:
src/risk/risk_layer_manager.py:345:            self.enabled_features.append("stress_test")
src/risk/risk_layer_manager.py:346:        if self.backtest_enabled:
src/risk/risk_layer_manager.py:347:            self.enabled_features.append("backtest")
src/risk/risk_layer_manager.py:349:    def full_risk_assessment(
src/risk/risk_layer_manager.py:357:        Perform full risk assessment.
src/risk/risk_layer_manager.py:366:            RiskAssessmentResult with all enabled components
src/risk/risk_layer_manager.py:369:            >>> assessment = manager.full_risk_assessment(
src/risk/risk_layer_manager.py:376:        if not self.enabled:
src/risk/risk_layer_manager.py:379:                warnings=["Risk Layer v1.0 disabled in config"], enabled_features=[]
src/risk/risk_layer_manager.py:382:        result = RiskAssessmentResult(enabled_features=self.enabled_features)
src/risk/risk_layer_manager.py:389:        if self.var_enabled:
src/risk/risk_layer_manager.py:390:            methods = self.get_fn("risk_layer_v1.var.methods", ["historical", "parametric"])
src/risk/risk_layer_manager.py:404:        if self.component_var_enabled and self.component_var_calculator:
src/risk/risk_layer_manager.py:416:        if self.monte_carlo_enabled and self.monte_carlo_calculator_class:
src/risk/risk_layer_manager.py:419:                method_str = str(self.get_fn("risk_layer_v1.monte_carlo.method", "normal"))
src/risk/risk_layer_manager.py:424:                        self.get_fn("risk_layer_v1.monte_carlo.n_simulations", 10000)
src/risk/risk_layer_manager.py:427:                    seed=int(self.get_fn("risk_layer_v1.monte_carlo.seed", 42)),
src/risk/risk_layer_manager.py:429:                        self.get_fn("risk_layer_v1.monte_carlo.confidence_level", 0.95)
src/risk/risk_layer_manager.py:431:                    horizon_days=int(self.get_fn("risk_layer_v1.monte_carlo.horizon_days", 1)),
src/risk/risk_layer_manager.py:442:        if self.stress_test_enabled and self.stress_tester:
src/risk/risk_layer_manager.py:452:        if self.backtest_enabled:
src/risk/risk_layer_manager.py:454:                "VaR Backtesting requires historical violation data (not implemented in full_risk_assessment)"
src/risk/risk_layer_manager.py:465:        Generate risk assessment report.
src/risk/risk_layer_manager.py:468:            assessment: RiskAssessmentResult from full_risk_assessment()
src/risk/risk_layer_manager.py:488:            f"**Enabled Features:** {', '.join(assessment.enabled_features)}",
src/risk/risk_layer_manager.py:561:    <p><strong>Enabled Features:</strong> {", ".join(assessment.enabled_features)}</p>
src/risk/risk_layer_manager.py:574:        return f"<RiskLayerManager(enabled={self.enabled}, features={self.enabled_features})>"
src/risk/risk_layer_manager.py:577:def build_risk_layer_manager_from_config(config: Any) -> Optional[RiskLayerManager]:
src/risk/risk_layer_manager.py:585:        RiskLayerManager if enabled, else None
src/risk/risk_layer_manager.py:589:    [risk_layer_v1]
src/risk/risk_layer_manager.py:590:    enabled = true
src/risk/risk_layer_manager.py:592:    [risk_layer_v1.var]
src/risk/risk_layer_manager.py:593:    enabled = true
src/risk/risk_layer_manager.py:596:    [risk_layer_v1.component_var]
src/risk/risk_layer_manager.py:597:    enabled = true
src/risk/risk_layer_manager.py:599:    [risk_layer_v1.monte_carlo]
src/risk/risk_layer_manager.py:600:    enabled = true
src/risk/risk_layer_manager.py:604:    [risk_layer_v1.stress_test]
src/risk/risk_layer_manager.py:605:    enabled = true
src/risk/risk_layer_manager.py:608:    # Check if enabled
src/risk/risk_layer_manager.py:626:    enabled = bool(get_fn("risk_layer_v1.enabled", False))
src/risk/risk_layer_manager.py:627:    if not enabled:
src/obs/ai_telemetry.py:14:- Leichtgewichtig (keine Imports aus execution/risk/governance heavy paths)
src/obs/ai_telemetry.py:57:    Normalize label values to reduce cardinality risks:
src/orders/testnet_executor.py:53:    from src.live.risk_limits import LiveRiskLimits, LiveRiskCheckResult
src/orders/testnet_executor.py:109:        risk_check_passed: Ob der Risk-Check bestanden wurde
src/orders/testnet_executor.py:118:    risk_check_passed: bool = True
src/orders/testnet_executor.py:161:        ...     risk_limits=risk_limits,
src/orders/testnet_executor.py:170:        risk_limits: Optional["LiveRiskLimits"] = None,
src/orders/testnet_executor.py:179:            risk_limits: Optionale LiveRiskLimits fuer Risk-Pruefungen
src/orders/testnet_executor.py:187:        self._risk_limits = risk_limits
src/orders/testnet_executor.py:211:            f"risk_limits_enabled={self._risk_limits is not None}"
src/orders/testnet_executor.py:238:    def _check_risk_limits(
src/orders/testnet_executor.py:253:        if self._risk_limits is None:
src/orders/testnet_executor.py:277:        return self._risk_limits.check_orders(live_orders)
src/orders/testnet_executor.py:289:        3. Sendet Order an Exchange (wenn risk_check ok)
src/orders/testnet_executor.py:325:            self._log_execution(order, result, now, risk_check_passed=False)
src/orders/testnet_executor.py:329:        risk_result = self._check_risk_limits([order], current_price)
src/orders/testnet_executor.py:330:        if risk_result is not None and not risk_result.allowed:
src/orders/testnet_executor.py:331:            logger.warning(f"[TESTNET EXECUTOR] Risk-Limits verletzt: {risk_result.reasons}")
src/orders/testnet_executor.py:336:                reason=f"risk_limit_violation: {'; '.join(risk_result.reasons)}",
src/orders/testnet_executor.py:340:                    "risk_reasons": risk_result.reasons,
src/orders/testnet_executor.py:341:                    "risk_metrics": risk_result.metrics,
src/orders/testnet_executor.py:344:            self._log_execution(order, result, now, risk_check_passed=False)
src/orders/testnet_executor.py:444:        risk_result = self._check_risk_limits(orders, current_price)
src/orders/testnet_executor.py:445:        if risk_result is not None and not risk_result.allowed:
src/orders/testnet_executor.py:446:            logger.warning(f"[TESTNET EXECUTOR] Batch Risk-Limits verletzt: {risk_result.reasons}")
src/orders/testnet_executor.py:456:                    reason=f"batch_risk_limit_violation: {'; '.join(risk_result.reasons)}",
src/orders/testnet_executor.py:460:                        "risk_reasons": risk_result.reasons,
src/orders/testnet_executor.py:461:                        "risk_metrics": risk_result.metrics,
src/orders/testnet_executor.py:465:                self._log_execution(order, result, now, risk_check_passed=False)
src/orders/testnet_executor.py:478:        risk_check_passed: bool = True,
src/orders/testnet_executor.py:488:            risk_check_passed=risk_check_passed,
src/orders/testnet_executor.py:506:        risk_blocked = [log for log in self._execution_log if not log.risk_check_passed]
src/orders/testnet_executor.py:521:            "risk_blocked_orders": len(risk_blocked),
src/orders/testnet_executor.py:549:    risk_limits: Optional["LiveRiskLimits"] = None,
src/orders/testnet_executor.py:557:        risk_limits: Optionale LiveRiskLimits (sonst aus Config)
src/orders/testnet_executor.py:573:    from src.live.risk_limits import LiveRiskLimits
src/orders/testnet_executor.py:590:    if risk_limits is None:
src/orders/testnet_executor.py:592:        risk_limits = LiveRiskLimits.from_config(cfg, starting_cash=starting_cash)
src/orders/testnet_executor.py:597:        risk_limits=risk_limits,
src/core/risk.py:1:# src/core/risk.py
src/core/risk.py:255:        from ..risk import RiskLimitsV2, RiskEnforcer
src/core/risk.py:306:        from ..risk import PositionSnapshot, PortfolioSnapshot
src/core/risk.py:382:def build_risk_manager_from_config(
src/core/risk.py:384:    section: str = "risk",
src/core/risk.py:398:    [risk]
src/core/risk.py:406:    [risk.limits]
src/core/risk.py:416:        >>> risk_mgr = build_risk_manager_from_config(cfg)
src/reporting/regime_reporting.py:356:    risk_on_bucket = next((b for b in regime_stats.buckets if b.regime_value == 1), None)
src/reporting/regime_reporting.py:357:    risk_off_bucket = next((b for b in regime_stats.buckets if b.regime_value == -1), None)
src/reporting/regime_reporting.py:360:    if risk_on_bucket:
src/reporting/regime_reporting.py:362:            (risk_on_bucket.return_total / regime_stats.overall_return * 100)
src/reporting/regime_reporting.py:368:            f"({risk_on_bucket.time_fraction:.1%} der Zeit, {risk_on_bucket.num_trades} Trades)"
src/reporting/regime_reporting.py:371:    if risk_off_bucket:
src/reporting/regime_reporting.py:373:            f"- **Risk-Off** hat einen Max-Drawdown von {format_metric(risk_off_bucket.max_drawdown, 'drawdown')} "
src/reporting/regime_reporting.py:374:            f"({risk_off_bucket.time_fraction:.1%} der Zeit)"
src/risk_layer/alerting/channels/webhook_channel.py:14:from src.risk_layer.alerting.alert_event import AlertEvent
src/risk_layer/alerting/channels/webhook_channel.py:15:from src.risk_layer.alerting.alert_types import AlertSeverity
src/risk_layer/alerting/channels/webhook_channel.py:16:from src.risk_layer.alerting.channels.base_channel import (
src/risk_layer/alerting/channels/webhook_channel.py:58:        if not self.url and self._enabled:
src/risk_layer/alerting/channels/webhook_channel.py:61:            self._enabled = False
src/risk_layer/alerting/channels/webhook_channel.py:115:        if not self._enabled:
src/live/__init__.py:28:from .risk_limits import LiveRiskLimits, LiveRiskConfig, LiveRiskCheckResult
src/live/safety.py:193:            LiveTradingDisabledError: enable_live_trading = False
src/live/safety.py:236:                if "enable_live_trading=False" in reason_detail:
src/live/safety.py:237:                    reason = "enable_live_trading = False (Gate 1)"
src/live/safety.py:240:                        f"Live-Trading ist deaktiviert (enable_live_trading=False). "
src/live/safety.py:241:                        f"Setze enable_live_trading=True in der Config, um fortzufahren."
src/live/safety.py:244:                if "live_mode_armed=False" in reason_detail:
src/live/safety.py:245:                    reason = "live_mode_armed = False (Gate 2 - Phase 71)"
src/live/safety.py:248:                        f"Live-Modus ist nicht 'armed' (live_mode_armed=False). "
src/live/safety.py:250:                        f"Setze live_mode_armed=True in der Config (nur fÃ¼r Design-Tests)."
src/live/safety.py:411:        2. enable_live_trading == True (Gate 1)
src/live/safety.py:412:        3. live_mode_armed == True (Gate 2 - Phase 71)
src/live/safety.py:432:        ...     enable_live_trading=True,
src/live/safety.py:433:        ...     live_mode_armed=True,
src/live/safety.py:447:    # Kriterium 2: Gate 1 - enable_live_trading
src/live/safety.py:448:    if not env_config.enable_live_trading:
src/live/safety.py:449:        return (False, "enable_live_trading=False (Gate 1 blockiert)")
src/live/safety.py:451:    # Kriterium 3: Gate 2 - live_mode_armed (Phase 71)
src/live/safety.py:452:    if not env_config.live_mode_armed:
src/live/safety.py:453:        return (False, "live_mode_armed=False (Gate 2 blockiert - Phase 71)")
src/core/environment.py:55:        enable_live_trading: ZusÃ¤tzlicher Safety-Schalter fÃ¼r Live-Trading
src/core/environment.py:60:        live_mode_armed: Zweistufiges Gating: zusÃ¤tzlicher "Armed"-Flag fÃ¼r Live
src/core/environment.py:70:        - enable_live_trading = False blockt alle echten Orders
src/core/environment.py:72:        - live_mode_armed = False blockt Live zusÃ¤tzlich (zweistufiges Gating)
src/core/environment.py:78:    enable_live_trading: bool = False
src/core/environment.py:84:    live_mode_armed: bool = False
src/core/environment.py:134:            # Zweistufiges Gating: enable_live_trading + live_mode_armed
src/core/environment.py:135:            if not self.enable_live_trading:
src/core/environment.py:137:            if not self.live_mode_armed:
src/core/environment.py:179:        enable_live_trading=peak_config.get("environment.enable_live_trading", False),
src/core/environment.py:185:        live_mode_armed=peak_config.get("environment.live_mode_armed", False),
src/core/environment.py:207:        enable_live_trading=False,
src/core/environment.py:213:        live_mode_armed=False,
src/strategies/armstrong/armstrong_cycle_strategy.py:104:        use_risk_scaling: Ob Risk-Multiplier angewendet werden soll
src/strategies/armstrong/armstrong_cycle_strategy.py:111:        use_risk_scaling: Ob Risk-Multiplier verwendet werden soll
src/strategies/armstrong/armstrong_cycle_strategy.py:143:        use_risk_scaling: bool = True,
src/strategies/armstrong/armstrong_cycle_strategy.py:156:            use_risk_scaling: Ob Risk-Multiplier angewendet werden soll
src/strategies/armstrong/armstrong_cycle_strategy.py:167:            "use_risk_scaling": use_risk_scaling,
src/strategies/armstrong/armstrong_cycle_strategy.py:196:        self.use_risk_scaling = self.config.get("use_risk_scaling", use_risk_scaling)
src/strategies/armstrong/armstrong_cycle_strategy.py:261:        use_risk = cfg.get(f"{section}.use_risk_scaling", True)
src/strategies/armstrong/armstrong_cycle_strategy.py:269:            use_risk_scaling=use_risk,
src/reporting/experiment_report.py:421:            ("param_neutral_scale", "param_risk_off_scale"),
src/reporting/experiment_report.py:422:            ("param_risk_on_scale", "param_neutral_scale"),
src/reporting/experiment_report.py:423:            ("param_neutral_scale", "param_risk_on_scale"),
src/risk_layer/types.py:5:Type stubs and protocols for risk management components.
src/risk_layer/types.py:52:    Component VaR for risk attribution.
src/risk_layer/types.py:75:    Result of risk model validation (backtesting).
src/risk_layer/types.py:127:    Comprehensive risk metrics for monitoring and reporting.
src/risk_layer/types.py:137:        stress_score: Aggregate stress test score
src/risk_layer/types.py:154:    Configuration for risk layer operations.
src/risk_layer/types.py:160:        enabled: Whether risk layer is enabled
src/risk_layer/types.py:163:        cvar_enabled: Whether to calculate CVaR
src/risk_layer/types.py:164:        stress_testing_enabled: Whether to run stress tests
src/risk_layer/types.py:169:    enabled: bool = False
src/risk_layer/types.py:172:    cvar_enabled: bool = False
src/risk_layer/types.py:173:    stress_testing_enabled: bool = False
src/risk_layer/types.py:201:    Risk layer needs to assess portfolio risk without depending on
src/risk_layer/alerting/channels/telegram_channel.py:14:from src.risk_layer.alerting.alert_event import AlertEvent
src/risk_layer/alerting/channels/telegram_channel.py:15:from src.risk_layer.alerting.alert_types import AlertSeverity
src/risk_layer/alerting/channels/telegram_channel.py:16:from src.risk_layer.alerting.channels.base_channel import (
src/risk_layer/alerting/channels/telegram_channel.py:59:        if self._enabled and (not self.bot_token or not self.chat_id):
src/risk_layer/alerting/channels/telegram_channel.py:62:            self._enabled = False
src/risk_layer/alerting/channels/telegram_channel.py:162:        if not self._enabled:
src/core/peak_config.py:291:    - Apply only in live-like environments OR when enable_live_trading is True.
src/core/peak_config.py:298:    if cfg.get("environment.enable_live_trading", False):
src/live/alert_pipeline.py:36:        source="live_risk_severity",
src/live/alert_pipeline.py:87:    def from_risk_status(cls, status: str) -> "AlertSeverity":
src/live/alert_pipeline.py:170:        source: Quelle des Alerts (z.B. "live_risk_severity", "live_risk_limits")
src/live/alert_pipeline.py:210:    - is_enabled: Ob der Channel aktiv ist
src/live/alert_pipeline.py:222:    def is_enabled(self) -> bool:
src/live/alert_pipeline.py:257:        enabled: Ob der Channel aktiviert ist
src/live/alert_pipeline.py:266:    enabled: bool = True
src/live/alert_pipeline.py:309:    def is_enabled(self) -> bool:
src/live/alert_pipeline.py:310:        return self._config.enabled and bool(self._config.webhook_url)
src/live/alert_pipeline.py:323:        if not self.is_enabled:
src/live/alert_pipeline.py:496:        enabled: Ob der Channel aktiviert ist
src/live/alert_pipeline.py:508:    enabled: bool = False
src/live/alert_pipeline.py:544:    def is_enabled(self) -> bool:
src/live/alert_pipeline.py:546:            self._config.enabled
src/live/alert_pipeline.py:563:        if not self.is_enabled:
src/live/alert_pipeline.py:770:    def is_enabled(self) -> bool:
src/live/alert_pipeline.py:829:    def enabled_channels(self) -> List[AlertChannel]:
src/live/alert_pipeline.py:831:        return [c for c in self._channels if c.is_enabled]
src/live/alert_pipeline.py:848:        - Channel muss enabled sein
src/live/alert_pipeline.py:873:            if not channel.is_enabled:
src/live/alert_pipeline.py:970:    def send_risk_alert(
src/live/alert_pipeline.py:1126:            self._logger.debug(f"Initial risk status: {new_status}")
src/live/alert_pipeline.py:1168:            source="live_risk_severity",
src/live/alert_pipeline.py:1198:        enabled = true
src/live/alert_pipeline.py:1202:        enabled = true
src/live/alert_pipeline.py:1210:        enabled = false
src/live/alert_pipeline.py:1221:        enabled = true
src/live/alert_pipeline.py:1222:        enabled_environments = ["live"]
src/live/alert_pipeline.py:1236:    if not alerts_config.get("enabled", True):
src/live/alert_pipeline.py:1248:    if slack_config.get("enabled", False):
src/live/alert_pipeline.py:1258:                enabled=True,
src/live/alert_pipeline.py:1264:            logger.warning("Slack channel enabled but no webhook_url configured")
src/live/alert_pipeline.py:1268:    if email_config.get("enabled", False):
src/live/alert_pipeline.py:1285:                enabled=True,
src/live/alert_pipeline.py:1291:            logger.warning("Email channel enabled but no smtp_host configured")
src/live/alert_pipeline.py:1328:        if not escalation_config.get("enabled", False):
src/data/kraken_live.py:182:        enabled: Session aktiviert
src/data/kraken_live.py:194:    enabled: bool = True
src/data/kraken_live.py:708:        enabled=cfg.get("shadow_paper.enabled", True),
src/live/execution_bridge.py:28:        kind: Event kind (gate/intent/order/fill)
src/live/execution_bridge.py:145:        elif kind == "gate":
src/live/execution_bridge.py:146:            gate_name = payload.get("gate_name", "")
src/live/execution_bridge.py:149:            description = f"Gate [{gate_name}]: {status}"
src/risk_layer/alerting/alert_dispatcher.py:12:from src.risk_layer.alerting.alert_event import AlertEvent
src/live/testnet_limits.py:12:Das Modul ergaenzt die bestehenden LiveRiskLimits (src/live/risk_limits.py)
src/risk_layer/alerting/channels/email_channel.py:14:from src.risk_layer.alerting.alert_event import AlertEvent
src/risk_layer/alerting/channels/email_channel.py:15:from src.risk_layer.alerting.alert_types import AlertSeverity
src/risk_layer/alerting/channels/email_channel.py:16:from src.risk_layer.alerting.channels.base_channel import (
src/risk_layer/alerting/channels/email_channel.py:66:        if self._enabled:
src/risk_layer/alerting/channels/email_channel.py:80:                self._enabled = False
src/risk_layer/alerting/channels/email_channel.py:260:        if not self._enabled:
src/live/alert_manager.py:84:            source: Quelle des Alerts (z.B. "monitoring", "risk", "exchange")
src/core/experiments.py:39:RUN_TYPE_LIVE_RISK_CHECK = "live_risk_check"
src/core/experiments.py:370:def log_live_risk_check(
src/core/experiments.py:396:    run_name = f"live_risk_check_{ts_label}"
src/core/experiments.py:398:        run_name = f"live_risk_check_{tag}_{ts_label}"
src/core/experiments.py:411:        "runner": "check_live_risk_limits.py",
src/core/experiments.py:551:        allocation_method: Allocation-Methode ("equal", "risk_parity", "sharpe_weighted", "manual")
src/live/risk_limits.py:3:# src/live/risk_limits.py
src/live/risk_limits.py:49:    [live_risk]
src/live/risk_limits.py:50:    enabled = true
src/live/risk_limits.py:137:def aggregate_severities(severities: Sequence[RiskCheckSeverity]) -> RiskCheckSeverity:
src/live/risk_limits.py:195:    enabled: bool
src/live/risk_limits.py:244:    def risk_status(self) -> RiskStatus:
src/live/risk_limits.py:315:        enabled = _get_bool("live_risk.enabled", True)
src/live/risk_limits.py:317:        max_daily_loss_abs = _get_float("live_risk.max_daily_loss_abs")
src/live/risk_limits.py:318:        max_daily_loss_pct = _get_float("live_risk.max_daily_loss_pct")
src/live/risk_limits.py:320:        max_total_exposure_notional = _get_float("live_risk.max_total_exposure_notional")
src/live/risk_limits.py:321:        max_symbol_exposure_notional = _get_float("live_risk.max_symbol_exposure_notional")
src/live/risk_limits.py:322:        max_open_positions = cfg.get("live_risk.max_open_positions", None)
src/live/risk_limits.py:328:        max_order_notional = _get_float("live_risk.max_order_notional")
src/live/risk_limits.py:330:        block_on_violation = _get_bool("live_risk.block_on_violation", True)
src/live/risk_limits.py:331:        use_experiments_for_daily_pnl = _get_bool("live_risk.use_experiments_for_daily_pnl", True)
src/live/risk_limits.py:334:        max_live_notional_per_order = _get_float("live_risk.max_live_notional_per_order")
src/live/risk_limits.py:335:        max_live_notional_total = _get_float("live_risk.max_live_notional_total")
src/live/risk_limits.py:336:        live_trade_min_size = _get_float("live_risk.live_trade_min_size")
src/live/risk_limits.py:339:        warning_threshold_factor = _get_float("live_risk.warning_threshold_factor")
src/live/risk_limits.py:346:            enabled=enabled,
src/live/risk_limits.py:395:    def _compute_orders_aggregates(
src/live/risk_limits.py:595:        if not self.config.enabled:
src/live/risk_limits.py:598:                from src.obs import strategy_risk_telemetry as _srt
src/live/risk_limits.py:600:                _srt.inc_risk_check(check="live_limits.check_orders", result="disabled", n=1)
src/live/risk_limits.py:603:            aggregates = self._compute_orders_aggregates(orders)
src/live/risk_limits.py:608:                    **aggregates,
src/live/risk_limits.py:611:                    "live_risk_enabled": False,
src/live/risk_limits.py:617:        aggregates = self._compute_orders_aggregates(orders)
src/live/risk_limits.py:618:        total_notional = aggregates["total_notional"]
src/live/risk_limits.py:619:        max_order_notional = aggregates["max_order_notional"]
src/live/risk_limits.py:620:        max_symbol_exposure_notional = aggregates["max_symbol_exposure_notional"]
src/live/risk_limits.py:621:        n_orders = aggregates["n_orders"]
src/live/risk_limits.py:622:        n_symbols = aggregates["n_symbols"]
src/live/risk_limits.py:733:        overall_severity = aggregate_severities(severities)
src/live/risk_limits.py:743:            "live_risk_enabled": True,
src/live/risk_limits.py:757:            from src.obs import strategy_risk_telemetry as _srt
src/live/risk_limits.py:760:                _srt.inc_risk_check(check="live_limits.check_orders", result="block", n=1)
src/live/risk_limits.py:762:                _srt.inc_risk_check(check="live_limits.check_orders", result="warn", n=1)
src/live/risk_limits.py:764:                _srt.inc_risk_check(check="live_limits.check_orders", result="allow", n=1)
src/live/risk_limits.py:768:                _srt.set_risk_limit_utilization(
src/live/risk_limits.py:773:                    _srt.inc_risk_block(reason=f"limit:{d.limit_name}", n=1)
src/live/risk_limits.py:779:            self._emit_risk_alert(
src/live/risk_limits.py:781:                source="live_risk.orders",
src/live/risk_limits.py:783:                message="Live risk limit violation for proposed order batch.",
src/live/risk_limits.py:791:            self._emit_risk_alert(
src/live/risk_limits.py:793:                source="live_risk.orders",
src/live/risk_limits.py:795:                message="Live risk limit warning for proposed order batch.",
src/live/risk_limits.py:807:    def _emit_risk_alert(
src/live/risk_limits.py:821:            source: Alert-Source (z.B. "live_risk.orders", "live_risk.portfolio")
src/live/risk_limits.py:880:            >>> monitor = LivePortfolioMonitor(exchange_client, risk_limits)
src/live/risk_limits.py:882:            >>> result = risk_limits.evaluate_portfolio(snapshot)
src/live/risk_limits.py:885:            >>> print(f"Status: {result.risk_status}")  # "green", "yellow" oder "red"
src/live/risk_limits.py:892:        if not self.config.enabled:
src/live/risk_limits.py:903:                    "live_risk_enabled": False,
src/live/risk_limits.py:1015:        overall_severity = aggregate_severities(severities)
src/live/risk_limits.py:1025:            "live_risk_enabled": True,
src/live/risk_limits.py:1047:            self._emit_risk_alert(
src/live/risk_limits.py:1049:                source="live_risk.portfolio",
src/live/risk_limits.py:1051:                message="Live risk limit violation for current portfolio snapshot.",
src/live/risk_limits.py:1060:            self._emit_risk_alert(
src/live/risk_limits.py:1062:                source="live_risk.portfolio",
src/live/risk_limits.py:1064:                message="Live risk limit warning for current portfolio snapshot.",
src/reporting/trigger_training_report.py:92:def _aggregate_outcomes(df: pd.DataFrame) -> pd.DataFrame:
src/reporting/trigger_training_report.py:132:def _aggregate_tags(df: pd.DataFrame) -> pd.DataFrame:
src/reporting/trigger_training_report.py:769:    outcome_agg = _aggregate_outcomes(df)
src/reporting/trigger_training_report.py:772:    tag_agg = _aggregate_tags(df)
src/risk_layer/__init__.py:4:This package is the canonical entry point for risk-related primitives and layers.
src/risk_layer/__init__.py:16:from src.risk_layer.adapters import order_to_dict, to_order
src/risk_layer/__init__.py:19:from src.risk_layer.kill_switch import KillSwitchLayer, KillSwitchStatus
src/risk_layer/alerting/alert_event.py:13:from src.risk_layer.alerting.alert_types import AlertCategory, AlertSeverity
src/risk_layer/alerting/channels/base_channel.py:15:from src.risk_layer.alerting.alert_event import AlertEvent
src/risk_layer/alerting/channels/base_channel.py:16:from src.risk_layer.alerting.alert_types import AlertSeverity
src/risk_layer/alerting/channels/base_channel.py:72:        self._enabled = config.get("enabled", False)  # Default: disabled
src/risk_layer/alerting/channels/base_channel.py:76:            status=ChannelStatus.HEALTHY if self._enabled else ChannelStatus.DISABLED,
src/risk_layer/alerting/channels/base_channel.py:81:    def is_enabled(self) -> bool:
src/risk_layer/alerting/channels/base_channel.py:82:        """Check if channel is enabled."""
src/risk_layer/alerting/channels/base_channel.py:83:        return self._enabled
src/risk_layer/alerting/channels/base_channel.py:93:            True if event meets severity threshold and channel is enabled
src/risk_layer/alerting/channels/base_channel.py:95:        if not self._enabled:
src/risk_layer/alerting/channels/base_channel.py:168:        status = "enabled" if self._enabled else "disabled"
src/data/shadow/_guards.py:7:3. Config Guard: prÃ¼ft ob Pipeline enabled
src/data/shadow/_guards.py:17:    """Raised wenn Shadow Pipeline nicht enabled ist."""
src/data/shadow/_guards.py:48:        cfg: Config-Dict (nested, z.B. {"live": {"enabled": false}})
src/data/shadow/_guards.py:56:    # Check Config: live.enabled
src/data/shadow/_guards.py:57:    live_enabled = cfg.get("live", {}).get("enabled", False)
src/data/shadow/_guards.py:58:    if live_enabled:
src/data/shadow/_guards.py:67:    Config Guard: prÃ¼ft ob Pipeline enabled ist.
src/data/shadow/_guards.py:75:    pipeline_enabled = cfg.get("shadow", {}).get("pipeline", {}).get("enabled", False)
src/data/shadow/_guards.py:76:    if not pipeline_enabled:
src/live/testnet_orchestrator.py:214:            from .risk_limits import LiveRiskLimits
src/live/testnet_orchestrator.py:216:            risk_limits = LiveRiskLimits.from_config(self._config)
src/live/testnet_orchestrator.py:217:            if not risk_limits.config.enabled:
src/live/testnet_orchestrator.py:253:        from .risk_limits import LiveRiskLimits
src/live/testnet_orchestrator.py:285:        risk_limits = LiveRiskLimits.from_config(
src/live/testnet_orchestrator.py:298:            risk_limits=risk_limits,
src/live/audit.py:32:from src.live.risk_limits import LiveRiskLimits
src/live/audit.py:51:        enable_live_trading: Gate 1
src/live/audit.py:52:        live_mode_armed: Gate 2 (Phase 71)
src/live/audit.py:60:    enable_live_trading: bool
src/live/audit.py:61:    live_mode_armed: bool
src/live/audit.py:76:        limits_enabled: Ob Risk-Limits aktiviert sind
src/live/audit.py:83:    limits_enabled: bool
src/live/audit.py:128:        risk: Risk-Limits-Status
src/live/audit.py:137:    risk: LiveAuditRiskState = None  # type: ignore
src/live/audit.py:151:    live_risk_limits: Optional[LiveRiskLimits] = None,
src/live/audit.py:160:        live_risk_limits: Optional LiveRiskLimits-Instanz
src/live/audit.py:182:        enable_live_trading=env_config.enable_live_trading,
src/live/audit.py:183:        live_mode_armed=env_config.live_mode_armed,
src/live/audit.py:190:    if live_risk_limits:
src/live/audit.py:191:        risk_config = live_risk_limits.config
src/live/audit.py:192:        risk = LiveAuditRiskState(
src/live/audit.py:193:            max_live_notional_per_order=risk_config.max_live_notional_per_order,
src/live/audit.py:194:            max_live_notional_total=risk_config.max_live_notional_total,
src/live/audit.py:195:            live_trade_min_size=risk_config.live_trade_min_size,
src/live/audit.py:196:            limits_enabled=risk_config.enabled,
src/live/audit.py:200:        risk = LiveAuditRiskState(
src/live/audit.py:204:            limits_enabled=False,
src/live/audit.py:227:            if not env_config.enable_live_trading:
src/live/audit.py:228:                reasons.append("Gate 1: enable_live_trading=False")
src/live/audit.py:229:            if not env_config.live_mode_armed:
src/live/audit.py:230:                reasons.append("Gate 2: live_mode_armed=False (Phase 71)")
src/live/audit.py:254:        risk=risk,
src/live/audit.py:280:            "enable_live_trading": snapshot.gating.enable_live_trading,
src/live/audit.py:281:            "live_mode_armed": snapshot.gating.live_mode_armed,
src/live/audit.py:286:        "risk": {
src/live/audit.py:287:            "max_live_notional_per_order": snapshot.risk.max_live_notional_per_order,
src/live/audit.py:288:            "max_live_notional_total": snapshot.risk.max_live_notional_total,
src/live/audit.py:289:            "live_trade_min_size": snapshot.risk.live_trade_min_size,
src/live/audit.py:290:            "limits_enabled": snapshot.risk.limits_enabled,
src/live/audit.py:291:            "limits_source": snapshot.risk.limits_source,
src/live/audit.py:336:    lines.append(f"- **enable_live_trading (Gate 1):** {snapshot.gating.enable_live_trading}")
src/live/audit.py:337:    lines.append(f"- **live_mode_armed (Gate 2 - Phase 71):** {snapshot.gating.live_mode_armed}")
src/live/audit.py:348:    lines.append(f"- **Limits Enabled:** {snapshot.risk.limits_enabled}")
src/live/audit.py:349:    lines.append(f"- **Limits Source:** {snapshot.risk.limits_source}")
src/live/audit.py:350:    lines.append(f"- **max_live_notional_per_order:** {snapshot.risk.max_live_notional_per_order}")
src/live/audit.py:351:    lines.append(f"- **max_live_notional_total:** {snapshot.risk.max_live_notional_total}")
src/live/audit.py:352:    lines.append(f"- **live_trade_min_size:** {snapshot.risk.live_trade_min_size}")
src/live/risk_runbook.py:1:# src/live/risk_runbook.py
src/live/risk_runbook.py:37:    from src.live.risk_runbook import (
src/webui/services/knowledge_service.py:220:            ReadonlyModeError: If KNOWLEDGE_READONLY is enabled
src/webui/services/knowledge_service.py:343:            ReadonlyModeError: If KNOWLEDGE_READONLY is enabled
src/risk_layer/alerting/alert_types.py:57:    and enable targeted routing to appropriate channels.
src/risk_layer/alerting/alert_types.py:60:    RISK_LIMIT = "risk_limit"
src/live/monitoring.py:351:            if "risk_reasons" in last_event and pd.notna(last_event["risk_reasons"]):
src/live/monitoring.py:352:                error_str = str(last_event["risk_reasons"]).strip()
src/reporting/walkforward_report.py:86:    aggregate_section = _build_aggregate_metrics_section(result)
src/reporting/walkforward_report.py:87:    report.add_section(aggregate_section)
src/reporting/walkforward_report.py:123:    if result.aggregate_metrics:
src/reporting/walkforward_report.py:126:        avg_sharpe = result.aggregate_metrics.get("avg_sharpe", 0.0)
src/reporting/walkforward_report.py:127:        avg_return = result.aggregate_metrics.get("avg_return", 0.0)
src/reporting/walkforward_report.py:128:        win_rate = result.aggregate_metrics.get("win_rate_windows", 0.0)
src/reporting/walkforward_report.py:136:def _build_aggregate_metrics_section(result: Any) -> ReportSection:
src/reporting/walkforward_report.py:138:    if not result.aggregate_metrics:
src/reporting/walkforward_report.py:139:        return ReportSection(title="Aggregate Metrics", content_markdown="No metrics available.")
src/reporting/walkforward_report.py:144:    metrics = result.aggregate_metrics
src/reporting/walkforward_report.py:173:    return ReportSection(title="Aggregate Metrics", content_markdown="\n".join(table_lines))
src/reporting/walkforward_report.py:278:        metrics = result.aggregate_metrics
src/risk_layer/alerting/channels/slack_channel.py:14:from src.risk_layer.alerting.alert_event import AlertEvent
src/risk_layer/alerting/channels/slack_channel.py:15:from src.risk_layer.alerting.alert_types import AlertSeverity
src/risk_layer/alerting/channels/slack_channel.py:16:from src.risk_layer.alerting.channels.base_channel import (
src/risk_layer/alerting/channels/slack_channel.py:68:        if not self.webhook_url and self._enabled:
src/risk_layer/alerting/channels/slack_channel.py:71:            self._enabled = False
src/risk_layer/alerting/channels/slack_channel.py:193:        if not self._enabled:
src/live/run_logging.py:66:        enabled: Logging aktiviert
src/live/run_logging.py:73:        log_risk_details: Risk-Check-Details loggen
src/live/run_logging.py:76:    enabled: bool = True
src/live/run_logging.py:83:    log_risk_details: bool = True
src/live/run_logging.py:97:        enabled=cfg.get("shadow_paper_logging.enabled", True),
src/live/run_logging.py:106:        log_risk_details=cfg.get("shadow_paper_logging.log_risk_details", True),
src/live/run_logging.py:217:        risk_allowed: Ob Risk-Check bestanden
src/live/run_logging.py:218:        risk_reasons: GrÃ¼nde fÃ¼r Risk-Block
src/live/run_logging.py:254:    risk_allowed: bool = True
src/live/run_logging.py:255:    risk_reasons: str = ""
src/live/run_logging.py:409:        if not self._cfg.enabled:
src/live/run_logging.py:446:        if not self._cfg.enabled or self._logging_disabled_due_to_error:
src/live/run_logging.py:504:        if not self._cfg.enabled:
src/data/safety/__init__.py:7:    from .data_safety_gate import (
src/data/safety/__init__.py:28:        module = importlib.import_module(".data_safety_gate", __name__)
src/risk_layer/alerting/alert_config.py:19:from src.risk_layer.alerting.alert_types import AlertSeverity
src/risk_layer/alerting/alert_config.py:28:        enabled: Whether alerting is active (default: False for safety)
src/risk_layer/alerting/alert_config.py:35:    enabled: bool = False
src/risk_layer/alerting/alert_config.py:60:    def is_channel_enabled(self, channel_name: str) -> bool:
src/risk_layer/alerting/alert_config.py:62:        Check if a specific channel is enabled.
src/risk_layer/alerting/alert_config.py:68:            True if channel exists and is enabled
src/risk_layer/alerting/alert_config.py:73:        return channel_cfg.get("enabled", False)
src/risk_layer/alerting/alert_config.py:136:        enabled = true
src/risk_layer/alerting/alert_config.py:141:        enabled = false
src/risk_layer/alerting/alert_config.py:169:    enabled = alerting_config.get("enabled", False)
src/risk_layer/alerting/alert_config.py:189:        enabled=enabled,
src/core/resilience_helpers.py:77:                "circuit_breaker_enabled": True,
src/core/resilience_helpers.py:80:                "rate_limit_enabled": True,
src/core/resilience_helpers.py:101:        module_name: Name of module (e.g., 'backtest', 'portfolio', 'risk', 'live')
src/core/resilience_helpers.py:118:        "circuit_breaker_enabled": global_config.get("circuit_breaker_enabled", True),
src/core/resilience_helpers.py:121:        "rate_limit_enabled": global_config.get("rate_limit_enabled", True),
src/core/resilience_helpers.py:148:    if not module_config.get("circuit_breaker_enabled", True):
src/core/resilience_helpers.py:196:    if not module_config.get("rate_limit_enabled", True):
src/live/drills.py:32:from src.live.risk_limits import LiveRiskConfig, LiveRiskLimits
src/live/drills.py:55:                      (z.B. {"enable_live_trading": False})
src/live/drills.py:56:        risk_config_overrides: Optional Dict mit Overrides fÃ¼r LiveRiskConfig
src/live/drills.py:60:                         (z.B. ["enable_live_trading=False"])
src/live/drills.py:68:    risk_config_overrides: Optional[Dict[str, Any]] = None
src/live/drills.py:141:            "enable_live_trading": base_env_config.enable_live_trading,
src/live/drills.py:146:            "live_mode_armed": base_env_config.live_mode_armed,
src/live/drills.py:166:        notes.append(f"enable_live_trading: {env_config.enable_live_trading}")
src/live/drills.py:167:        notes.append(f"live_mode_armed: {env_config.live_mode_armed}")
src/live/drills.py:176:        if scenario.risk_config_overrides or scenario.simulated_orders:
src/live/drills.py:257:        C: Alles armed, aber Dry-Run aktiv
src/live/drills.py:269:                "Live-Modus, aber enable_live_trading=False. "
src/live/drills.py:271:                "Reason enthÃ¤lt Hinweis auf enable_live_trading."
src/live/drills.py:275:                "enable_live_trading": False,
src/live/drills.py:276:                "live_mode_armed": False,
src/live/drills.py:280:            expected_reasons=["enable_live_trading=False"],
src/live/drills.py:289:                "Live-Modus, enable_live_trading=True, aber live_mode_armed=False. "
src/live/drills.py:291:                "Reason enthÃ¤lt live_mode_armed."
src/live/drills.py:295:                "enable_live_trading": True,
src/live/drills.py:296:                "live_mode_armed": False,
src/live/drills.py:300:            expected_reasons=["live_mode_armed=False"],
src/live/drills.py:304:    # Drill C â€“ Alles armed, aber Dry-Run aktiv
src/live/drills.py:307:            name="C - Alles armed, aber Dry-Run aktiv",
src/live/drills.py:316:                "enable_live_trading": True,
src/live/drills.py:317:                "live_mode_armed": True,
src/live/drills.py:337:                "enable_live_trading": True,
src/live/drills.py:338:                "live_mode_armed": True,
src/live/drills.py:360:                "enable_live_trading": True,
src/live/drills.py:361:                "live_mode_armed": True,
src/live/drills.py:365:            risk_config_overrides={
src/live/drills.py:387:                "enable_live_trading": False,
src/live/drills.py:388:                "live_mode_armed": False,
src/live/drills.py:407:                "enable_live_trading": False,
src/live/drills.py:408:                "live_mode_armed": False,
src/webui/services/__init__.py:15:    get_risk_status,
src/webui/services/__init__.py:24:    "get_risk_status",
src/live/web/api_v0.py:351:                    risk_allowed=(
src/live/web/api_v0.py:352:                        bool(row.get("risk_allowed"))
src/live/web/api_v0.py:353:                        if "risk_allowed" in row and pd.notna(row.get("risk_allowed"))
src/live/web/api_v0.py:356:                    risk_reasons=(
src/live/web/api_v0.py:357:                        str(row.get("risk_reasons"))
src/live/web/api_v0.py:358:                        if "risk_reasons" in row and pd.notna(row.get("risk_reasons"))
src/live/web/api_v0.py:554:            risk_allowed = row.get("risk_allowed")
src/live/web/api_v0.py:557:            if (risk_allowed is False) or (ob is not None and ob > 0):
src/data/shadow/bar_aggregator.py:4:Aggregates live ticks into OHLCV bars, matching backtest normalization.
src/data/shadow/bar_aggregator.py:104:    Aggregates live ticks into OHLCV bars.
src/risk_layer/alerting/__init__.py:15:    from src.risk_layer.alerting import (
src/risk_layer/alerting/__init__.py:28:        source="var_gate",
src/risk_layer/alerting/__init__.py:34:from src.risk_layer.alerting.alert_config import AlertConfig, load_alert_config
src/risk_layer/alerting/__init__.py:35:from src.risk_layer.alerting.alert_dispatcher import AlertDispatcher
src/risk_layer/alerting/__init__.py:36:from src.risk_layer.alerting.alert_event import AlertEvent
src/risk_layer/alerting/__init__.py:37:from src.risk_layer.alerting.alert_manager import AlertManager
src/risk_layer/alerting/__init__.py:38:from src.risk_layer.alerting.alert_types import AlertCategory, AlertSeverity
src/live/alerts.py:22:    config = LiveAlertsConfig.from_dict({"enabled": True, "min_level": "warning"})
src/live/alerts.py:28:        source="live_risk.orders",
src/live/alerts.py:66:        source: Quelle des Alerts (z.B. "live_risk.orders", "live_risk.portfolio")
src/live/alerts.py:379:        enabled: Ob Alerts aktiviert sind
src/live/alerts.py:388:    enabled: bool = True
src/live/alerts.py:409:        enabled = bool(raw.get("enabled", True))
src/live/alerts.py:443:            enabled=enabled,
src/live/alerts.py:463:    if not cfg.enabled:
src/risk_layer/alerting/channels/channel_router.py:12:from src.risk_layer.alerting.alert_event import AlertEvent
src/risk_layer/alerting/channels/channel_router.py:13:from src.risk_layer.alerting.channels.base_channel import AlertChannel
src/risk_layer/alerting/channels/channel_router.py:81:    def get_enabled_channels(self) -> List[AlertChannel]:
src/risk_layer/alerting/channels/channel_router.py:83:        Get all enabled channels.
src/risk_layer/alerting/channels/channel_router.py:86:            List of enabled AlertChannel instances
src/risk_layer/alerting/channels/channel_router.py:88:        return [ch for ch in self._channels.values() if ch.is_enabled()]
src/risk_layer/alerting/channels/channel_router.py:95:        1. Are enabled
src/risk_layer/alerting/channels/channel_router.py:156:            if fallback_channel and fallback_channel.is_enabled():
src/risk_layer/alerting/channels/channel_router.py:201:            "channels_enabled": len(self.get_enabled_channels()),
src/core/config_simple.py:10:    print(cfg['risk']['risk_per_trade'])
src/live/web/app.py:71:        enabled: Web-UI aktiviert
src/live/web/app.py:78:    enabled: bool = True
src/live/web/app.py:96:        enabled=cfg.get("web_ui.enabled", True),
src/live/web/app.py:324:        .risk-ok {{
src/live/web/app.py:327:        .risk-blocked {{
src/live/web/app.py:525:                                    <td class="${{row.risk_allowed ? 'risk-ok' : 'risk-blocked'}}">
src/live/web/app.py:526:                                        ${{row.risk_allowed ? 'OK' : 'BLOCKED'}}
src/live/web/app.py:764:                        risk_allowed=event.get("risk_allowed", True),
src/live/web/app.py:765:                        risk_reasons=event.get("risk_reasons", "") or "",
src/live/web/app.py:1154:                f"<td>{'BLOCKED' if it.risk_allowed is False else ('OK' if it.risk_allowed is True else 'â€”')}</td>"
src/live/web/app.py:1220:          <thead><tr><th>ts</th><th>step</th><th>gen</th><th>fill</th><th>rej</th><th>blk</th><th>risk</th></tr></thead>
src/live/web/app.py:1390:              const risk = (it.risk_allowed === false) ? "BLOCKED" : (it.risk_allowed === true ? "OK" : "â€”");
src/live/web/app.py:1398:                <td>${{risk}}</td>
src/strategies/composite.py:319:    def _aggregate_signals_weighted(self, signal_matrix: pd.DataFrame) -> pd.Series:
src/strategies/composite.py:335:    def _aggregate_signals_voting(self, signal_matrix: pd.DataFrame) -> pd.Series:
src/strategies/composite.py:357:    def _aggregate_signals_unanimous(self, signal_matrix: pd.DataFrame) -> pd.Series:
src/strategies/composite.py:377:    def _aggregate_signals_any(self, signal_matrix: pd.DataFrame, direction: str) -> pd.Series:
src/strategies/composite.py:449:            aggregated = self._aggregate_signals_weighted(signal_matrix)
src/strategies/composite.py:453:            final_signals = final_signals.where(~(aggregated > self.signal_threshold), 1)
src/strategies/composite.py:454:            final_signals = final_signals.where(~(aggregated < -self.signal_threshold), -1)
src/strategies/composite.py:457:            final_signals = self._aggregate_signals_voting(signal_matrix)
src/strategies/composite.py:460:            final_signals = self._aggregate_signals_unanimous(signal_matrix)
src/strategies/composite.py:463:            final_signals = self._aggregate_signals_any(signal_matrix, "long")
src/strategies/composite.py:466:            final_signals = self._aggregate_signals_any(signal_matrix, "short")
src/data/feeds/live_feed.py:47:        reconnect_enabled: Enable automatic reconnection
src/data/feeds/live_feed.py:50:        backfill_enabled: Enable backfill on reconnect
src/data/feeds/live_feed.py:56:    reconnect_enabled: bool = True
src/data/feeds/live_feed.py:59:    backfill_enabled: bool = True
src/data/feeds/live_feed.py:173:        if self.config.reconnect_enabled:
src/data/feeds/live_feed.py:178:        if not self.config.reconnect_enabled:
src/data/feeds/live_feed.py:208:            if self.config.backfill_enabled:
src/data/feeds/live_feed.py:216:        if not self.config.backfill_enabled:
src/webui/services/live_panel_data.py:328:        # Aggregate positions from active sessions
src/webui/services/live_panel_data.py:435:        # Aggregate from active sessions
src/webui/services/live_panel_data.py:491:def get_risk_status() -> Dict[str, Any]:
src/webui/services/live_panel_data.py:493:    Get current risk status and limits.
src/webui/services/live_panel_data.py:497:        - status: Overall risk status (ok/warning/breach)
src/webui/services/live_panel_data.py:499:        - limits_enabled: Whether risk limits are active
src/webui/services/live_panel_data.py:504:        >>> status = get_risk_status()
src/webui/services/live_panel_data.py:511:        return _risk_status_fallback()
src/webui/services/live_panel_data.py:514:        return _risk_status_fallback()
src/webui/services/live_panel_data.py:525:                "limits_enabled": False,
src/webui/services/live_panel_data.py:531:        # Aggregate risk status from active sessions
src/webui/services/live_panel_data.py:535:        limits_enabled = False
src/webui/services/live_panel_data.py:542:            # Extract risk status from metrics
src/webui/services/live_panel_data.py:543:            risk_check = metrics.get("risk_check", {})
src/webui/services/live_panel_data.py:544:            if isinstance(risk_check, dict):
src/webui/services/live_panel_data.py:545:                severity = risk_check.get("severity", "ok")
src/webui/services/live_panel_data.py:550:                limit_details = risk_check.get("limit_details", [])
src/webui/services/live_panel_data.py:555:                if not risk_check.get("allowed", True):
src/webui/services/live_panel_data.py:556:                    reasons = risk_check.get("reasons", [])
src/webui/services/live_panel_data.py:559:                limits_enabled = True
src/webui/services/live_panel_data.py:561:            # Also check top-level risk fields
src/webui/services/live_panel_data.py:562:            if "risk_severity" in metrics:
src/webui/services/live_panel_data.py:563:                severity = metrics["risk_severity"]
src/webui/services/live_panel_data.py:574:            "limits_enabled": limits_enabled,
src/webui/services/live_panel_data.py:580:        logger.warning("Error extracting risk status fields: %s", e)
src/webui/services/live_panel_data.py:581:        return _risk_status_fallback()
src/webui/services/live_panel_data.py:583:        logger.warning("Unexpected error getting risk status: %s", e, exc_info=True)
src/webui/services/live_panel_data.py:584:        return _risk_status_fallback()
src/webui/services/live_panel_data.py:587:def _risk_status_fallback() -> Dict[str, Any]:
src/webui/services/live_panel_data.py:588:    """Fallback when risk status is not available."""
src/webui/services/live_panel_data.py:592:        "limits_enabled": False,
src/webui/services/live_panel_data.py:610:    "get_risk_status",
src/reporting/psychology_heuristics.py:18:3. Events nach Cluster aggregieren (aggregate_cluster_scores)
src/reporting/psychology_heuristics.py:142:    risk_violation: bool  # Stop/Risk-Regel verletzt
src/reporting/psychology_heuristics.py:212:        ...     risk_violation=False, recent_loss_streak=0,
src/reporting/psychology_heuristics.py:280:        ...     risk_violation=False, recent_loss_streak=3,
src/reporting/psychology_heuristics.py:348:        ...     risk_violation=False, recent_loss_streak=0,
src/reporting/psychology_heuristics.py:407:        ...     risk_violation=False, recent_loss_streak=0,
src/reporting/psychology_heuristics.py:468:        ...     risk_violation=True, recent_loss_streak=0,
src/reporting/psychology_heuristics.py:484:    if ev.risk_violation:
src/reporting/psychology_heuristics.py:503:def aggregate_cluster_scores(
src/reporting/psychology_heuristics.py:532:        ...         risk_violation=False, recent_loss_streak=0,
src/reporting/psychology_heuristics.py:537:        >>> scores = aggregate_cluster_scores(events)
src/reporting/psychology_heuristics.py:562:        def aggregate_scores(scores: List[int]) -> int:
src/reporting/psychology_heuristics.py:583:            fomo=aggregate_scores(fomo_scores),
src/reporting/psychology_heuristics.py:584:            loss_fear=aggregate_scores(loss_fear_scores),
src/reporting/psychology_heuristics.py:585:            impulsivity=aggregate_scores(impulsivity_scores),
src/reporting/psychology_heuristics.py:586:            hesitation=aggregate_scores(hesitation_scores),
src/reporting/psychology_heuristics.py:587:            rule_break=aggregate_scores(rule_break_scores),
src/reporting/psychology_heuristics.py:653:    1. Events â†’ Cluster-Scores (aggregate_cluster_scores)
src/reporting/psychology_heuristics.py:671:    clusters = aggregate_cluster_scores(events)
src/reporting/psychology_heuristics.py:713:        risk_violation=False,
src/reporting/psychology_heuristics.py:747:        risk_violation=False,
src/reporting/psychology_heuristics.py:780:        risk_violation=False,
src/reporting/psychology_heuristics.py:813:        risk_violation=False,
src/reporting/psychology_heuristics.py:846:        risk_violation=True,  # Risk verletzt
src/reporting/psychology_heuristics.py:884:            risk_violation=False,
src/reporting/psychology_heuristics.py:906:            risk_violation=False,
src/risk_layer/alerting/channels/__init__.py:13:    from src.risk_layer.alerting.channels import (
src/risk_layer/alerting/channels/__init__.py:24:from src.risk_layer.alerting.channels.base_channel import (
src/risk_layer/alerting/channels/__init__.py:29:from src.risk_layer.alerting.channels.channel_router import ChannelRouter
src/risk_layer/alerting/channels/__init__.py:30:from src.risk_layer.alerting.channels.console_channel import ConsoleChannel
src/risk_layer/alerting/channels/__init__.py:31:from src.risk_layer.alerting.channels.email_channel import EmailChannel
src/risk_layer/alerting/channels/__init__.py:32:from src.risk_layer.alerting.channels.file_channel import FileChannel
src/risk_layer/alerting/channels/__init__.py:33:from src.risk_layer.alerting.channels.slack_channel import SlackChannel
src/risk_layer/alerting/channels/__init__.py:34:from src.risk_layer.alerting.channels.telegram_channel import TelegramChannel
src/risk_layer/alerting/channels/__init__.py:35:from src.risk_layer.alerting.channels.webhook_channel import WebhookChannel
src/live/web/models_v0.py:54:    risk_allowed: bool = True
src/live/web/models_v0.py:55:    risk_reasons: str = ""
src/live/web/models_v0.py:144:    """v0.1B: order counters + risk summary per event (best effort, read-only)."""
src/live/web/models_v0.py:152:    risk_allowed: Optional[bool] = None
src/live/web/models_v0.py:153:    risk_reasons: Optional[str] = None
src/live/ops/alerts.py:78:        "RISK_LIMIT_BREACH": "docs/ops/runbooks/risk_limit_breach.md",
src/execution/telemetry_retention.py:64:    enabled: bool = True
src/execution/telemetry_retention.py:196:    # Find .jsonl.gz files (if enabled)
src/execution/telemetry_retention.py:236:    if not policy.enabled:
src/execution/telemetry_retention.py:311:    # Phase 3: Compression (if enabled)
src/risk_layer/alerting/alert_manager.py:11:from src.risk_layer.alerting.alert_config import AlertConfig
src/risk_layer/alerting/alert_manager.py:12:from src.risk_layer.alerting.alert_dispatcher import AlertDispatcher
src/risk_layer/alerting/alert_manager.py:13:from src.risk_layer.alerting.alert_event import AlertEvent
src/risk_layer/alerting/alert_manager.py:14:from src.risk_layer.alerting.alert_types import AlertCategory, AlertSeverity
src/risk_layer/alerting/alert_manager.py:58:        and dispatches if alerting is enabled.
src/risk_layer/alerting/alert_manager.py:88:        # Dispatch if enabled
src/risk_layer/alerting/alert_manager.py:89:        if self.config.enabled:
src/risk_layer/alerting/alert_manager.py:176:            "alerting_enabled": self.config.enabled,
src/reporting/execution_reports.py:296:    # Aggregates
src/data/feeds/offline_realtime_feed.py:334:        safety_gate: Optional[DataSafetyGate] = None,
src/data/feeds/offline_realtime_feed.py:342:            safety_gate: Optionaler DataSafetyGate (default: Standardinstanz).
src/live/workflows.py:21:from src.core.experiments import log_live_risk_check, RUN_TYPE_LIVE_RISK_CHECK
src/live/workflows.py:24:from src.live.risk_limits import LiveRiskLimits, LiveRiskCheckResult
src/live/workflows.py:29:    """Exception bei erzwungenem Risk-Check-Fehler (--enforce-live-risk)."""
src/live/workflows.py:66:def validate_risk_flags(enforce: bool, skip: bool) -> None:
src/live/workflows.py:68:    Validiert, dass --enforce-live-risk und --skip-live-risk
src/live/workflows.py:72:        enforce: Wert von --enforce-live-risk
src/live/workflows.py:73:        skip: Wert von --skip-live-risk
src/live/workflows.py:80:            "Konflikt: --enforce-live-risk und --skip-live-risk kÃ¶nnen nicht "
src/live/workflows.py:85:def run_live_risk_check(
src/live/workflows.py:113:    validate_risk_flags(ctx.enforce, ctx.skip)
src/live/workflows.py:117:        print("\nâš ï¸  Live-Risk-Check Ã¼bersprungen (--skip-live-risk)")
src/live/workflows.py:138:    _print_risk_check_summary(result)
src/live/workflows.py:149:        log_live_risk_check(
src/live/workflows.py:161:        _send_risk_alert(result, ctx.notifier, ctx.tag)
src/live/workflows.py:165:        print("\nâŒ ABBRUCH: Live-Risk-Limits verletzt und --enforce-live-risk gesetzt.")
src/live/workflows.py:174:def _print_risk_check_summary(result: LiveRiskCheckResult) -> None:
src/live/workflows.py:177:    enabled = result.metrics.get("live_risk_enabled", True)
src/live/workflows.py:181:    if not enabled:
src/live/workflows.py:205:def exit_on_risk_violation(result: Optional[LiveRiskCheckResult], enforce: bool) -> bool:
src/live/workflows.py:211:        enforce: Wert von --enforce-live-risk
src/live/workflows.py:229:    print("\nâš ï¸  Warnung: Live-Risk-Limits verletzt, aber --enforce-live-risk nicht gesetzt.")
src/live/workflows.py:234:def _send_risk_alert(
src/live/workflows.py:262:        source="live_risk",
src/live/web/metrics_prom.py:36:def _enabled() -> bool:
src/live/web/metrics_prom.py:106:    if not _enabled():
src/live/web/metrics_prom.py:172:    Registers /metrics endpoint only when prometheus is available AND enabled.
src/live/web/metrics_prom.py:174:    if not is_prometheus_available() or not _enabled():
src/data/providers/ccxt_exchange_client.py:34:        enable_rate_limit: bool = True,
src/data/providers/ccxt_exchange_client.py:46:        config: Dict[str, Any] = {"enableRateLimit": enable_rate_limit}
src/risk_layer/alerting/channels/console_channel.py:12:from src.risk_layer.alerting.alert_event import AlertEvent
src/risk_layer/alerting/channels/console_channel.py:13:from src.risk_layer.alerting.alert_types import AlertSeverity
src/risk_layer/alerting/channels/console_channel.py:14:from src.risk_layer.alerting.channels.base_channel import (
src/risk_layer/alerting/channels/console_channel.py:111:            ChannelHealth (always healthy if enabled)
src/risk_layer/alerting/channels/console_channel.py:115:        if not self._enabled:
src/risk_layer/alerting/channels/console_channel.py:119:            # Console is always healthy if enabled
src/reporting/live_session_report.py:136:    overview_data = _aggregate_records(records)
src/reporting/live_session_report.py:228:        "orders_blocked_risk": "Orders Blocked (Risk)",
src/reporting/live_session_report.py:283:        "enable_risk_limits": "Risk Limits Enabled",
src/reporting/live_session_report.py:375:def _aggregate_records(records: List["LiveSessionRecord"]) -> Dict[str, Any]:
src/reporting/live_session_report.py:383:    total_blocked = sum(r.metrics.get("orders_blocked_risk", 0) for r in records)
src/core/position_sizing.py:390:    enable_dd_throttle: bool = False
src/core/position_sizing.py:454:        """Concrete implementation to satisfy ABC; delegates to base_sizer."""
src/core/position_sizing.py:506:    enable_dd_throttle: bool = False
src/core/position_sizing.py:547:        if not self.config.enable_dd_throttle:
src/core/position_sizing.py:644:        """Delegate to base_sizer, apply overlay, vol-targeting, and DD-throttle."""
src/core/position_sizing.py:793:                    # Check R&D gates for this overlay
src/core/position_sizing.py:809:    # R&D gates for vol_regime_overlay type (must come BEFORE generic Unknown-Type raise)
src/data/providers/kraken_ccxt_backend.py:40:    enable_rate_limit: bool = True
src/data/providers/kraken_ccxt_backend.py:61:            "enableRateLimit": bool(self.enable_rate_limit),
src/reporting/plots.py:779:        if "Risk-On" in label or "risk_on" in label.lower():
src/reporting/plots.py:781:        elif "Risk-Off" in label or "risk_off" in label.lower():
src/live/live_gates.py:1:# src/live/live_gates.py
src/live/live_gates.py:15:    from src.live.live_gates import (
src/webui/app.py:62:- POST /api/knowledge/snippets (Dokument hinzufÃ¼gen - gated)
src/webui/app.py:64:- POST /api/knowledge/strategies (Strategie hinzufÃ¼gen - gated)
src/webui/app.py:204:        risk_profile = "experimental" # Risikoprofil
src/webui/app.py:256:        risk_profile = meta.get("risk_profile", "")
src/webui/app.py:293:            row_data["risk_profile"] = risk_profile
src/webui/app.py:1053:            None, description="Filter nach Event-Kind (intent/order/fill/gate)"
src/webui/app.py:1111:        - Filter nach Kind (intent/order/fill/gate)
src/webui/app.py:1522:            "enabled": True,
src/reporting/live_status_report.py:92:    alerts_enabled = data.health.get("alerts_enabled", False)
src/reporting/live_status_report.py:93:    alerts_status = "OK" if alerts_enabled else "WARN"
src/reporting/live_status_report.py:103:    live_risk_ok = data.health.get("live_risk_ok", False)
src/reporting/live_status_report.py:104:    live_risk_status = "OK" if live_risk_ok else "WARN"
src/reporting/live_status_report.py:105:    live_risk_details = "Limits geladen, keine Errors"
src/reporting/live_status_report.py:106:    if data.health.get("live_risk_warnings"):
src/reporting/live_status_report.py:107:        live_risk_details = ", ".join(data.health["live_risk_warnings"])
src/reporting/live_status_report.py:108:    lines.append(f"| live_risk | {live_risk_status} | {live_risk_details} |")
src/reporting/live_status_report.py:125:    # 2.1 Aggregate
src/reporting/live_status_report.py:126:    lines.append("### 2.1 Aggregate")
src/reporting/live_status_report.py:174:    risk = portfolio.get("risk")
src/reporting/live_status_report.py:175:    if risk:
src/reporting/live_status_report.py:176:        allowed = risk.get("allowed", True)
src/reporting/live_status_report.py:177:        reasons = risk.get("reasons", [])
src/reporting/live_status_report.py:189:    lines.append(f"- Letzter Risk-Check: Health-Check {'OK' if live_risk_ok else 'WARN'}")
src/reporting/live_status_report.py:302:    alerts_enabled = data.health.get("alerts_enabled", False)
src/reporting/live_status_report.py:303:    alerts_status = "OK" if alerts_enabled else "WARN"
src/reporting/live_status_report.py:313:    live_risk_ok = data.health.get("live_risk_ok", False)
src/reporting/live_status_report.py:314:    live_risk_status = "OK" if live_risk_ok else "WARN"
src/reporting/live_status_report.py:315:    live_risk_details = "Limits geladen, keine Errors"
src/reporting/live_status_report.py:316:    if data.health.get("live_risk_warnings"):
src/reporting/live_status_report.py:317:        live_risk_details = ", ".join(data.health["live_risk_warnings"])
src/reporting/live_status_report.py:319:        f"      <tr><td>live_risk</td><td>{live_risk_status}</td><td>{live_risk_details}</td></tr>"
src/reporting/live_status_report.py:335:    # 2.1 Aggregate
src/reporting/live_status_report.py:336:    lines.append("  <h3>2.1 Aggregate</h3>")
src/reporting/live_status_report.py:387:    risk = portfolio.get("risk")
src/reporting/live_status_report.py:388:    if risk:
src/reporting/live_status_report.py:389:        allowed = risk.get("allowed", True)
src/reporting/live_status_report.py:390:        reasons = risk.get("reasons", [])
src/reporting/live_status_report.py:407:        f"    <li><strong>Letzter Risk-Check:</strong> Health-Check {'OK' if live_risk_ok else 'WARN'}</li>"
src/execution/replay_pack/compare.py:36:CheckMode = Literal["enabled", "disabled"]
src/execution/replay_pack/compare.py:412:            "check_outputs": "enabled" if check_outputs else "disabled",
src/strategies/regime_aware_portfolio.py:23:    ...     risk_on_scale=1.0,
src/strategies/regime_aware_portfolio.py:25:    ...     risk_off_scale=0.0
src/strategies/regime_aware_portfolio.py:60:        risk_on_scale: Skalierungsfaktor fÃ¼r Risk-On-Regime (default: 1.0)
src/strategies/regime_aware_portfolio.py:62:        risk_off_scale: Skalierungsfaktor fÃ¼r Risk-Off-Regime (default: 0.0)
src/strategies/regime_aware_portfolio.py:72:        ...     risk_on_scale=1.0,
src/strategies/regime_aware_portfolio.py:74:        ...     risk_off_scale=0.0
src/strategies/regime_aware_portfolio.py:86:        risk_on_scale: float = 1.0,
src/strategies/regime_aware_portfolio.py:88:        risk_off_scale: float = 0.0,
src/strategies/regime_aware_portfolio.py:101:            risk_on_scale: Skalierungsfaktor Risk-On
src/strategies/regime_aware_portfolio.py:103:            risk_off_scale: Skalierungsfaktor Risk-Off
src/strategies/regime_aware_portfolio.py:113:            "risk_on_scale": risk_on_scale,
src/strategies/regime_aware_portfolio.py:115:            "risk_off_scale": risk_off_scale,
src/strategies/regime_aware_portfolio.py:137:        self.risk_on_scale = float(self.config.get("risk_on_scale", 1.0))
src/strategies/regime_aware_portfolio.py:139:        self.risk_off_scale = float(self.config.get("risk_off_scale", 0.0))
src/strategies/regime_aware_portfolio.py:201:        risk_on_scale = cfg.get(f"{section}.risk_on_scale", 1.0)
src/strategies/regime_aware_portfolio.py:203:        risk_off_scale = cfg.get(f"{section}.risk_off_scale", 0.0)
src/strategies/regime_aware_portfolio.py:211:            risk_on_scale=risk_on_scale,
src/strategies/regime_aware_portfolio.py:213:            risk_off_scale=risk_off_scale,
src/strategies/regime_aware_portfolio.py:270:            return self.risk_on_scale
src/strategies/regime_aware_portfolio.py:274:            return self.risk_off_scale
src/strategies/regime_aware_portfolio.py:436:        "risk_on_scale": params.get("risk_on_scale", 1.0),
src/strategies/regime_aware_portfolio.py:438:        "risk_off_scale": params.get("risk_off_scale", 0.0),
src/core/config_pydantic.py:10:    print(cfg.risk.risk_per_trade)
src/core/config_pydantic.py:54:    risk_per_trade: float = Field(
src/core/config_pydantic.py:80:    enabled: bool = Field(default=False)
src/core/config_pydantic.py:154:    risk: RiskConfig
src/core/config_pydantic.py:166:            key: Attributname (z.B. "backtest", "risk")
src/core/config_pydantic.py:297:    risk = settings.risk
src/core/config_pydantic.py:300:    if risk.risk_per_trade > 0.02:
src/core/config_pydantic.py:304:        logging.warning(f"âš ï¸  risk_per_trade={risk.risk_per_trade:.1%} ist hoch! Empfohlen: <= 2%")
src/core/config_pydantic.py:306:    if risk.max_position_size > 0.5:
src/core/config_pydantic.py:310:            f"âš ï¸  max_position_size={risk.max_position_size:.0%} ist hoch! Empfohlen: <= 50%"
src/core/config_pydantic.py:324:    if settings.live.enabled and settings.live.mode == "live":
src/core/config_pydantic.py:328:            "Setze live.enabled=false oder live.mode='paper'"
src/core/config_pydantic.py:348:        >>> print(cfg.risk.risk_per_trade)
src/risk_layer/alerting/channels/file_channel.py:14:from src.risk_layer.alerting.alert_event import AlertEvent
src/risk_layer/alerting/channels/file_channel.py:15:from src.risk_layer.alerting.alert_types import AlertSeverity
src/risk_layer/alerting/channels/file_channel.py:16:from src.risk_layer.alerting.channels.base_channel import (
src/risk_layer/alerting/channels/file_channel.py:57:        if self._enabled:
src/risk_layer/alerting/channels/file_channel.py:63:                self._enabled = False
src/risk_layer/alerting/channels/file_channel.py:117:        if not self._enabled:
src/data/kraken.py:37:    backend = KrakenCcxtBackend(enable_rate_limit=True, timeout_ms=30000)
src/data/kraken.py:109:        backend = KrakenCcxtBackend(enable_rate_limit=True, timeout_ms=30000)
src/strategies/breakout.py:56:        risk_mode: Trading-Modus ("symmetric", "long_only", "short_only") (default: "symmetric")
src/strategies/breakout.py:75:        ...     risk_mode="symmetric"
src/strategies/breakout.py:90:        risk_mode: str = "symmetric",
src/strategies/breakout.py:110:            risk_mode: "symmetric", "long_only", "short_only"
src/strategies/breakout.py:127:            "risk_mode": risk_mode,
src/strategies/breakout.py:156:        self.risk_mode = str(self.config.get("risk_mode", "symmetric")).lower()
src/strategies/breakout.py:162:        # Legacy: side -> risk_mode Mapping
src/strategies/breakout.py:164:        if legacy_side and self.risk_mode == "symmetric":
src/strategies/breakout.py:167:                self.risk_mode = "long_only"
src/strategies/breakout.py:169:                self.risk_mode = "short_only"
src/strategies/breakout.py:171:                self.risk_mode = "symmetric"
src/strategies/breakout.py:205:        if self.risk_mode not in ("symmetric", "long_only", "short_only"):
src/strategies/breakout.py:207:                f"risk_mode ({self.risk_mode}) muss 'symmetric', 'long_only' oder 'short_only' sein"
src/strategies/breakout.py:245:        risk_mode = cfg.get(f"{section}.risk_mode", None)
src/strategies/breakout.py:252:        # Legacy: side -> risk_mode
src/strategies/breakout.py:253:        if risk_mode is None:
src/strategies/breakout.py:255:                risk_mode = "long_only"
src/strategies/breakout.py:257:                risk_mode = "short_only"
src/strategies/breakout.py:259:                risk_mode = "symmetric"
src/strategies/breakout.py:261:                risk_mode = "symmetric"
src/strategies/breakout.py:271:            risk_mode=risk_mode,
src/strategies/breakout.py:464:                    if self.risk_mode in ("symmetric", "short_only") and current_close < lower:
src/strategies/breakout.py:467:                        if self.risk_mode == "symmetric":
src/strategies/breakout.py:504:                    if self.risk_mode in ("symmetric", "long_only") and current_close > upper:
src/strategies/breakout.py:507:                        if self.risk_mode == "symmetric":
src/strategies/breakout.py:522:                if self.risk_mode in ("symmetric", "long_only") and current_close > upper:
src/strategies/breakout.py:529:                elif self.risk_mode in ("symmetric", "short_only") and current_close < lower:
src/live/status_providers.py:52:        "risk": _panel_risk,  # optional
src/live/status_providers.py:244:    - Aggregates PnL, equity, exposure from active sessions
src/live/status_providers.py:279:def _panel_risk(*args: Any, **kwargs: Any) -> Any:
src/live/status_providers.py:281:    Provide risk limits / risk gate status from active sessions.
src/live/status_providers.py:285:    - Aggregates risk status from active session metrics
src/live/status_providers.py:288:        from src.webui.services.live_panel_data import get_risk_status
src/live/status_providers.py:290:        risk_status = get_risk_status()
src/live/status_providers.py:292:        # Determine panel status from risk status
src/live/status_providers.py:293:        is_fallback = risk_status.get("_fallback", False)
src/live/status_providers.py:297:            # Map risk status to panel status
src/live/status_providers.py:298:            risk_state = risk_status.get("status", "ok")
src/live/status_providers.py:305:            status = status_map.get(risk_state, "unknown")
src/live/status_providers.py:308:            "id": "risk",
src/live/status_providers.py:311:            "details": risk_status,
src/live/status_providers.py:320:        "id": "risk",
src/strategies/diagnostics.py:467:        from src.core.risk import build_risk_manager_from_config
src/strategies/diagnostics.py:496:        risk_manager = build_risk_manager_from_config(cfg, section="risk_management")
src/strategies/diagnostics.py:501:            risk_manager=risk_manager,
src/live/risk_alert_helpers.py:1:# src/live/risk_alert_helpers.py
src/live/risk_alert_helpers.py:12:4. Runbook-Handlungsempfehlungen basierend auf risk_status
src/live/risk_alert_helpers.py:15:    from src.live.risk_alert_helpers import (
src/live/risk_alert_helpers.py:16:        format_risk_alert_message,
src/live/risk_alert_helpers.py:17:        trigger_risk_alert,
src/live/risk_alert_helpers.py:25:        message = format_risk_alert_message(result)
src/live/risk_alert_helpers.py:26:        trigger_risk_alert(result, alert_sink)
src/live/risk_alert_helpers.py:29:    guidance = get_operator_guidance(result.risk_status)
src/live/risk_alert_helpers.py:41:    from src.live.risk_limits import (
src/live/risk_alert_helpers.py:59:    Handlungsempfehlung fÃ¼r Operator basierend auf risk_status.
src/live/risk_alert_helpers.py:62:        risk_status: Der aktuelle Risk-Status (green/yellow/red)
src/live/risk_alert_helpers.py:71:    risk_status: str
src/live/risk_alert_helpers.py:82:    risk_status="green",
src/live/risk_alert_helpers.py:96:    risk_status="yellow",
src/live/risk_alert_helpers.py:112:    risk_status="red",
src/live/risk_alert_helpers.py:136:def get_operator_guidance(risk_status: str) -> OperatorGuidance:
src/live/risk_alert_helpers.py:138:    Gibt Operator-Handlungsempfehlungen fÃ¼r einen risk_status zurÃ¼ck.
src/live/risk_alert_helpers.py:141:        risk_status: "green", "yellow" oder "red"
src/live/risk_alert_helpers.py:153:    return _GUIDANCE_MAP.get(risk_status, _GUIDANCE_GREEN)
src/live/risk_alert_helpers.py:161:        result: LiveRiskCheckResult mit risk_status
src/live/risk_alert_helpers.py:166:    return get_operator_guidance(result.risk_status)
src/live/risk_alert_helpers.py:197:def format_risk_alert_message(
src/live/risk_alert_helpers.py:200:    source: str = "live_risk",
src/live/risk_alert_helpers.py:209:        source: Alert-Quelle (z.B. "live_risk.orders", "live_risk.portfolio")
src/live/risk_alert_helpers.py:218:        >>> msg = format_risk_alert_message(result)
src/live/risk_alert_helpers.py:224:    guidance = get_operator_guidance(result.risk_status)
src/live/risk_alert_helpers.py:261:def format_slack_risk_alert(
src/live/risk_alert_helpers.py:264:    source: str = "live_risk",
src/live/risk_alert_helpers.py:280:    guidance = get_operator_guidance(result.risk_status)
src/live/risk_alert_helpers.py:296:    lines.append(f"Status: `{result.risk_status}`")
src/live/risk_alert_helpers.py:327:def trigger_risk_alert(
src/live/risk_alert_helpers.py:331:    source: str = "live_risk",
src/live/risk_alert_helpers.py:343:        source: Alert-Quelle (z.B. "live_risk.orders")
src/live/risk_alert_helpers.py:352:        >>> triggered = trigger_risk_alert(result, alert_sink, session_id="sess_123")
src/live/risk_alert_helpers.py:375:    message = format_risk_alert_message(result, source=source, include_details=True)
src/live/risk_alert_helpers.py:379:        "risk_status": result.risk_status,
src/live/risk_alert_helpers.py:422:        logger.warning(f"Failed to send risk alert: {e}")
src/live/risk_alert_helpers.py:481:        guidance = get_operator_guidance(result.risk_status)
src/live/risk_alert_helpers.py:484:        if result.risk_status == "red":
src/live/risk_alert_helpers.py:487:        elif result.risk_status == "yellow":
src/live/risk_alert_helpers.py:501:        status_text = self._color(result.risk_status.upper(), status_color)
src/live/risk_alert_helpers.py:528:        if result.risk_status != "green":
src/live/risk_alert_helpers.py:548:        guidance = get_operator_guidance(result.risk_status)
src/live/risk_alert_helpers.py:573:def trigger_risk_pipeline_alert(
src/live/risk_alert_helpers.py:577:    source: str = "live_risk",
src/live/risk_alert_helpers.py:590:        source: Alert-Quelle (z.B. "live_risk.orders", "live_risk.limits")
src/live/risk_alert_helpers.py:601:        >>> triggered = trigger_risk_pipeline_alert(result, manager, session_id="sess_123")
src/live/risk_alert_helpers.py:625:        guidance = get_operator_guidance(result.risk_status)
src/live/risk_alert_helpers.py:658:            "risk_status": result.risk_status,
src/live/risk_alert_helpers.py:703:        logger.warning(f"Failed to send risk pipeline alert: {e}")
src/live/risk_alert_helpers.py:773:            source="live_risk_limits",
src/live/risk_alert_helpers.py:794:    "format_risk_alert_message",
src/live/risk_alert_helpers.py:795:    "format_slack_risk_alert",
src/live/risk_alert_helpers.py:798:    "trigger_risk_alert",
src/live/risk_alert_helpers.py:800:    "trigger_risk_pipeline_alert",
src/execution/pipeline.py:55:    from ..live.risk_limits import LiveRiskLimits, LiveRiskCheckResult
src/execution/pipeline.py:70:    from ..obs import strategy_risk_telemetry as _strategy_risk_telemetry
src/execution/pipeline.py:72:    _strategy_risk_telemetry = None  # type: ignore
src/execution/pipeline.py:314:    BLOCKED_BY_RISK = "blocked_by_risk"
src/execution/pipeline.py:335:        risk_check: Ergebnis des Risk-Checks (falls durchgefuehrt)
src/execution/pipeline.py:345:    risk_check: Optional["LiveRiskCheckResult"] = None
src/execution/pipeline.py:366:    def is_blocked_by_risk(self) -> bool:
src/execution/pipeline.py:502:        risk_limits: Optional["LiveRiskLimits"] = None,
src/execution/pipeline.py:515:            risk_limits: Optional LiveRiskLimits fuer Risk-Checks (Phase 16A)
src/execution/pipeline.py:527:        self._risk_limits = risk_limits
src/execution/pipeline.py:559:            kind: Event kind (gate/intent/order/fill/error)
src/execution/pipeline.py:758:        if _strategy_risk_telemetry is not None:
src/execution/pipeline.py:761:                _strategy_risk_telemetry.inc_strategy_signal(  # type: ignore[union-attr]
src/execution/pipeline.py:878:        if orders and _strategy_risk_telemetry is not None:
src/execution/pipeline.py:883:                    _strategy_risk_telemetry.inc_strategy_decision(  # type: ignore[union-attr]
src/execution/pipeline.py:1226:            if "risk_limits" in (result.reason or ""):
src/execution/pipeline.py:1445:        risk_result: Optional["LiveRiskCheckResult"] = None
src/execution/pipeline.py:1446:        if self._risk_limits is not None:
src/execution/pipeline.py:1449:            risk_result = self._risk_limits.check_orders(live_orders)
src/execution/pipeline.py:1451:            if not risk_result.allowed:
src/execution/pipeline.py:1452:                reason = f"risk_limits_violated: {', '.join(risk_result.reasons)}"
src/execution/pipeline.py:1456:                    self._log_rejected_execution(orders_list, reason, risk_result)
src/execution/pipeline.py:1476:                    risk_check=risk_result,
src/execution/pipeline.py:1489:            self._log_execution_results(execution_results, risk_result)
src/execution/pipeline.py:1491:        # Telemetry: approved after all gates (before executor results interpretation)
src/execution/pipeline.py:1510:            risk_check=risk_result,
src/execution/pipeline.py:1562:        risk_result: Optional["LiveRiskCheckResult"],
src/execution/pipeline.py:1569:            risk_result: Optionales Risk-Check-Ergebnis
src/execution/pipeline.py:1589:                    risk_allowed=risk_result.allowed if risk_result else True,
src/execution/pipeline.py:1590:                    risk_reasons=(
src/execution/pipeline.py:1591:                        "; ".join(risk_result.reasons)
src/execution/pipeline.py:1592:                        if risk_result and risk_result.reasons
src/execution/pipeline.py:1619:        risk_result: Optional["LiveRiskCheckResult"],
src/execution/pipeline.py:1627:            risk_result: Optionales Risk-Check-Ergebnis
src/execution/pipeline.py:1644:                risk_allowed=False,
src/execution/pipeline.py:1645:                risk_reasons=reason,
src/execution/events.py:16:EventKind = Literal["gate", "intent", "order", "fill", "error"]
src/execution/events.py:25:    - After each gate decision
src/execution/events.py:36:        kind: Event type (gate/intent/order/fill/error)
src/live/shadow_session.py:46:from src.obs import strategy_risk_telemetry
src/live/shadow_session.py:54:from ..live.risk_limits import LiveRiskLimits, LiveRiskCheckResult
src/live/shadow_session.py:96:        last_risk_check: Zeitstempel des letzten Risk-Checks
src/live/shadow_session.py:108:    last_risk_check: Optional[datetime] = None
src/live/shadow_session.py:122:            "last_risk_check": self.last_risk_check.isoformat() if self.last_risk_check else None,
src/live/shadow_session.py:182:        ...     risk_limits=risk_limits,
src/live/shadow_session.py:196:        risk_limits: LiveRiskLimits,
src/live/shadow_session.py:210:            risk_limits: Live-Risk-Limits
src/live/shadow_session.py:230:        self._risk_limits = risk_limits
src/live/shadow_session.py:354:            "risk_allowed": True,
src/live/shadow_session.py:355:            "risk_reasons": "",
src/live/shadow_session.py:452:        self._metrics.last_risk_check = datetime.now(timezone.utc)
src/live/shadow_session.py:457:        risk_result = self._risk_limits.check_orders(live_orders)
src/live/shadow_session.py:459:        if not risk_result.allowed:
src/live/shadow_session.py:462:            event_data["risk_allowed"] = False
src/live/shadow_session.py:463:            event_data["risk_reasons"] = "; ".join(risk_result.reasons)
src/live/shadow_session.py:465:                f"[SHADOW SESSION] Orders blockiert durch Risk-Limits: {risk_result.reasons}"
src/live/shadow_session.py:501:            from src.obs import strategy_risk_telemetry as _srt
src/live/shadow_session.py:549:                risk_allowed=event_data.get("risk_allowed", True),
src/live/shadow_session.py:550:                risk_reasons=event_data.get("risk_reasons", ""),
src/live/shadow_session.py:606:        strategy_risk_telemetry.ensure_registered()
src/live/shadow_session.py:656:        strategy_risk_telemetry.ensure_registered()
src/live/shadow_session.py:690:        strategy_risk_telemetry.ensure_registered()
src/live/shadow_session.py:775:    enable_logging: bool = True,
src/live/shadow_session.py:789:        enable_logging: Run-Logging aktivieren (default: True)
src/live/shadow_session.py:832:    risk_limits = LiveRiskLimits.from_config(cfg, starting_cash=shadow_cfg.start_balance)
src/live/shadow_session.py:836:    if enable_logging and logging_cfg.enabled:
src/live/shadow_session.py:874:        risk_limits=risk_limits,
src/live/portfolio_monitor.py:33:from .risk_limits import LiveRiskLimits
src/live/portfolio_monitor.py:105:        self._compute_aggregates()
src/live/portfolio_monitor.py:107:    def _compute_aggregates(self) -> None:
src/live/portfolio_monitor.py:138:        _risk_limits: Optional LiveRiskLimits fÃ¼r Risk-Checks
src/live/portfolio_monitor.py:144:        risk_limits: LiveRiskLimits | None = None,
src/live/portfolio_monitor.py:151:            risk_limits: Optional LiveRiskLimits fÃ¼r Risk-Checks
src/live/portfolio_monitor.py:154:        self._risk_limits = risk_limits
src/strategies/gatheral_cont/vol_regime_overlay_strategy.py:219:                regime="meta_risk_layer",
src/webui/execution_watch_api_v0_2.py:175:def _enabled_exec_watch_metrics() -> bool:
src/webui/execution_watch_api_v0_2.py:195:# In-memory fallback (only when explicitly enabled; not exposed by default to keep determinism)
src/webui/execution_watch_api_v0_2.py:248:    if not _enabled_exec_watch_metrics():
src/webui/execution_watch_api_v0_2.py:900:    if include_runtime_metrics and _enabled_exec_watch_metrics():
src/execution/telemetry_health.py:64:    """Aggregate health report."""
src/execution/telemetry_health.py:352:    """Run all health checks and return aggregate report."""
src/live/alert_rules.py:286:            if event.get("risk_reasons") and str(event.get("risk_reasons")).strip():
src/live/alert_rules.py:288:                error_reason = f"Risk: {event.get('risk_reasons')}"
src/execution/reconciliation.py:288:        - Aggregate counts by severity and diff_type
src/execution/reconciliation.py:299:            ReconSummary with aggregated statistics
src/execution/broker/retry.py:6:- Deterministic (no jitter unless explicitly enabled)
src/webui/health_endpoint.py:125:            "resilience_enabled": True,
src/webui/knowledge_api.py:108:                "solution": "Set KNOWLEDGE_READONLY=false to enable writes",
src/webui/knowledge_api.py:135:                "solution": "Set KNOWLEDGE_WEB_WRITE_ENABLED=true to enable WebUI writes",
src/execution/risk_runtime/policies.py:4:Pluggable risk evaluation policies.
src/execution/risk_runtime/policies.py:10:from src.execution.risk_runtime.decisions import (
src/execution/risk_runtime/policies.py:15:from src.execution.risk_runtime.context import RiskContextSnapshot
src/execution/risk_runtime/policies.py:25:    Protocol for risk policies.
src/execution/risk_runtime/policies.py:60:    - Development (bypass risk checks)
src/webui/alerts_api.py:64:                "source": "live_risk_severity",
src/webui/alerts_api.py:70:                        "id": "live_risk_severity",
src/execution/telemetry_health_trends.py:127:    """Aggregated health metrics over a time period."""
src/execution/telemetry_health_trends.py:282:    Compute aggregated metrics from a list of snapshots.
src/execution/replay_pack/builder.py:139:    # Deterministic surrogate: epoch + ts_sim seconds.
src/webui/live_track.py:88:        risk_status: Risk-Ampel-Status (green/yellow/red, Phase 87 Severity)
src/webui/live_track.py:89:        risk_severity: Severity-Level (ok/warning/breach, Phase 87)
src/webui/live_track.py:109:    risk_status: Literal["green", "yellow", "red"] = Field(
src/webui/live_track.py:112:    risk_severity: Literal["ok", "warning", "breach"] = Field(
src/webui/live_track.py:148:    risk_status: Literal["green", "yellow", "red"] = Field(
src/webui/live_track.py:151:    risk_severity: Literal["ok", "warning", "breach"] = Field(
src/webui/live_track.py:154:    risk_limit_details: List[dict] = Field(
src/webui/live_track.py:250:def _extract_risk_status_from_metrics(metrics: dict) -> tuple:
src/webui/live_track.py:252:    Extrahiert risk_status und risk_severity aus Metrics.
src/webui/live_track.py:255:    1. Direkt in metrics["risk_status"] / metrics["risk_severity"]
src/webui/live_track.py:256:    2. In metrics["risk_check"]["severity"]
src/webui/live_track.py:260:        Tuple (risk_status, risk_severity)
src/webui/live_track.py:262:    risk_status = "green"
src/webui/live_track.py:263:    risk_severity = "ok"
src/webui/live_track.py:266:        return risk_status, risk_severity
src/webui/live_track.py:269:    if "risk_status" in metrics:
src/webui/live_track.py:270:        rs = metrics["risk_status"]
src/webui/live_track.py:272:            risk_status = rs
src/webui/live_track.py:274:            risk_severity = {"green": "ok", "yellow": "warning", "red": "breach"}.get(rs, "ok")
src/webui/live_track.py:276:    if "risk_severity" in metrics:
src/webui/live_track.py:277:        sev = metrics["risk_severity"]
src/webui/live_track.py:279:            risk_severity = sev
src/webui/live_track.py:281:            if "risk_status" not in metrics:
src/webui/live_track.py:282:                risk_status = {"ok": "green", "warning": "yellow", "breach": "red"}.get(
src/webui/live_track.py:286:    # Aus risk_check Sub-Dict
src/webui/live_track.py:287:    risk_check = metrics.get("risk_check", {})
src/webui/live_track.py:288:    if isinstance(risk_check, dict):
src/webui/live_track.py:289:        if "severity" in risk_check:
src/webui/live_track.py:290:            sev = risk_check["severity"]
src/webui/live_track.py:292:                risk_severity = sev
src/webui/live_track.py:293:                risk_status = {"ok": "green", "warning": "yellow", "breach": "red"}.get(
src/webui/live_track.py:297:    return risk_status, risk_severity
src/webui/live_track.py:340:        risk_status, risk_severity = _extract_risk_status_from_metrics(metrics)
src/webui/live_track.py:356:            risk_status=risk_status,
src/webui/live_track.py:357:            risk_severity=risk_severity,
src/webui/live_track.py:372:    Sucht in metrics["risk_check"]["limit_details"] oder metrics["limit_details"].
src/webui/live_track.py:387:    elif "risk_check" in metrics and isinstance(metrics["risk_check"], dict):
src/webui/live_track.py:388:        limit_details = metrics["risk_check"].get("limit_details")
src/webui/live_track.py:447:        risk_status, risk_severity = _extract_risk_status_from_metrics(metrics)
src/webui/live_track.py:448:        risk_limit_details = _extract_limit_details_from_metrics(metrics)
src/webui/live_track.py:464:            risk_status=risk_status,
src/webui/live_track.py:465:            risk_severity=risk_severity,
src/webui/live_track.py:466:            risk_limit_details=risk_limit_details,
src/execution/live_session.py:48:from src.obs import strategy_risk_telemetry
src/execution/live_session.py:59:    from ..live.risk_limits import LiveRiskLimits
src/execution/live_session.py:114:        enable_risk_limits: Ob Risk-Limits aktiviert werden sollen
src/execution/live_session.py:115:        enable_logging: Ob Run-Logging aktiviert werden soll
src/execution/live_session.py:134:    enable_risk_limits: bool = True
src/execution/live_session.py:135:    enable_logging: bool = True
src/execution/live_session.py:197:            "enable_risk_limits": self.enable_risk_limits,
src/execution/live_session.py:198:            "enable_logging": self.enable_logging,
src/execution/live_session.py:247:        orders_blocked_risk: Anzahl durch Risk-Limits blockierter Orders
src/execution/live_session.py:258:    orders_blocked_risk: int = 0
src/execution/live_session.py:271:            "orders_blocked_risk": self.orders_blocked_risk,
src/execution/live_session.py:331:        risk_limits: Optional["LiveRiskLimits"] = None,
src/execution/live_session.py:344:            risk_limits: Optionale LiveRiskLimits fÃ¼r Risk-Checks
src/execution/live_session.py:363:        self._risk_limits = risk_limits
src/execution/live_session.py:480:            from ..live.risk_limits import LiveRiskLimits
src/execution/live_session.py:492:                    enable_live_trading=False,
src/execution/live_session.py:498:                    enable_live_trading=False,
src/execution/live_session.py:515:            risk_limits = None
src/execution/live_session.py:516:            if session_config.enable_risk_limits:
src/execution/live_session.py:517:                risk_limits = LiveRiskLimits.from_config(
src/execution/live_session.py:530:                risk_limits=risk_limits,
src/execution/live_session.py:776:            self._metrics.orders_blocked_risk += len(orders)
src/execution/live_session.py:794:            from src.obs import strategy_risk_telemetry as _srt
src/execution/live_session.py:823:        strategy_risk_telemetry.ensure_registered()
src/execution/live_session.py:857:        strategy_risk_telemetry.ensure_registered()
src/execution/live_session.py:889:        strategy_risk_telemetry.ensure_registered()
src/execution/live_session.py:958:            f"  Blocked (Risk): {metrics['orders_blocked_risk']}\n"
src/execution/alerting/history.py:33:        enabled: bool = True,
src/execution/alerting/history.py:41:            enabled: Whether history is enabled
src/execution/alerting/history.py:45:        self.enabled = enabled
src/execution/alerting/history.py:58:        if not self.enabled:
src/execution/alerting/history.py:102:        if not self.enabled or not self.history_path.exists():
src/execution/alerting/history.py:162:        if not self.enabled or not self.history_path.exists():
src/execution/paper/engine.py:20:from src.execution.risk_runtime.decisions import RiskDecision
src/execution/paper/engine.py:21:from src.execution.risk_runtime.runtime import RiskRuntime
src/execution/paper/engine.py:51:    Paper execution engine with risk integration.
src/execution/paper/engine.py:55:    - Risk checks (pre-submit gate via RiskRuntime)
src/execution/paper/engine.py:70:        risk_runtime: Optional[RiskRuntime] = None,
src/execution/paper/engine.py:77:            risk_runtime: Optional RiskRuntime for pre-submit checks
src/execution/paper/engine.py:96:        self.risk_runtime = risk_runtime
src/execution/paper/engine.py:127:        Submit order with risk checks.
src/execution/paper/engine.py:164:        # Risk check (pre-submit gate)
src/execution/paper/engine.py:165:        if self.risk_runtime:
src/execution/paper/engine.py:166:            risk_result = self._check_risk(order)
src/execution/paper/engine.py:168:            if risk_result.decision == RiskDecision.REJECT:
src/execution/paper/engine.py:171:                    f"Order {order.client_order_id} REJECTED by risk: {risk_result.reason}"
src/execution/paper/engine.py:178:                    entry_id=f"risk_{order.client_order_id}",
src/execution/paper/engine.py:182:                        "reason": risk_result.reason,
src/execution/paper/engine.py:183:                        "decision": risk_result.decision.value,
src/execution/paper/engine.py:190:            elif risk_result.decision == RiskDecision.HALT:
src/execution/paper/engine.py:192:                logger.error(f"Order {order.client_order_id} HALTED by risk: {risk_result.reason}")
src/execution/paper/engine.py:198:                    entry_id=f"risk_{order.client_order_id}",
src/execution/paper/engine.py:202:                        "reason": risk_result.reason,
src/execution/paper/engine.py:203:                        "decision": risk_result.decision.value,
src/execution/paper/engine.py:255:    def _check_risk(self, order: Order) -> any:
src/execution/paper/engine.py:257:        Check order against risk runtime.
src/execution/paper/engine.py:265:        # Evaluate via risk runtime
src/execution/paper/engine.py:266:        result = self.risk_runtime.evaluate_pre_order(
src/execution/alerting/rules.py:33:        enabled: Whether rule is active
src/execution/alerting/rules.py:45:    enabled: bool
src/execution/alerting/rules.py:77:        if not self.enabled:
src/execution/alerting/rules.py:170:        enabled=True,
src/execution/alerting/rules.py:177:            "Please investigate immediately."
src/execution/alerting/rules.py:186:        enabled=True,
src/execution/alerting/rules.py:205:        enabled=True,
src/execution/alerting/rules.py:222:        enabled=True,
src/execution/alerting/rules.py:229:            "Action: Investigate recent telemetry sessions for corrupted logs."
src/execution/alerting/engine.py:79:            if not rule.enabled:
src/execution/alerting/engine.py:202:    def get_enabled_rules(self) -> List[AlertRule]:
src/execution/alerting/engine.py:203:        """Get list of enabled rules."""
src/execution/alerting/engine.py:204:        return [r for r in self.rules if r.enabled]
src/execution/alerting/engine.py:213:    def enable_rule(self, rule_id: str):
src/execution/alerting/engine.py:217:            rule.enabled = True
src/execution/alerting/engine.py:224:            rule.enabled = False
src/execution/alerting/operator_state.py:45:        enabled: bool = False,
src/execution/alerting/operator_state.py:53:            enabled: Whether operator actions are enabled
src/execution/alerting/operator_state.py:57:        self.enabled = enabled
src/execution/alerting/operator_state.py:65:        if enabled and state_path.exists():
src/execution/alerting/operator_state.py:87:        if not self.enabled:
src/execution/alerting/operator_state.py:133:        if not self.enabled:
src/execution/alerting/operator_state.py:167:        if not self.enabled:
src/execution/alerting/operator_state.py:187:        if not self.enabled:
src/execution/alerting/operator_state.py:220:        if not self.enabled:
src/execution/alerting/persistence.py:136:        # Only enable persistence if explicitly configured
src/execution/risk_runtime/context.py:4:Snapshot of system state for risk evaluation.
src/execution/risk_runtime/context.py:24:    Snapshot of system state for risk evaluation.
src/execution/risk_runtime/context.py:99:    Build risk context snapshot from ledgers.
src/execution/risk_hook.py:4:This module defines the interface between execution and risk layer.
src/execution/risk_hook.py:5:NO cyclic imports - execution depends on contracts, risk depends on contracts.
src/execution/risk_hook.py:9:- Execution never imports from src/risk_layer directly
src/execution/risk_hook.py:27:    Protocol for risk evaluation.
src/execution/risk_hook.py:51:    def check_kill_switch(self) -> RiskResult:
src/execution/risk_hook.py:53:        Check if kill switch is active.
src/execution/risk_hook.py:92:    - Testing (no risk checks)
src/execution/risk_hook.py:93:    - Development (bypass risk)
src/execution/risk_hook.py:94:    - Safe default (explicit opt-in to risk checks)
src/execution/risk_hook.py:105:    def check_kill_switch(self) -> RiskResult:
src/execution/risk_hook.py:109:            reason="NullRiskHook: kill switch inactive",
src/execution/risk_hook.py:153:    def check_kill_switch(self) -> RiskResult:
src/execution/risk_hook.py:186:    - Testing (simulate specific risk scenarios)
src/execution/risk_hook.py:187:    - Development (prototype risk logic)
src/execution/risk_hook.py:194:        kill_switch_active: bool = False,
src/execution/risk_hook.py:198:        self.kill_switch_active = kill_switch_active
src/execution/risk_hook.py:202:        # Check kill switch first
src/execution/risk_hook.py:203:        if self.kill_switch_active:
src/execution/risk_hook.py:232:    def check_kill_switch(self) -> RiskResult:
src/execution/risk_hook.py:233:        """Check kill switch status"""
src/execution/risk_hook.py:234:        if self.kill_switch_active:
src/execution/risk_hook.py:254:        if self.kill_switch_active:
src/execution/risk_hook.py:288:    """Factory for null risk hook"""
src/execution/risk_hook.py:293:    """Factory for blocking risk hook"""
src/execution/risk_hook.py:300:    kill_switch_active: bool = False,
src/execution/risk_hook.py:302:    """Factory for conditional risk hook"""
src/execution/risk_hook.py:306:        kill_switch_active=kill_switch_active,
src/execution/order_state_machine.py:11:- Integration with risk_hook for pre-submission checks
src/execution/order_state_machine.py:26:from src.execution.risk_hook import RiskHook, NullRiskHook
src/execution/order_state_machine.py:126:        risk_hook: Optional[RiskHook] = None,
src/execution/order_state_machine.py:127:        enable_audit: bool = True,
src/execution/order_state_machine.py:133:            risk_hook: Risk evaluation hook (optional, defaults to NullRiskHook)
src/execution/order_state_machine.py:134:            enable_audit: Enable audit log generation
src/execution/order_state_machine.py:136:        self.risk_hook = risk_hook or NullRiskHook()
src/execution/order_state_machine.py:137:        self.enable_audit = enable_audit
src/execution/order_state_machine.py:184:        if self.enable_audit:
src/execution/order_state_machine.py:234:        # Check risk hook
src/execution/order_state_machine.py:235:        risk_result = self.risk_hook.evaluate_order(order)
src/execution/order_state_machine.py:236:        if risk_result.decision.value != "ALLOW":
src/execution/order_state_machine.py:240:                message=f"Risk check blocked order: {risk_result.reason}",
src/execution/order_state_machine.py:241:                metadata={"risk_result": risk_result.to_dict()},
src/execution/order_state_machine.py:485:        if self.enable_audit:
src/execution/risk_runtime/runtime.py:4:Main orchestrator for runtime risk evaluation.
src/execution/risk_runtime/runtime.py:11:from src.execution.risk_runtime.decisions import (
src/execution/risk_runtime/runtime.py:17:from src.execution.risk_runtime.context import (
src/execution/risk_runtime/runtime.py:21:from src.execution.risk_runtime.policies import RiskPolicy
src/execution/risk_runtime/runtime.py:31:    Runtime risk evaluator with pluggable policies.
src/execution/risk_runtime/runtime.py:54:        Initialize risk runtime.
src/execution/risk_runtime/runtime.py:57:            policies: List of risk policies to evaluate
src/execution/risk_runtime/runtime.py:221:        # Aggregate decisions
src/execution/risk_runtime/runtime.py:247:        Log risk decision to audit log.
src/execution/risk_runtime/runtime.py:266:            entry_id=f"risk_{event_type.lower()}_{datetime.utcnow().timestamp()}",
src/execution/risk_runtime/decisions.py:4:Extended decision types for runtime risk evaluation.
src/execution/risk_runtime/decisions.py:22:    Extended risk decision types.
src/execution/risk_runtime/decisions.py:28:    - HALT: Emergency halt all trading (e.g., kill switch)
src/execution/risk_runtime/__init__.py:4:Runtime risk evaluation system with pluggable policies.
src/execution/risk_runtime/__init__.py:9:- RiskContextSnapshot: Snapshot of system state for risk evaluation
src/execution/risk_runtime/__init__.py:10:- RiskPolicy: Protocol for risk policies
src/execution/risk_runtime/__init__.py:11:- RiskRuntime: Main orchestrator for risk evaluation
src/execution/risk_runtime/__init__.py:15:from src.execution.risk_runtime.decisions import (
src/execution/risk_runtime/__init__.py:20:from src.execution.risk_runtime.context import (
src/execution/risk_runtime/__init__.py:26:from src.execution.risk_runtime.policies import (
src/execution/risk_runtime/__init__.py:34:from src.execution.risk_runtime.runtime import (
src/execution/replay_pack/contract_v2.py:35:# gated by invariants.has_fifo_ledger (see schema/validator).
src/execution/replay_pack/contract_v2.py:41:# v2 introduces new (optional or invariant-gated) files under ledger/.
src/execution/orchestrator.py:21:- No live enablement (default blocked/gated)
src/execution/orchestrator.py:24:IMPORTANT: NO live execution. Default remains blocked/gated.
src/execution/orchestrator.py:56:from src.execution.risk_hook import RiskHook, NullRiskHook
src/execution/orchestrator.py:92:        SHADOW: Shadow mode (dry-run, no real execution)
src/execution/orchestrator.py:109:    - RISK_*: Risk gate blocks
src/execution/orchestrator.py:152:    Represents strategy/operator intention before validation and risk checks.
src/execution/orchestrator.py:300:    - No live enablement (default blocked)
src/execution/orchestrator.py:302:    IMPORTANT: NO live execution. Default remains blocked/gated.
src/execution/orchestrator.py:307:        risk_hook: Optional[RiskHook] = None,
src/execution/orchestrator.py:312:        enable_audit: bool = True,
src/execution/orchestrator.py:314:        # RUNBOOK B / Slice 1: Minimal risk rails (stubs, testable)
src/execution/orchestrator.py:315:        kill_switch_active: bool = False,
src/execution/orchestrator.py:324:            risk_hook: Risk evaluation hook (defaults to NullRiskHook)
src/execution/orchestrator.py:332:            enable_audit: Enable audit log generation
src/execution/orchestrator.py:335:        self.risk_hook = risk_hook or NullRiskHook()
src/execution/orchestrator.py:340:        self.enable_audit = enable_audit
src/execution/orchestrator.py:343:        self.kill_switch_active = kill_switch_active
src/execution/orchestrator.py:352:            risk_hook=self.risk_hook,
src/execution/orchestrator.py:353:            enable_audit=enable_audit,
src/execution/orchestrator.py:512:            if self.kill_switch_active:
src/execution/orchestrator.py:520:                    reason_detail="kill switch active",
src/execution/orchestrator.py:524:                    reason="risk_kill_switch_active",
src/execution/orchestrator.py:556:                    reason="risk_max_position",
src/execution/orchestrator.py:589:            risk_result = self._stage_3_risk_gate(order, correlation_id)
src/execution/orchestrator.py:590:            if not risk_result.success:
src/execution/orchestrator.py:591:                risk_result.metadata.setdefault("beta_events", beta_events)
src/execution/orchestrator.py:594:                    reason="risk_blocked",
src/execution/orchestrator.py:599:                return risk_result
src/execution/orchestrator.py:797:    def _stage_3_risk_gate(self, order: Order, correlation_id: str) -> PipelineResult:
src/execution/orchestrator.py:817:        # Evaluate order via risk hook
src/execution/orchestrator.py:818:        risk_result: RiskResult = self.risk_hook.evaluate_order(order)
src/execution/orchestrator.py:820:        if risk_result.decision == RiskDecision.ALLOW:
src/execution/orchestrator.py:823:                f"reason={risk_result.reason}"
src/execution/orchestrator.py:830:                metadata={"risk_result": risk_result.to_dict()},
src/execution/orchestrator.py:833:        elif risk_result.decision == RiskDecision.BLOCK:
src/execution/orchestrator.py:836:                f"reason={risk_result.reason}"
src/execution/orchestrator.py:841:            sm_result = self.state_machine.fail_order(order, reason=risk_result.reason)
src/execution/orchestrator.py:853:                reason_detail=risk_result.reason,
src/execution/orchestrator.py:857:                metadata={"risk_result": risk_result.to_dict()},
src/execution/orchestrator.py:863:                f"reason={risk_result.reason}"
src/execution/orchestrator.py:868:            sm_result = self.state_machine.fail_order(order, reason=risk_result.reason)
src/execution/orchestrator.py:880:                reason_detail=f"Risk PAUSE (treated as BLOCK in Phase 0): {risk_result.reason}",
src/execution/orchestrator.py:884:                metadata={"risk_result": risk_result.to_dict()},
src/execution/orchestrator.py:923:                order, reason="Live execution not enabled (Phase 0)"
src/execution/contracts.py:358:    - Aggregated counts by diff_type and severity
src/execution/contracts.py:371:    # Aggregate counts
src/execution/contracts.py:419:    Risk layer decision (returned by risk_hook).
src/execution/contracts.py:435:    Risk evaluation result (returned by risk_hook).
src/execution/contracts.py:533:    sample_risk_result = RiskResult(
src/execution/contracts.py:543:        "risk_result": sample_risk_result.to_dict(),
src/execution/telemetry_viewer.py:28:        event_type: Filter by event kind (intent/order/fill/gate/error)
src/execution/telemetry_viewer.py:36:    event_type: Optional[str] = None  # intent|order|fill|gate|error
src/execution/telemetry_viewer.py:289:        elif kind == "gate":
src/execution/telemetry_viewer.py:290:            entry["gate_name"] = payload.get("gate_name", "")
src/execution/venue_adapters/registry.py:10:- No live enablement (LIVE_BLOCKED â†’ reject)
src/execution/venue_adapters/registry.py:13:           Live execution remains blocked/gated in Phase 0.
src/execution/venue_adapters/registry.py:40:    - TESTNET: SimulatedVenueAdapter (testnet dry-run)
src/execution/venue_adapters/registry.py:127:        - PAPER â†’ SimulatedVenueAdapter(enable_fills=True)
src/execution/venue_adapters/registry.py:128:        - SHADOW â†’ SimulatedVenueAdapter(enable_fills=True)
src/execution/venue_adapters/registry.py:129:        - TESTNET â†’ SimulatedVenueAdapter(enable_fills=True)
src/execution/venue_adapters/registry.py:140:            SimulatedVenueAdapter(enable_fills=True),
src/execution/venue_adapters/registry.py:146:            SimulatedVenueAdapter(enable_fills=True),
src/execution/venue_adapters/registry.py:149:        # TESTNET mode: same as PAPER (dry-run)
src/execution/venue_adapters/registry.py:152:            SimulatedVenueAdapter(enable_fills=True),
src/execution/venue_adapters/registry.py:168:        enable_fills: bool = True,
src/execution/venue_adapters/registry.py:175:            enable_fills: If False, orders are ACKed but not filled
src/execution/venue_adapters/registry.py:185:            enable_fills=enable_fills,
src/execution/venue_adapters/registry.py:194:        logger.info(f"AdapterRegistry: Created testing registry (enable_fills={enable_fills})")
src/execution/live/orchestrator.py:57:    # Optional, purely local validation gate (no registry/network).
src/execution/risk_hook_impl.py:11:from src.execution.risk_runtime import RiskRuntime
src/execution/risk_hook_impl.py:12:from src.execution.risk_runtime.decisions import RiskDecision as RuntimeRiskDecision
src/execution/risk_hook_impl.py:27:    - Delegates to RiskRuntime for evaluation
src/execution/risk_hook_impl.py:28:    - NO cyclic imports (only depends on contracts + risk_runtime)
src/execution/risk_hook_impl.py:38:        osm = OrderStateMachine(risk_hook=hook)
src/execution/risk_hook_impl.py:48:        Initialize runtime risk hook.
src/execution/risk_hook_impl.py:81:        # SLICE4 telemetry (watch/paper/shadow safe): bounded risk decision counters.
src/execution/risk_hook_impl.py:83:            from src.obs import strategy_risk_telemetry as _srt
src/execution/risk_hook_impl.py:90:                _srt.inc_risk_check(check="runtime_risk.evaluate_pre_order", result="allow", n=1)
src/execution/risk_hook_impl.py:92:                _srt.inc_risk_check(check="runtime_risk.evaluate_pre_order", result="block", n=1)
src/execution/risk_hook_impl.py:93:                _srt.inc_risk_block(reason="runtime:reject", n=1)
src/execution/risk_hook_impl.py:95:                _srt.inc_risk_check(check="runtime_risk.evaluate_pre_order", result="block", n=1)
src/execution/risk_hook_impl.py:96:                _srt.inc_risk_block(reason="runtime:halt", n=1)
src/execution/risk_hook_impl.py:98:                _srt.inc_risk_check(check="runtime_risk.evaluate_pre_order", result="error", n=1)
src/execution/risk_hook_impl.py:99:                _srt.inc_risk_block(reason="runtime:unknown", n=1)
src/execution/risk_hook_impl.py:113:    def check_kill_switch(self) -> RiskResult:
src/execution/risk_hook_impl.py:115:        Check if kill switch is active.
src/execution/risk_hook_impl.py:117:        Note: Phase 0 doesn't implement kill switch.
src/execution/risk_hook_impl.py:121:            RiskResult with ALLOW (kill switch inactive)
src/execution/risk_hook_impl.py:123:        # Phase 0: No kill switch implementation
src/execution/risk_hook_impl.py:127:            metadata={"phase": "0", "kill_switch": "not_implemented"},
src/execution/risk_hook_impl.py:152:        # Phase 0: Delegate to order evaluation
src/execution/risk_hook_impl.py:201:def create_runtime_risk_hook(
src/execution/venue_adapters/simulated.py:56:    - TESTNET mode: Same as PAPER (dry-run)
src/execution/venue_adapters/simulated.py:65:        enable_fills: bool = True,
src/execution/venue_adapters/simulated.py:76:            enable_fills: If False, orders are ACKed but not filled (for testing)
src/execution/venue_adapters/simulated.py:82:        self.enable_fills = enable_fills
src/execution/venue_adapters/simulated.py:89:            f"enable_fills={enable_fills}, "
src/execution/venue_adapters/simulated.py:143:        # 3. Generate fill (if enabled)
src/execution/venue_adapters/simulated.py:144:        if not self.enable_fills:
src/execution/venue_adapters/__init__.py:9:           Live execution remains blocked/gated in Phase 0.
src/execution/alerting/adapters/webhook.py:26:    - Disabled by default (must be explicitly enabled + URL provided)
src/execution/alerting/adapters/webhook.py:29:    - Safe by default: disabled unless config enables and URL exists
src/execution/alerting/adapters/webhook.py:37:        enabled: bool = False,
src/execution/alerting/adapters/webhook.py:46:            enabled: Whether webhook is enabled
src/execution/alerting/adapters/webhook.py:51:        self.enabled = enabled
src/execution/alerting/adapters/webhook.py:65:        if not self.enabled:
src/execution/alerting/adapters/webhook.py:70:            logger.warning("Webhook sink enabled but URL not configured")
src/execution/alerting/adapters/console.py:4:Prints alerts to stdout (default sink for dry-run).
src/execution/alerting/adapters/console.py:22:    - Ideal for dry-run mode
