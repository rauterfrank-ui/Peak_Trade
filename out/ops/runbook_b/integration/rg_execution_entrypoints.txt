src/observability/drift/comparator.py:84:    - Fill execution
src/observability/metrics.py:4:Collects and exports metrics for live execution monitoring.
src/observability/metrics.py:76:    Collects metrics for live execution monitoring.
src/governance/policy_critic/critic.py:176:            # Check for execution-critical warnings
src/governance/policy_critic/critic.py:177:            execution_warnings = [v for v in violations if v.rule_id == "EXECUTION_ENDPOINT_TOUCH"]
src/governance/policy_critic/critic.py:178:            if execution_warnings:
src/governance/policy_critic/critic.py:191:        # Check for execution path changes
src/governance/policy_critic/critic.py:192:        execution_files = [f for f in changed_files if "execution" in f or "exchange" in f]
src/governance/policy_critic/critic.py:193:        if execution_files:
src/governance/policy_critic/critic.py:194:            test_plan.append("Run integration tests for execution pipeline")
src/governance/policy_critic/critic.py:224:        # Check for execution changes
src/governance/policy_critic/critic.py:225:        execution_violations = [v for v in violations if "EXECUTION" in v.rule_id]
src/governance/policy_critic/critic.py:226:        if execution_violations:
src/governance/policy_critic/critic.py:227:            questions.append("Have these execution changes been tested in shadow mode?")
src/observability/drift/daily_report.py:178:Signal execution is mostly aligned but some divergence observed.
src/observability/drift/daily_report.py:207:                "ðŸ” **Investigate root cause:** Check data quality, timing, and execution logic."
src/observability/logging.py:4:Provides structured logging with context fields for live execution tracing.
src/observability/logging.py:53:    Set observability context for current execution.
src/backtest/engine.py:53:from ..execution.pipeline import ExecutionPipeline, ExecutionPipelineConfig, SignalEvent
src/backtest/engine.py:95:        use_execution_pipeline: bool = True,
src/backtest/engine.py:96:        log_executions: bool = False,
src/backtest/engine.py:109:            use_execution_pipeline: Wenn True, wird die ExecutionPipeline verwendet.
src/backtest/engine.py:112:            log_executions: Wenn True, werden Execution-Summaries gesammelt und in
src/backtest/engine.py:113:                           _execution_logs gespeichert. Default: False
src/backtest/engine.py:114:            use_order_layer: DEPRECATED - Alias fuer use_execution_pipeline (backward compat)
src/backtest/engine.py:130:        # Backward-compat: use_order_layer Ã¼berschreibt use_execution_pipeline
src/backtest/engine.py:133:                "use_order_layer ist deprecated, nutze use_execution_pipeline stattdessen"
src/backtest/engine.py:135:            self.use_execution_pipeline = use_order_layer
src/backtest/engine.py:137:            self.use_execution_pipeline = use_execution_pipeline
src/backtest/engine.py:140:        self.use_order_layer = self.use_execution_pipeline
src/backtest/engine.py:143:        self.log_executions = log_executions
src/backtest/engine.py:150:        self.execution_results: List[OrderExecutionResult] = []
src/backtest/engine.py:151:        self._execution_logs: List[Dict[str, Any]] = []
src/backtest/engine.py:154:        self.execution_pipeline: Optional[ExecutionPipeline] = None
src/backtest/engine.py:222:    def _init_execution_pipeline(
src/backtest/engine.py:249:            log_executions=self.log_executions,
src/backtest/engine.py:254:        self.execution_pipeline = ExecutionPipeline.for_paper(market_ctx, pipeline_config)
src/backtest/engine.py:255:        return self.execution_pipeline
src/backtest/engine.py:257:    def _log_execution_summary(
src/backtest/engine.py:264:        Speichert Execution-Summary in _execution_logs.
src/backtest/engine.py:269:            summary: Summary-Dict von ExecutionPipeline.get_execution_summary()
src/backtest/engine.py:277:        self._execution_logs.append(log_entry)
src/backtest/engine.py:279:        if self.log_executions:
src/backtest/engine.py:287:    def get_execution_logs(self) -> List[Dict[str, Any]]:
src/backtest/engine.py:294:        return self._execution_logs.copy()
src/backtest/engine.py:296:    def clear_execution_logs(self) -> None:
src/backtest/engine.py:298:        self._execution_logs.clear()
src/backtest/engine.py:312:        Workflow (Legacy, use_execution_pipeline=False):
src/backtest/engine.py:320:        Workflow (ExecutionPipeline, use_execution_pipeline=True):
src/backtest/engine.py:341:            >>> engine = BacktestEngine(use_execution_pipeline=True)
src/backtest/engine.py:351:            >>> engine = BacktestEngine(use_execution_pipeline=False)
src/backtest/engine.py:359:        if self.use_execution_pipeline:
src/backtest/engine.py:360:            return self._run_with_execution_pipeline(
src/backtest/engine.py:747:        DEPRECATED: Verwende run_realistic() mit use_execution_pipeline=True.
src/backtest/engine.py:750:        delegiert an _run_with_execution_pipeline().
src/backtest/engine.py:754:            "Nutze run_realistic() mit use_execution_pipeline=True stattdessen."
src/backtest/engine.py:756:        return self._run_with_execution_pipeline(
src/backtest/engine.py:765:    def _run_with_execution_pipeline(
src/backtest/engine.py:807:        self.execution_results = []
src/backtest/engine.py:817:        pipeline = self._init_execution_pipeline(
src/backtest/engine.py:875:                results = pipeline.execute_orders(orders)
src/backtest/engine.py:876:                self.execution_results.extend(results)
src/backtest/engine.py:1024:        exec_summary = pipeline.get_execution_summary()
src/backtest/engine.py:1046:        if self.log_executions:
src/backtest/engine.py:1047:            self._log_execution_summary(
src/backtest/engine.py:1059:                "mode": "execution_pipeline_backtest",
src/backtest/engine.py:1064:                "execution_summary": exec_summary,
src/observability/__init__.py:4:Provides structured logging and metrics for live execution monitoring.
src/governance/policy_critic/README.md:33:- **BLOCK**: Changes to order execution code (`place_order`, `submit_order`)
src/governance/policy_critic/README.md:34:- **WARN**: Other changes in `src/execution/`, `src/exchange/`, `src/live/`
src/governance/policy_critic/README.md:128:- `src/execution/**`
src/governance/policy_critic/rules.py:138:    """Warn or block changes to execution-critical paths."""
src/governance/policy_critic/rules.py:141:    description = "Detects changes to execution-critical code paths"
src/governance/policy_critic/rules.py:144:        "src/execution/",
src/governance/policy_critic/rules.py:150:        r"def\s+place_order",
src/governance/policy_critic/rules.py:151:        r"def\s+submit_order",
src/governance/policy_critic/rules.py:152:        r"\.place_order\(",
src/governance/policy_critic/rules.py:153:        r"\.submit_order\(",
src/governance/policy_critic/rules.py:178:                            message=f"Order execution code modified in {cfile}. This requires manual review.",
src/governance/policy_critic/rules.py:180:                            suggested_fix="Order execution changes require peer review and extensive testing.",
src/governance/policy_critic/rules.py:272:        "src/execution/",
src/governance/policy_critic/rules.py:281:        "src/execution/",
src/governance/live_mode_gate.py:4:Provides governance layer for live execution:
src/governance/live_mode_gate.py:48:    APPROVED = "approved"  # Explicitly approved for live execution
src/governance/live_mode_gate.py:85:        """Check if live execution is currently allowed."""
src/governance/live_mode_gate.py:105:    Gate controller for live execution mode.
src/governance/live_mode_gate.py:108:    allowing live execution.
src/governance/live_mode_gate.py:220:        self._state.reason = reason or "Approved for live execution"
src/governance/live_mode_gate.py:314:    Check if live execution is currently allowed.
src/governance/live_mode_gate.py:398:        import src.execution.risk_runtime  # noqa: F401
src/orders/base.py:129:    def execute_orders(self, orders: Sequence[OrderRequest]) -> List[OrderExecutionResult]:
src/orders/base.py:141:    def execute_order(self, order: OrderRequest) -> OrderExecutionResult:
src/autonomous/decision_engine.py:5:AI-enhanced decision logic for autonomous workflow execution.
src/autonomous/decision_engine.py:70:    Decision outcome for workflow execution.
src/autonomous/decision_engine.py:191:        Make a decision about workflow execution.
src/autonomous/decision_engine.py:249:            reasoning = "Forced execution via context override"
src/obs/ai_telemetry.py:14:- Leichtgewichtig (keine Imports aus execution/risk/governance heavy paths)
src/obs/ai_telemetry.py:160:    component: str = "execution",
src/obs/ai_telemetry.py:191:    component: str = "execution",
src/obs/ai_telemetry.py:209:    component: str = "execution",
src/autonomous/__init__.py:10:    - workflow_engine: Workflow execution and coordination
src/orders/shadow.py:149:        >>> result = executor.execute_order(order)
src/orders/shadow.py:177:        self._execution_count = 0
src/orders/shadow.py:258:    def execute_order(self, order: OrderRequest) -> OrderExecutionResult:
src/orders/shadow.py:275:        self._execution_count += 1
src/orders/shadow.py:280:            f"[SHADOW] Order #{self._execution_count}: "
src/orders/shadow.py:295:                    "execution_id": self._execution_count,
src/orders/shadow.py:316:                        "execution_id": self._execution_count,
src/orders/shadow.py:355:                "execution_id": self._execution_count,
src/orders/shadow.py:370:    def execute_orders(self, orders: Sequence[OrderRequest]) -> List[OrderExecutionResult]:
src/orders/shadow.py:380:        return [self.execute_order(order) for order in orders]
src/orders/shadow.py:394:            notes=f"Shadow execution #{self._execution_count}",
src/orders/shadow.py:398:    def get_execution_count(self) -> int:
src/orders/shadow.py:400:        return self._execution_count
src/orders/shadow.py:406:    def get_execution_summary(self) -> Dict[str, Any]:
src/orders/shadow.py:451:        self._execution_count = 0
src/autonomous/workflow_engine.py:5:Workflow execution and coordination for autonomous workflows.
src/autonomous/workflow_engine.py:22:    """Workflow execution status."""
src/autonomous/workflow_engine.py:39:        status: Current execution status
src/autonomous/workflow_engine.py:63:    Result of workflow execution.
src/autonomous/workflow_engine.py:67:        success: Whether execution was successful
src/autonomous/workflow_engine.py:84:    Autonomous workflow execution engine.
src/autonomous/workflow_engine.py:86:    Coordinates workflow execution, manages state, and integrates
src/autonomous/workflow_engine.py:144:            dry_run: If True, simulate execution
src/autonomous/workflow_engine.py:147:            WorkflowResult with execution outcome
src/autonomous/workflow_engine.py:211:        Simulate workflow execution (dry-run).
src/autonomous/workflow_engine.py:240:        # Map workflow types to script execution
src/execution_pipeline/policies.py:36:    run execution.
src/execution_pipeline/contracts.py:59:    Context for a single execution run.
src/orders/testnet_executor.py:163:        >>> result = executor.execute_order(order)
src/orders/testnet_executor.py:197:        self._execution_count = 0
src/orders/testnet_executor.py:198:        self._execution_log: List[TestnetExecutionLog] = []
src/orders/testnet_executor.py:220:    def execution_count(self) -> int:
src/orders/testnet_executor.py:222:        return self._execution_count
src/orders/testnet_executor.py:267:                client_order_id=order.client_id or f"testnet_{self._execution_count}",
src/orders/testnet_executor.py:279:    def execute_order(
src/orders/testnet_executor.py:302:        self._execution_count += 1
src/orders/testnet_executor.py:306:            f"[TESTNET EXECUTOR] Order #{self._execution_count}: "
src/orders/testnet_executor.py:320:                    "execution_id": self._execution_count,
src/orders/testnet_executor.py:325:            self._log_execution(order, result, now, risk_check_passed=False)
src/orders/testnet_executor.py:338:                    "execution_id": self._execution_count,
src/orders/testnet_executor.py:344:            self._log_execution(order, result, now, risk_check_passed=False)
src/orders/testnet_executor.py:349:            exchange_order_id = self._client.create_order(order)
src/orders/testnet_executor.py:371:                        "execution_id": self._execution_count,
src/orders/testnet_executor.py:395:                        "execution_id": self._execution_count,
src/orders/testnet_executor.py:402:            self._log_execution(order, result, now, exchange_order_id=exchange_order_id)
src/orders/testnet_executor.py:413:                    "execution_id": self._execution_count,
src/orders/testnet_executor.py:419:            self._log_execution(order, result, now, notes=f"Error: {e}")
src/orders/testnet_executor.py:422:    def execute_orders(
src/orders/testnet_executor.py:451:                self._execution_count += 1
src/orders/testnet_executor.py:458:                        "execution_id": self._execution_count,
src/orders/testnet_executor.py:465:                self._log_execution(order, result, now, risk_check_passed=False)
src/orders/testnet_executor.py:470:        return [self.execute_order(order, current_price) for order in orders]
src/orders/testnet_executor.py:472:    def _log_execution(
src/orders/testnet_executor.py:491:        self._execution_log.append(log_entry)
src/orders/testnet_executor.py:493:    def get_execution_log(self) -> List[TestnetExecutionLog]:
src/orders/testnet_executor.py:495:        return list(self._execution_log)
src/orders/testnet_executor.py:497:    def get_execution_summary(self) -> Dict[str, Any]:
src/orders/testnet_executor.py:504:        filled = [log for log in self._execution_log if log.result.status == "filled"]
src/orders/testnet_executor.py:505:        rejected = [log for log in self._execution_log if log.result.status == "rejected"]
src/orders/testnet_executor.py:506:        risk_blocked = [log for log in self._execution_log if not log.risk_check_passed]
src/orders/testnet_executor.py:518:            "total_orders": len(self._execution_log),
src/orders/testnet_executor.py:522:            "fill_rate": len(filled) / len(self._execution_log) if self._execution_log else 0.0,
src/orders/testnet_executor.py:532:        self._execution_log.clear()
src/orders/testnet_executor.py:536:        self._execution_count = 0
src/orders/testnet_executor.py:537:        self._execution_log.clear()
src/execution_pipeline/pipeline.py:115:                    message="execution_run_timeout_exceeded",
src/governance/__init__.py:27:    validate_execution_config,
src/governance/__init__.py:28:    validate_execution_config_strict,
src/governance/__init__.py:55:    "validate_execution_config",
src/governance/__init__.py:56:    "validate_execution_config_strict",
src/experiments/live_session_registry.py:52:    - src/execution/live_session.py (LiveSessionRunner, LiveSessionConfig)
src/experiments/live_session_registry.py:245:        Die Aufrufstelle in run_execution_session.py muss dafÃ¼r sorgen,
src/execution_pipeline/events_v0.py:27:    Stable, versioned execution event.
src/execution_pipeline/events_v0.py:33:    schema: Literal["execution_event_v0"] = "execution_event_v0"
src/execution_pipeline/telemetry.py:2:Telemetry emitters for execution_pipeline v0.
src/execution_pipeline/telemetry.py:35:    Default path is compatible with existing repo patterns under `logs/execution`.
src/execution_pipeline/telemetry.py:38:    root: Path = Path("logs/execution")
src/execution_pipeline/telemetry.py:39:    filename: str = "execution_pipeline_events_v0.jsonl"
src/execution_pipeline/telemetry.py:48:            logger.error("Failed to emit execution_pipeline event: %s", e)
src/orders/exchange.py:108:        >>> result = executor.execute_order(order)  # Dry-Run
src/orders/exchange.py:131:        self._execution_count = 0
src/orders/exchange.py:161:    def execute_order(self, order: OrderRequest) -> OrderExecutionResult:
src/orders/exchange.py:178:        self._execution_count += 1
src/orders/exchange.py:183:            f"[TESTNET DRY-RUN] Order #{self._execution_count}: "
src/orders/exchange.py:198:                    "execution_id": self._execution_count,
src/orders/exchange.py:227:                    "execution_id": self._execution_count,
src/orders/exchange.py:251:    def execute_orders(self, orders: Sequence[OrderRequest]) -> List[OrderExecutionResult]:
src/orders/exchange.py:253:        return [self.execute_order(order) for order in orders]
src/orders/exchange.py:255:    def get_execution_count(self) -> int:
src/orders/exchange.py:257:        return self._execution_count
src/orders/exchange.py:269:        self._execution_count = 0
src/orders/exchange.py:308:        >>> result = executor.execute_order(order)  # Dry-Run mit Logging
src/orders/exchange.py:342:        self._execution_count = 0
src/orders/exchange.py:356:            "[SAFETY] Live execution blocked â€“ system is Phase 71 (design only, no real orders)."
src/orders/exchange.py:386:    def execute_order(self, order: OrderRequest) -> OrderExecutionResult:
src/orders/exchange.py:404:        self._execution_count += 1
src/orders/exchange.py:416:            f"[LIVE-DRY-RUN] Would send LIVE order #{self._execution_count}: "
src/orders/exchange.py:432:                    "execution_id": self._execution_count,
src/orders/exchange.py:463:                    "execution_id": self._execution_count,
src/orders/exchange.py:490:    def execute_orders(self, orders: Sequence[OrderRequest]) -> List[OrderExecutionResult]:
src/orders/exchange.py:492:        return [self.execute_order(order) for order in orders]
src/orders/exchange.py:494:    def get_execution_count(self) -> int:
src/orders/exchange.py:496:        return self._execution_count
src/orders/exchange.py:508:        self._execution_count = 0
src/orders/exchange.py:545:        >>> executor.execute_order(order)  # Dry-Run
src/orders/exchange.py:551:        >>> executor.execute_order(order)  # Nutzt DummyExchangeClient
src/orders/exchange.py:579:        self._execution_count = 0
src/orders/exchange.py:603:    def execute_order(self, order: OrderRequest) -> OrderExecutionResult:
src/orders/exchange.py:620:        self._execution_count += 1
src/orders/exchange.py:634:                    "execution_id": self._execution_count,
src/orders/exchange.py:647:            return self._testnet_executor.execute_order(order)
src/orders/exchange.py:652:            self._safety_guard.ensure_may_place_order(is_testnet=False)
src/orders/exchange.py:664:                "execution_id": self._execution_count,
src/orders/exchange.py:693:            exchange_order_id = self._trading_client.place_order(
src/orders/exchange.py:706:            return self._map_exchange_result_to_execution_result(
src/orders/exchange.py:722:                    "execution_id": self._execution_count,
src/orders/exchange.py:729:    def _map_exchange_result_to_execution_result(
src/orders/exchange.py:789:                "execution_id": self._execution_count,
src/orders/exchange.py:797:    def execute_orders(self, orders: Sequence[OrderRequest]) -> List[OrderExecutionResult]:
src/orders/exchange.py:799:        return [self.execute_order(order) for order in orders]
src/orders/exchange.py:801:    def get_execution_count(self) -> int:
src/orders/exchange.py:803:        return self._execution_count
src/orders/exchange.py:856:# Factory-Funktion: create_order_executor (Phase 71)
src/orders/exchange.py:860:def create_order_executor(
src/orders/exchange.py:893:        >>> executor = create_order_executor(env)
src/orders/exchange.py:899:        >>> executor = create_order_executor(env)
src/orders/exchange.py:908:        >>> executor = create_order_executor(env)
src/governance/go_no_go.py:25:    "live_order_execution": "locked",
src/governance/go_no_go.py:48:        >>> get_governance_status("live_order_execution")
src/governance/go_no_go.py:78:        >>> is_feature_approved_for_year("live_order_execution", 2026)
src/execution_pipeline/__init__.py:4:Dieses Paket ist bewusst von `src.execution.*` getrennt, um:
src/ai_orchestration/l4_critic_determinism_contract.py:9:- No-live: pure analysis/validation code, no trading/execution
src/orders/paper.py:87:        self._execution_count = 0
src/orders/paper.py:154:    def execute_order(self, order: OrderRequest) -> OrderExecutionResult:
src/orders/paper.py:164:        self._execution_count += 1
src/orders/paper.py:176:                metadata={"execution_id": self._execution_count},
src/orders/paper.py:191:                        "execution_id": self._execution_count,
src/orders/paper.py:226:                "execution_id": self._execution_count,
src/orders/paper.py:235:    def execute_orders(self, orders: Sequence[OrderRequest]) -> List[OrderExecutionResult]:
src/orders/paper.py:245:        return [self.execute_order(order) for order in orders]
src/orders/paper.py:247:    def get_execution_count(self) -> int:
src/orders/paper.py:249:        return self._execution_count
src/orders/paper.py:251:    def reset_execution_count(self) -> None:
src/orders/paper.py:253:        self._execution_count = 0
src/orders/paper.py:278:    def execute_orders(self, orders: Sequence[OrderRequest]) -> List[OrderExecutionResult]:
src/orders/paper.py:281:    def execute_order(self, order: OrderRequest) -> OrderExecutionResult:
src/governance/config_validation.py:4:Validates execution configuration before deployment.
src/governance/config_validation.py:17:def validate_execution_config(config: Dict[str, Any]) -> List[str]:
src/governance/config_validation.py:19:    Validate execution configuration.
src/governance/config_validation.py:37:        >>> errors = validate_execution_config(config)
src/governance/config_validation.py:85:def validate_execution_config_strict(config: Dict[str, Any]) -> None:
src/governance/config_validation.py:87:    Validate execution configuration (strict mode - raises on error).
src/governance/config_validation.py:94:        >>> validate_execution_config_strict(config)  # Raises!
src/governance/config_validation.py:103:    errors = validate_execution_config(config)
src/execution/telemetry_retention.py:4:Automated log lifecycle management for execution telemetry logs.
src/execution/telemetry_retention.py:115:    - Path name contains "execution" or "telemetry" or "logs"
src/execution/telemetry_retention.py:148:    # Check path contains telemetry/execution/logs keywords
src/execution/telemetry_retention.py:150:    safe_keywords = ["execution", "telemetry", "logs", "log"]
src/execution/telemetry_retention.py:164:        root: Directory to scan (e.g., logs/execution)
src/webui/execution_watch_api_v0.py:5:- GET /api/v0/execution/health
src/webui/execution_watch_api_v0.py:6:- GET /api/v0/execution/runs
src/webui/execution_watch_api_v0.py:7:- GET /api/v0/execution/runs/{run_id}
src/webui/execution_watch_api_v0.py:8:- GET /watch/execution (HTML)
src/webui/execution_watch_api_v0.py:21:from src.execution_pipeline.store import JsonlExecutionRunStore
src/webui/execution_watch_api_v0.py:23:router = APIRouter(tags=["execution-watch-v0"])
src/webui/execution_watch_api_v0.py:30:@router.get("/api/v0/execution/health")
src/webui/execution_watch_api_v0.py:31:async def execution_health_v0(
src/webui/execution_watch_api_v0.py:32:    root: str = Query("logs/execution", description="JSONL root (read-only)"),
src/webui/execution_watch_api_v0.py:34:        "execution_pipeline_events_v0.jsonl", description="JSONL filename (read-only)"
src/webui/execution_watch_api_v0.py:41:        "schema": "execution_event_v0",
src/webui/execution_watch_api_v0.py:48:@router.get("/api/v0/execution/runs")
src/webui/execution_watch_api_v0.py:49:async def execution_runs_v0(
src/webui/execution_watch_api_v0.py:51:    root: str = Query("logs/execution", description="JSONL root (read-only)"),
src/webui/execution_watch_api_v0.py:53:        "execution_pipeline_events_v0.jsonl", description="JSONL filename (read-only)"
src/webui/execution_watch_api_v0.py:61:@router.get("/api/v0/execution/runs/{run_id}")
src/webui/execution_watch_api_v0.py:62:async def execution_run_detail_v0(
src/webui/execution_watch_api_v0.py:65:    root: str = Query("logs/execution", description="JSONL root (read-only)"),
src/webui/execution_watch_api_v0.py:67:        "execution_pipeline_events_v0.jsonl", description="JSONL filename (read-only)"
src/webui/execution_watch_api_v0.py:77:@router.get("/watch/execution", response_class=HTMLResponse)
src/webui/execution_watch_api_v0.py:78:async def execution_watch_page_v0(
src/webui/execution_watch_api_v0.py:81:    root: str = Query("logs/execution", description="JSONL root (read-only)"),
src/webui/execution_watch_api_v0.py:83:        "execution_pipeline_events_v0.jsonl", description="JSONL filename (read-only)"
src/webui/execution_watch_api_v0.py:125:    lines.append("<div class='muted'>Quelle: JSONL Events (schema=execution_event_v0)</div>")
src/execution/audit_log.py:4:Append-only audit trail for all execution events.
src/execution/audit_log.py:18:from src.execution.contracts import LedgerEntry, ReconSummary
src/live/safety.py:140:        >>> guard.ensure_may_place_order()  # Raises PaperModeOrderError
src/live/safety.py:179:    def ensure_may_place_order(self, *, is_testnet: bool = False) -> None:
src/live/safety.py:201:        action = f"place_order(is_testnet={is_testnet})"
src/live/safety.py:232:            allowed, reason_detail = is_live_execution_allowed(self.env_config)
src/live/safety.py:398:# Helper-Funktion: is_live_execution_allowed (Phase 71)
src/live/safety.py:402:def is_live_execution_allowed(env_config: EnvironmentConfig) -> tuple[bool, str]:
src/live/safety.py:437:        >>> allowed, reason = is_live_execution_allowed(env)
src/ai_orchestration/l1_runner.py:274:            "4. No execution instructions or live trading advice."
src/ai_orchestration/l1_runner.py:324:            "4. No execution instructions or live trading advice\n"
src/execution_pipeline/store.py:2:Read-only store for execution_pipeline events (JSONL).
src/execution_pipeline/store.py:39:        root: Path = Path("logs/execution"),
src/execution_pipeline/store.py:40:        filename: str = "execution_pipeline_events_v0.jsonl",
src/execution_pipeline/store.py:63:                if obj.get("schema") != "execution_event_v0":
src/execution/replay_pack/schema.py:121:    if inv.get("has_execution_events") is not True:
src/execution/replay_pack/schema.py:122:        raise SchemaValidationError("manifest invariants.has_execution_events must be true")
src/execution/replay_pack/schema.py:182:def validate_execution_event_object_strict(ev: Mapping[str, Any], *, line_no: int) -> None:
src/execution/replay_pack/schema.py:184:    Strict event-object validation for events/execution_events.jsonl.
src/execution/replay_pack/schema.py:190:        raise ContractViolationError("execution event schema_version must be 'BETA_EXEC_V1'")
src/execution/replay_pack/schema.py:194:            raise ContractViolationError(f"execution event missing/invalid required string: {k}")
src/execution/replay_pack/schema.py:197:        raise ContractViolationError("execution event ts_sim must be int >= 0")
src/execution/replay_pack/schema.py:201:        raise ContractViolationError("execution event payload must be object (not null)")
src/execution/replay_pack/schema.py:203:        raise ContractViolationError("execution event payload must be object")
src/live/execution_bridge.py:1:# src/live/execution_bridge.py
src/live/execution_bridge.py:5:Phase 16B: Reads execution events from JSONL logs and maps them to
src/live/execution_bridge.py:41:def get_execution_timeline(
src/live/execution_bridge.py:43:    base_path: str = "logs/execution",
src/live/execution_bridge.py:47:    Load execution timeline for a session.
src/live/execution_bridge.py:49:    Reads last N events from logs/execution/<session_id>.jsonl
src/live/execution_bridge.py:54:        base_path: Base path for execution logs
src/live/execution_bridge.py:61:        >>> timeline = get_execution_timeline("session_123", limit=50)
src/live/execution_bridge.py:102:        logger.error(f"Failed to load execution timeline: {e}")
src/live/execution_bridge.py:108:    Map execution event to timeline row.
src/live/execution_bridge.py:171:def get_execution_summary(
src/live/execution_bridge.py:173:    base_path: str = "logs/execution",
src/live/execution_bridge.py:176:    Get execution summary statistics for a session.
src/live/execution_bridge.py:180:        base_path: Base path for execution logs
src/live/execution_bridge.py:185:    timeline = get_execution_timeline(session_id, base_path, limit=10000)
src/strategies/diagnostics.py:502:            use_execution_pipeline=True,
src/webui/services/live_panel_data.py:195:        root: Optional telemetry root directory (default: logs/execution)
src/webui/services/live_panel_data.py:209:    telemetry_root = root or Path("logs/execution")
src/webui/services/live_panel_data.py:212:        from src.execution.telemetry_health import run_health_checks
src/execution/replay_pack/compare.py:8:from src.execution.beta_bridge.schema import normalize_beta_exec_v1_event, sort_key_beta_exec_v1
src/execution/replay_pack/compare.py:315:            events = list(bundle.execution_events())
src/live_eval/live_session_eval.py:11:    """Represents a single fill/trade execution."""
src/ops/gates/armed_gate.py:19:    Two-stage execution gate:
src/webui/ops_ci_health_router.py:25:- POST /ops/ci-health/run    - Trigger check execution (with lock)
src/webui/ops_ci_health_router.py:58:# In-memory lock for check execution (prevents parallel runs)
src/webui/ops_workflows_router.py:13:- Read-only, no script execution
src/execution/replay_pack/contract.py:31:    "events/execution_events.jsonl",
src/execution/replay_pack/contract.py:120:    has_execution_events: bool
src/execution/events.py:1:# src/execution/events.py
src/execution/events.py:22:    Structured execution event for telemetry.
src/execution/pipeline.py:1:# src/execution/pipeline.py
src/execution/pipeline.py:20:- Governance-Check via get_governance_status("live_order_execution")
src/execution/pipeline.py:26:         live_order_execution ist governance-seitig gesperrt (locked).
src/execution/pipeline.py:63:    # Watch-only telemetry; must never fail execution logic.
src/execution/pipeline.py:69:    # Watch-only telemetry; must never fail execution logic.
src/execution/pipeline.py:121:    - env="live" und get_governance_status("live_order_execution") == "locked"
src/execution/pipeline.py:125:        feature_key: Der Governance-Feature-Key (z.B. "live_order_execution")
src/execution/pipeline.py:133:        feature_key: str = "live_order_execution",
src/execution/pipeline.py:147:    - get_governance_status("live_order_execution") == "locked"
src/execution/pipeline.py:155:            "Governance-Feature: 'live_order_execution'. "
src/execution/pipeline.py:161:            feature_key="live_order_execution",
src/execution/pipeline.py:262:        >>> result = pipeline.submit_order(intent)
src/execution/pipeline.py:305:        BLOCKED_BY_GOVERNANCE: Durch Governance blockiert (z.B. live_order_execution=locked)
src/execution/pipeline.py:332:    Phase 16A V2: Wird von execute_with_safety() und submit_order() zurueckgegeben.
src/execution/pipeline.py:339:        execution_results: Liste der OrderExecutionResults vom Executor
src/execution/pipeline.py:349:    execution_results: List[OrderExecutionResult] = field(default_factory=list)
src/execution/pipeline.py:449:        log_executions: Ob Execution-Details geloggt werden sollen (Default: True)
src/execution/pipeline.py:459:    log_executions: bool = True  # Fuer Backward-Kompatibilitaet mit BacktestEngine
src/execution/pipeline.py:475:        >>> from src.execution import ExecutionPipeline
src/execution/pipeline.py:521:        self._execution_history: List[OrderExecutionResult] = []
src/execution/pipeline.py:544:    def execution_history(self) -> List[OrderExecutionResult]:
src/execution/pipeline.py:546:        return self._execution_history.copy()
src/execution/pipeline.py:556:        Emit execution event (Phase 16B).
src/execution/pipeline.py:585:            logger.warning(f"Failed to emit execution event: {e}")
src/execution/pipeline.py:678:    def execute_orders(
src/execution/pipeline.py:694:            >>> results = pipeline.execute_orders([order])
src/execution/pipeline.py:703:        results = self._executor.execute_orders(orders_list)
src/execution/pipeline.py:706:        self._execution_history.extend(results)
src/execution/pipeline.py:1031:            results = self.execute_orders([order])
src/execution/pipeline.py:1047:    def get_execution_summary(self) -> Dict[str, Any]:
src/execution/pipeline.py:1060:        filled = [r for r in self._execution_history if r.is_filled]
src/execution/pipeline.py:1061:        rejected = [r for r in self._execution_history if r.is_rejected]
src/execution/pipeline.py:1072:        total_orders = len(self._execution_history)
src/execution/pipeline.py:1085:        self._execution_history.clear()
src/execution/pipeline.py:1089:    # Phase 16A V2: submit_order() - Governance-aware Order Submission
src/execution/pipeline.py:1092:    def submit_order(
src/execution/pipeline.py:1129:            >>> result = pipeline.submit_order(intent)
src/execution/pipeline.py:1159:        governance_status = get_governance_status("live_order_execution")
src/execution/pipeline.py:1164:                    f"live_order_execution is governance-locked (status='{governance_status}'). "
src/execution/pipeline.py:1269:        governance_status = get_governance_status("live_order_execution")
src/execution/pipeline.py:1335:                execution_results=[],
src/execution/pipeline.py:1367:                execution_results=[],
src/execution/pipeline.py:1402:                    execution_results=[],
src/execution/pipeline.py:1412:                # SafetyGuard.ensure_may_place_order() wirft Exception bei Blockierung
src/execution/pipeline.py:1415:                self._safety_guard.ensure_may_place_order(is_testnet=is_testnet)
src/execution/pipeline.py:1437:                    execution_results=[],
src/execution/pipeline.py:1456:                    self._log_rejected_execution(orders_list, reason, risk_result)
src/execution/pipeline.py:1475:                    execution_results=[],
src/execution/pipeline.py:1484:        execution_results = self._executor.execute_orders(orders_list)
src/execution/pipeline.py:1485:        self._execution_history.extend(execution_results)
src/execution/pipeline.py:1489:            self._log_execution_results(execution_results, risk_result)
src/execution/pipeline.py:1508:            executed_orders=execution_results,
src/execution/pipeline.py:1509:            execution_results=execution_results,
src/execution/pipeline.py:1559:    def _log_execution_results(
src/execution/pipeline.py:1561:        execution_results: List[OrderExecutionResult],
src/execution/pipeline.py:1568:            execution_results: Liste von OrderExecutionResults
src/execution/pipeline.py:1581:            for result in execution_results:
src/execution/pipeline.py:1599:                        "execution_status": result.status,
src/execution/pipeline.py:1615:    def _log_rejected_execution(
src/execution/replay_pack/loader.py:26:    def execution_events(self) -> Iterable[Dict[str, Any]]:
src/execution/replay_pack/loader.py:27:        yield from iter_jsonl(self.root / "events" / "execution_events.jsonl")
src/execution_simple/pipeline.py:1:# src/execution_simple/pipeline.py
src/execution_simple/pipeline.py:5:Orchestrates order generation, gate validation, and execution.
src/execution_simple/pipeline.py:27:    Orchestrates order execution pipeline.
src/execution_simple/pipeline.py:54:            adapter: Optional broker adapter for execution
src/execution_simple/pipeline.py:134:                fill = self.adapter.execute_order(order, context)
src/live/drills.py:10:    kein Pfad zu echten Orders existiert, und is_live_execution_allowed()
src/live/drills.py:33:from src.live.safety import SafetyGuard, is_live_execution_allowed
src/live/drills.py:57:        expected_is_live_execution_allowed: Erwartetes Ergebnis von
src/live/drills.py:58:                                           is_live_execution_allowed()
src/live/drills.py:69:    expected_is_live_execution_allowed: bool = False
src/live/drills.py:83:        is_live_execution_allowed: TatsÃ¤chliches Ergebnis von
src/live/drills.py:84:                                   is_live_execution_allowed()
src/live/drills.py:85:        reason: Reason-String von is_live_execution_allowed()
src/live/drills.py:93:    is_live_execution_allowed: bool
src/live/drills.py:158:        # is_live_execution_allowed() prÃ¼fen
src/live/drills.py:159:        allowed, reason = is_live_execution_allowed(env_config)
src/live/drills.py:182:        if allowed != scenario.expected_is_live_execution_allowed:
src/live/drills.py:184:                f"is_live_execution_allowed mismatch: "
src/live/drills.py:185:                f"expected={scenario.expected_is_live_execution_allowed}, "
src/live/drills.py:202:            is_live_execution_allowed=allowed,
src/live/drills.py:270:                "Erwartung: is_live_execution_allowed=False, "
src/live/drills.py:279:            expected_is_live_execution_allowed=False,
src/live/drills.py:290:                "Erwartung: is_live_execution_allowed=False, "
src/live/drills.py:299:            expected_is_live_execution_allowed=False,
src/live/drills.py:310:                "Erwartung: is_live_execution_allowed=False, "
src/live/drills.py:321:            expected_is_live_execution_allowed=False,
src/live/drills.py:332:                "Erwartung: is_live_execution_allowed=False, "
src/live/drills.py:343:            expected_is_live_execution_allowed=False,
src/live/drills.py:355:                "Erwartung: is_live_execution_allowed kann True sein (Gating), "
src/live/drills.py:371:            expected_is_live_execution_allowed=True,  # Gating erlaubt, aber Risk wÃ¼rde blockieren
src/live/drills.py:382:                "Erwartung: is_live_execution_allowed=False, "
src/live/drills.py:391:            expected_is_live_execution_allowed=False,
src/live/drills.py:402:                "Erwartung: is_live_execution_allowed=False, "
src/live/drills.py:411:            expected_is_live_execution_allowed=False,
src/execution/risk_runtime/policies.py:10:from src.execution.risk_runtime.decisions import (
src/execution/risk_runtime/policies.py:15:from src.execution.risk_runtime.context import RiskContextSnapshot
src/execution/risk_runtime/policies.py:171:        from src.execution.contracts import OrderSide
src/execution/risk_runtime/policies.py:235:        from src.execution.contracts import OrderSide
src/webui/app.py:118:    from src.execution.telemetry_retention import (
src/webui/app.py:122:    from src.execution.telemetry_health import run_health_checks, HealthThresholds
src/webui/app.py:155:from .execution_watch_api_v0 import router as execution_watch_v0_router
src/webui/app.py:156:from .execution_watch_api_v0_2 import router as execution_watch_v0_2_router
src/webui/app.py:404:    app.include_router(execution_watch_v0_router)
src/webui/app.py:406:    app.include_router(execution_watch_v0_2_router)
src/webui/app.py:426:    @app.get("/execution_watch", response_class=HTMLResponse)
src/webui/app.py:427:    async def execution_watch_dashboard_page(request: Request) -> Any:
src/webui/app.py:432:        - execution runs + events pagination
src/webui/app.py:438:            "execution_watch.html",
src/webui/app.py:1044:        "/api/live/execution/{session_id}",
src/webui/app.py:1047:        tags=["execution"],
src/webui/app.py:1049:    async def api_execution_timeline(
src/webui/app.py:1062:        from src.live.execution_bridge import get_execution_timeline, get_execution_summary
src/webui/app.py:1065:        timeline_rows = get_execution_timeline(session_id, limit=limit)
src/webui/app.py:1084:        summary = get_execution_summary(session_id)
src/webui/app.py:1095:        "/live/execution/{session_id}",
src/webui/app.py:1100:    async def execution_timeline_page(
src/webui/app.py:1114:        from src.live.execution_bridge import get_execution_timeline, get_execution_summary
src/webui/app.py:1119:        timeline_rows = get_execution_timeline(session_id, limit=limit)
src/webui/app.py:1126:        summary = get_execution_summary(session_id)
src/webui/app.py:1142:            "execution_timeline.html",
src/webui/app.py:1283:        from src.execution.telemetry_viewer import (
src/webui/app.py:1302:        base_path = Path("logs/execution")
src/webui/app.py:1419:        telemetry_root = Path("logs/execution")
src/webui/app.py:1454:            from src.execution.telemetry_health_trends import load_snapshots, compute_rollup
src/webui/app.py:1545:        root: str = Query("logs/execution", description="Telemetry root directory"),
src/webui/app.py:1575:            from src.execution.telemetry_health_trends import (
src/webui/app.py:1687:            from src.execution.alerting.persistence import get_global_alert_store
src/execution/replay_pack/builder.py:11:from src.execution.beta_bridge.schema import normalize_beta_exec_v1_event, sort_key_beta_exec_v1
src/execution/replay_pack/builder.py:32:    # src/execution/replay_pack/builder.py -> repo root is 4 levels up
src/execution/replay_pack/builder.py:37:    # Preferred contract location (Slice 1): logs/execution/execution_events.jsonl
src/execution/replay_pack/builder.py:39:        run_dir / "logs" / "execution" / "execution_events.jsonl",
src/execution/replay_pack/builder.py:40:        run_dir / "execution_events.jsonl",
src/execution/replay_pack/builder.py:41:        run_dir / "logs" / "execution_events.jsonl",
src/execution/replay_pack/builder.py:55:            raise FileNotFoundError("could not find execution events jsonl under run_dir")
src/execution/replay_pack/builder.py:84:    raise FileNotFoundError("could not resolve run_id to an execution events jsonl file")
src/execution/replay_pack/builder.py:269:    write_jsonl_canonical(bundle_root / "events" / "execution_events.jsonl", events)
src/execution/replay_pack/builder.py:273:        from src.execution.ledger import LedgerEngine
src/execution/replay_pack/builder.py:274:        from src.execution.ledger.quantization import parse_symbol
src/execution/replay_pack/builder.py:299:        from src.execution.ledger.export import to_canonical_dict as slice2_snapshot_to_dict
src/execution/replay_pack/builder.py:300:        from src.execution.ledger.fifo_engine import FifoLedgerEngine
src/execution/replay_pack/builder.py:301:        from src.execution.ledger.models import FillEvent as Slice2FillEvent
src/execution/replay_pack/builder.py:302:        from src.execution.ledger.quantization import parse_symbol
src/execution/replay_pack/builder.py:425:            "has_execution_events": True,
src/webui/execution_watch_api_v0_2.py:11:- GET /api/execution/runs
src/webui/execution_watch_api_v0_2.py:12:- GET /api/execution/runs/{run_id}
src/webui/execution_watch_api_v0_2.py:13:- GET /api/execution/runs/{run_id}/events?limit=&cursor=
src/webui/execution_watch_api_v0_2.py:33:router = APIRouter(tags=["execution-watch-v0.2"])
src/webui/execution_watch_api_v0_2.py:105:    Read JSONL file and return raw event dicts for schema=execution_event_v0.
src/webui/execution_watch_api_v0_2.py:128:                if obj.get("schema") != "execution_event_v0":
src/webui/execution_watch_api_v0_2.py:212:        "peak_trade_execution_watch_requests_total",
src/webui/execution_watch_api_v0_2.py:217:        "peak_trade_execution_watch_request_latency_seconds",
src/webui/execution_watch_api_v0_2.py:223:        "peak_trade_execution_watch_read_errors_total",
src/webui/execution_watch_api_v0_2.py:406:    if root != "logs/execution" or filename != "execution_pipeline_events_v0.jsonl":
src/webui/execution_watch_api_v0_2.py:535:@router.get("/api/execution/runs", response_model=RunsListResponse)
src/webui/execution_watch_api_v0_2.py:536:async def api_execution_runs_v0_2(
src/webui/execution_watch_api_v0_2.py:538:    root: str = Query("logs/execution", description="JSONL root (read-only)"),
src/webui/execution_watch_api_v0_2.py:540:        "execution_pipeline_events_v0.jsonl", description="JSONL filename (read-only)"
src/webui/execution_watch_api_v0_2.py:597:            endpoint="/api/execution/runs",
src/webui/execution_watch_api_v0_2.py:604:@router.get("/api/execution/runs/{run_id}", response_model=RunDetailResponse)
src/webui/execution_watch_api_v0_2.py:605:async def api_execution_run_detail_v0_2(
src/webui/execution_watch_api_v0_2.py:607:    root: str = Query("logs/execution", description="JSONL root (read-only)"),
src/webui/execution_watch_api_v0_2.py:609:        "execution_pipeline_events_v0.jsonl", description="JSONL filename (read-only)"
src/webui/execution_watch_api_v0_2.py:620:            endpoint="/api/execution/runs/{run_id}",
src/webui/execution_watch_api_v0_2.py:661:            endpoint="/api/execution/runs/{run_id}",
src/webui/execution_watch_api_v0_2.py:668:@router.get("/api/execution/runs/{run_id}/events", response_model=RunEventsResponse)
src/webui/execution_watch_api_v0_2.py:669:async def api_execution_run_events_v0_2(
src/webui/execution_watch_api_v0_2.py:676:    root: str = Query("logs/execution", description="JSONL root (read-only)"),
src/webui/execution_watch_api_v0_2.py:678:        "execution_pipeline_events_v0.jsonl", description="JSONL filename (read-only)"
src/webui/execution_watch_api_v0_2.py:684:            endpoint="/api/execution/runs/{run_id}/events",
src/webui/execution_watch_api_v0_2.py:700:            endpoint="/api/execution/runs/{run_id}/events",
src/webui/execution_watch_api_v0_2.py:738:                endpoint="/api/execution/runs/{run_id}/events",
src/webui/execution_watch_api_v0_2.py:793:            endpoint="/api/execution/runs/{run_id}/events",
src/webui/execution_watch_api_v0_2.py:861:@router.get("/api/execution/health", response_model=ExecutionHealthResponse)
src/webui/execution_watch_api_v0_2.py:862:async def api_execution_health_v0_4(
src/webui/execution_watch_api_v0_2.py:863:    root: str = Query("logs/execution", description="JSONL root (read-only)"),
src/webui/execution_watch_api_v0_2.py:865:        "execution_pipeline_events_v0.jsonl", description="JSONL filename (read-only)"
src/webui/execution_watch_api_v0_2.py:935:            endpoint="/api/execution/health",
src/execution_simple/adapters/base.py:1:# src/execution_simple/adapters/base.py
src/execution_simple/adapters/base.py:23:    def execute_order(self, order: Order, context: ExecutionContext) -> Fill:
src/execution_simple/adapters/base.py:35:            Exception: If order execution fails
src/execution/risk_runtime/context.py:13:from src.execution.contracts import Order, Fill
src/execution/risk_runtime/context.py:131:        from src.execution.contracts import OrderState
src/execution_simple/builder.py:1:# src/execution_simple/builder.py
src/execution_simple/builder.py:18:def build_execution_pipeline_from_config(cfg: Any) -> ExecutionPipeline:
src/execution_simple/builder.py:24:    [execution]
src/execution_simple/builder.py:32:    [execution.gates]
src/execution_simple/builder.py:44:    # Get execution config with defaults
src/execution_simple/builder.py:45:    mode_str = cfg.get("execution.mode", "paper")
src/execution_simple/builder.py:46:    slippage_bps = float(cfg.get("execution.slippage_bps", 2.0))
src/execution_simple/builder.py:47:    fee_bps = float(cfg.get("execution.fee_bps", 0.0))
src/execution_simple/builder.py:48:    min_notional = float(cfg.get("execution.min_notional", 10.0))
src/execution_simple/builder.py:49:    lot_size = float(cfg.get("execution.lot_size", 0.0001))
src/execution_simple/builder.py:50:    min_qty = float(cfg.get("execution.min_qty", 0.0001))
src/execution_simple/builder.py:53:    block_research_in_live = bool(cfg.get("execution.gates.block_research_in_live", True))
src/execution_simple/builder.py:61:            f"Invalid execution mode: '{mode_str}'. Must be one of: {', '.join(valid_modes)}"
src/execution/reconciliation.py:21:from src.execution.contracts import ReconDiff, ReconSummary, OrderState
src/execution/reconciliation.py:22:from src.execution.position_ledger import PositionLedger, Position
src/execution/reconciliation.py:23:from src.execution.order_ledger import OrderLedger
src/execution/replay_pack/schema_v2.py:96:    if inv.get("has_execution_events") is not True:
src/execution/replay_pack/schema_v2.py:97:        raise SchemaValidationError("manifest invariants.has_execution_events must be true")
src/core/resilience.py:354:    Allows registration of health check functions and execution of all checks.
src/execution_simple/types.py:1:# src/execution_simple/types.py
src/execution_simple/types.py:5:Defines core types for order execution, gates, and results.
src/execution_simple/types.py:41:    Context for execution decisions.
src/execution_simple/types.py:139:    Result of execution pipeline run.
src/execution_simple/types.py:147:        blocked: Whether execution was blocked
src/execution_simple/types.py:161:        """Whether execution was successful (not blocked)."""
src/execution_simple/adapters/__init__.py:1:# src/execution_simple/adapters/__init__.py
src/execution_simple/adapters/__init__.py:2:"""Broker adapters for order execution."""
src/execution/risk_runtime/runtime.py:10:from src.execution.contracts import Order, Fill, LedgerEntry
src/execution/risk_runtime/runtime.py:11:from src.execution.risk_runtime.decisions import (
src/execution/risk_runtime/runtime.py:17:from src.execution.risk_runtime.context import (
src/execution/risk_runtime/runtime.py:21:from src.execution.risk_runtime.policies import RiskPolicy
src/core/experiments.py:983:    execution_summary: Optional[Dict[str, Any]] = None,
src/core/experiments.py:1001:        execution_summary: Zusammenfassung der Shadow-Execution
src/core/experiments.py:1018:        ...     execution_summary={
src/core/experiments.py:1036:    if execution_summary:
src/core/experiments.py:1037:        result_stats["execution"] = execution_summary
src/core/experiments.py:1048:        "runner": "run_shadow_execution.py",
src/core/experiments.py:1051:    if execution_summary:
src/core/experiments.py:1052:        metadata["execution_summary"] = execution_summary
src/execution/telemetry_health_trends.py:51:        from src.execution.telemetry_health import HealthReport
src/core/repro.py:4:Ensures deterministic execution for debugging and reproducibility.
src/execution_simple/adapters/simulated.py:1:# src/execution_simple/adapters/simulated.py
src/execution_simple/adapters/simulated.py:42:    def execute_order(self, order: Order, context: ExecutionContext) -> Fill:
src/live/ops/alerts.py:77:        "EXECUTION_ERROR": "docs/ops/runbooks/execution_error.md",
src/execution/risk_runtime/__init__.py:15:from src.execution.risk_runtime.decisions import (
src/execution/risk_runtime/__init__.py:20:from src.execution.risk_runtime.context import (
src/execution/risk_runtime/__init__.py:26:from src.execution.risk_runtime.policies import (
src/execution/risk_runtime/__init__.py:34:from src.execution.risk_runtime.runtime import (
src/execution_simple/gates.py:1:# src/execution_simple/gates.py
src/execution_simple/gates.py:5:Gates validate orders before execution and can block or modify orders.
src/execution_simple/gates.py:77:    Blocks LIVE execution for research-tagged strategies.
src/execution/replay_pack/contract_v2.py:58:    has_execution_events: bool
src/core/performance.py:8:- PerformanceMonitor: Tracks execution times and performance metrics
src/core/performance.py:9:- performance_timer: Decorator for timing function execution
src/core/performance.py:68:    Tracks execution times for operations and provides summary statistics.
src/core/performance.py:145:        Decorator for timing function execution.
src/core/performance.py:310:    Decorator for timing function execution using the global monitor.
src/execution/risk_runtime/decisions.py:12:from src.execution.contracts import Order
src/execution_simple/README.md:3:**Location:** `src/execution_simple/`  
src/execution_simple/README.md:4:**Purpose:** Simplified execution for legacy/backtest code  
src/execution_simple/README.md:5:**Status:** Legacy (use `src/execution/` for new code)
src/execution_simple/README.md:11:This module provides **simplified execution** for:
src/execution_simple/README.md:17:- âŒ Live trading (use `src/execution/` instead)
src/execution_simple/README.md:18:- âŒ Production code (use `src/execution/` instead)
src/execution_simple/README.md:22:## Relationship to `src/execution/`
src/execution_simple/README.md:24:See: `src/execution/README.md`
src/execution_simple/README.md:26:**Use `src/execution/` instead of this module for all new code.**
src/execution_simple/README.md:32:If you have code using `src/execution_simple/`, consider migrating to `src/execution/` for:
src/execution/live_session.py:1:# src/execution/live_session.py
src/execution/live_session.py:21:    >>> from src.execution.live_session import LiveSessionRunner, LiveSessionConfig
src/execution/live_session.py:974:            "pipeline_summary": self._pipeline.get_execution_summary(),
src/execution/replay_pack/runner.py:8:from src.execution.beta_bridge.schema import normalize_beta_exec_v1_event, sort_key_beta_exec_v1
src/execution/replay_pack/runner.py:9:from src.execution.ledger import LedgerEngine
src/execution/replay_pack/runner.py:10:from src.execution.ledger.quantization import parse_symbol
src/execution/replay_pack/runner.py:129:    events = list(bundle.execution_events())
src/execution_simple/__init__.py:1:# src/execution_simple/__init__.py
src/execution_simple/__init__.py:5:This is a simplified, standalone execution pipeline for learning and demos.
src/execution_simple/__init__.py:6:It demonstrates core execution concepts without the complexity of the full
src/execution_simple/__init__.py:7:production execution module (src/execution/).
src/execution_simple/__init__.py:10:- Learning execution concepts
src/execution_simple/__init__.py:14:For production, use: src/execution.pipeline (Phase 16A V2 - Governance-aware)
src/execution_simple/__init__.py:18:from .builder import build_execution_pipeline_from_config
src/execution_simple/__init__.py:56:    "build_execution_pipeline_from_config",
src/core/errors.py:192:        - Trade execution simulation errors
src/execution/order_state_machine.py:19:from src.execution.contracts import (
src/execution/order_state_machine.py:26:from src.execution.risk_hook import RiskHook, NullRiskHook
src/execution/order_state_machine.py:140:    def create_order(
src/execution/order_state_machine.py:161:        from src.execution.contracts import OrderSide, OrderType
src/execution/order_state_machine.py:201:    def submit_order(self, order: Order) -> StateMachineResult:
src/execution/replay_pack/validator.py:22:    validate_execution_event_object_strict,
src/execution/replay_pack/validator.py:83:    if "events/execution_events.jsonl" not in set(paths):
src/execution/replay_pack/validator.py:84:        raise SchemaValidationError("manifest.contents must include events/execution_events.jsonl")
src/execution/replay_pack/validator.py:138:    ev_path = root / "events" / "execution_events.jsonl"
src/execution/replay_pack/validator.py:139:    assert_lf_only_bytes(ev_path.read_bytes(), label="execution_events.jsonl")
src/execution/replay_pack/validator.py:148:                raise ContractViolationError(f"execution_events line {line_no} must be object")
src/execution/replay_pack/validator.py:149:            validate_execution_event_object_strict(obj, line_no=line_no)
src/execution/broker/base.py:17:from src.execution.contracts import Fill, Order, OrderState
src/execution/broker/base.py:52:    def place_order(self, order: Order, idempotency_key: str) -> str:
src/execution/broker/fake_broker.py:14:from src.execution.broker.base import BrokerOrderSnapshot, FillCursor
src/execution/broker/fake_broker.py:15:from src.execution.broker.errors import InvalidOrderError, OrderRejectedError
src/execution/broker/fake_broker.py:16:from src.execution.contracts import Fill, Order, OrderState, OrderType, validate_order
src/execution/broker/fake_broker.py:31:    - idempotent place_order via (idempotency_key -> broker_order_id)
src/execution/broker/fake_broker.py:46:    def place_order(self, order: Order, idempotency_key: str) -> str:
src/execution/risk_hook.py:4:This module defines the interface between execution and risk layer.
src/execution/risk_hook.py:5:NO cyclic imports - execution depends on contracts, risk depends on contracts.
src/execution/risk_hook.py:17:from src.execution.contracts import Order, RiskResult, RiskDecision
src/execution/ledger_mapper.py:18:from src.execution.contracts import LedgerEntry, Fill, OrderState
src/execution/ledger_mapper.py:21:    from src.execution.orchestrator import ExecutionEvent
src/execution/ledger_mapper.py:39:        execution_event: "ExecutionEvent",
src/execution/ledger_mapper.py:46:            execution_event: Execution event from adapter
src/execution/ledger_mapper.py:53:        if execution_event.event_type != "FILL":
src/execution/ledger_mapper.py:57:        fill = execution_event.fill
src/execution/ledger_mapper.py:66:            timestamp=execution_event.timestamp,
src/execution/ledger_mapper.py:69:            client_order_id=execution_event.order_id,
src/execution/ledger_mapper.py:74:                "exchange_order_id": execution_event.exchange_order_id,
src/core/peak_config.py:297:    # Explicit safety flag: treat as live-like for config layering (does NOT unlock execution)
src/core/peak_config.py:320:    execution behaviour; it only merges config values for live-like envs.
src/execution/paper/daily_summary.py:14:from src.execution.paper.journal import TradeJournal
src/execution/paper/daily_summary.py:15:from src.execution.position_ledger import PositionLedger
src/execution/broker/adapter.py:13:from src.execution.broker.base import Broker, BrokerOrderSnapshot, FillCursor
src/execution/broker/adapter.py:14:from src.execution.broker.idempotency import build_idempotency_key
src/execution/broker/adapter.py:15:from src.execution.broker.retry import RetryPolicy
src/execution/broker/adapter.py:16:from src.execution.contracts import Fill, Order, OrderState
src/execution/broker/adapter.py:24:    def place_order(self, order: Order, idempotency_key: str) -> str:
src/execution/broker/adapter.py:27:            lambda: self._broker.place_order(order=order, idempotency_key=stable)
src/infra/escalation/manager.py:144:                f"Error in escalation decision/execution: {e}",
src/execution/paper/__init__.py:7:from src.execution.paper.broker import PaperBroker, FillSimulationConfig
src/execution/paper/__init__.py:8:from src.execution.paper.engine import PaperExecutionEngine
src/execution/paper/__init__.py:9:from src.execution.paper.journal import TradeJournal, JournalEntry
src/execution/paper/__init__.py:10:from src.execution.paper.daily_summary import DailySummaryGenerator
src/execution/venue_adapters/base.py:4:Defines the OrderAdapter protocol for venue execution.
src/execution/venue_adapters/base.py:7:IMPORTANT: NO live execution. Adapters are for paper/shadow/testnet only.
src/execution/venue_adapters/base.py:12:from src.execution.contracts import Order
src/execution/venue_adapters/base.py:13:from src.execution.orchestrator import ExecutionEvent
src/execution/venue_adapters/base.py:18:    Protocol for order execution adapters.
src/execution/venue_adapters/base.py:21:    - execute_order: Submit order and return execution event (ACK/REJECT/FILL)
src/execution/venue_adapters/base.py:26:    - SimulatedVenueAdapter: Deterministic paper/shadow execution
src/execution/venue_adapters/base.py:27:    - (Future) LiveVenueAdapter: Real exchange execution (Phase 2+)
src/execution/venue_adapters/base.py:30:    def execute_order(self, order: Order, idempotency_key: str) -> ExecutionEvent:
src/execution/venue_adapters/base.py:32:        Execute order and return execution event.
src/execution/venue_adapters/base.py:42:            VenueAdapterError: If execution fails (network, timeout, etc.)
src/execution/venue_adapters/base.py:49:    Exception raised by venue adapters on execution failure.
src/execution/telemetry_health.py:17:P0 Guardrails: This file is protected by CODEOWNERS (execution review required).
src/execution/paper/journal.py:15:from src.execution.contracts import OrderSide, OrderState
src/execution/paper/broker.py:4:Simulates order execution with deterministic fills, slippage, and fees.
src/execution/paper/broker.py:15:from src.execution.contracts import Fill, Order, OrderSide, OrderState, OrderType
src/execution/paper/broker.py:61:        >>> fills = broker.submit_order(order, current_price=Decimal("50000"))
src/execution/paper/broker.py:84:    def submit_order(
src/infra/escalation/network_gate.py:36:    # Note: we do NOT require environment==LIVE here; live execution may be blocked by design,
src/execution/broker/retry.py:4:Differences vs `src/execution/retry_policy.py`:
src/execution/broker/retry.py:14:from src.execution.broker.errors import PermanentBrokerError, TransientBrokerError
src/execution/position_ledger.py:19:from src.execution.contracts import Fill, OrderSide
src/execution/position_ledger.py:159:        from src.execution.pipeline import DuplicateFillConflictError
src/execution/paper/engine.py:14:from src.execution.audit_log import AuditLog
src/execution/paper/engine.py:15:from src.execution.contracts import Fill, LedgerEntry, Order, OrderSide, OrderState, OrderType
src/execution/paper/engine.py:16:from src.execution.order_ledger import OrderLedger
src/execution/paper/engine.py:17:from src.execution.paper.broker import FillSimulationConfig, PaperBroker
src/execution/paper/engine.py:18:from src.execution.paper.journal import JournalEntry, TradeJournal
src/execution/paper/engine.py:19:from src.execution.position_ledger import PositionLedger
src/execution/paper/engine.py:20:from src.execution.risk_runtime.decisions import RiskDecision
src/execution/paper/engine.py:21:from src.execution.risk_runtime.runtime import RiskRuntime
src/execution/paper/engine.py:30:    Configuration for paper execution engine.
src/execution/paper/engine.py:51:    Paper execution engine with risk integration.
src/execution/paper/engine.py:63:        >>> order = engine.submit_order(...)
src/execution/paper/engine.py:73:        Initialize paper execution engine.
src/execution/paper/engine.py:102:            f"Paper execution engine initialized: "
src/execution/paper/engine.py:117:    def submit_order(
src/execution/paper/engine.py:218:        new_state, fills = self.broker.submit_order(order, current_price)
src/execution/venue_adapters/__init__.py:4:Provides venue execution adapters for different execution modes:
src/execution/venue_adapters/__init__.py:5:- SimulatedVenueAdapter: Deterministic paper/shadow execution
src/execution/venue_adapters/__init__.py:8:IMPORTANT: NO live execution. All adapters are for paper/shadow/testnet only.
src/execution/venue_adapters/__init__.py:9:           Live execution remains blocked/gated in Phase 0.
src/execution/venue_adapters/__init__.py:12:from src.execution.venue_adapters.base import OrderAdapter, VenueAdapterError
src/execution/venue_adapters/__init__.py:13:from src.execution.venue_adapters.simulated import SimulatedVenueAdapter
src/execution/venue_adapters/__init__.py:14:from src.execution.venue_adapters.registry import AdapterRegistry
src/execution/venue_adapters/__init__.py:15:from src.execution.venue_adapters.fill_models import (
src/live/shadow_session.py:59:from ..execution.pipeline import ExecutionPipeline, SignalEvent
src/live/shadow_session.py:475:        results = self._pipeline.execute_orders(orders)
src/live/shadow_session.py:745:    def get_execution_summary(self) -> Dict[str, Any]:
src/live/shadow_session.py:752:        pipeline_summary = self._pipeline.get_execution_summary()
src/execution/venue_adapters/fill_models.py:4:Provides deterministic fill/slippage/fee calculation models for paper/shadow execution.
src/execution/venue_adapters/fill_models.py:19:from src.execution.contracts import Order, OrderType, OrderSide
src/execution/broker/idempotency.py:13:from src.execution.contracts import Order
src/execution/metrics/__init__.py:6:from .execution_latency import (
src/execution/ledger/__init__.py:5:This package converts deterministic execution fill events into:
src/execution/ledger/__init__.py:17:from .execution_to_ledger import iter_beta_exec_v1_events
src/execution/__init__.py:1:# src/execution/__init__.py
src/execution/__init__.py:12:- OrderIntent: Order-Absicht fuer submit_order() (Phase 16A V2)
src/execution/__init__.py:24:- Governance-Integration via get_governance_status("live_order_execution")
src/execution/__init__.py:25:- live_order_execution ist gesperrt (status="locked")
src/execution/__init__.py:29:         live_order_execution ist governance-seitig gesperrt.
src/execution/ledger/engine_legacy.py:11:# src/execution/ledger/engine.py.
src/execution/ledger/engine_legacy.py:18:from src.execution.determinism import stable_id
src/execution/ledger/engine_legacy.py:78:    Deterministic legacy ledger engine that consumes execution events and produces:
src/execution/venue_adapters/registry.py:12:IMPORTANT: NO live execution. Registry only provides paper/shadow/testnet adapters.
src/execution/venue_adapters/registry.py:13:           Live execution remains blocked/gated in Phase 0.
src/execution/venue_adapters/registry.py:21:from src.execution.orchestrator import ExecutionMode
src/execution/venue_adapters/registry.py:22:from src.execution.venue_adapters.base import OrderAdapter, VenueAdapterError
src/execution/venue_adapters/registry.py:23:from src.execution.venue_adapters.simulated import SimulatedVenueAdapter
src/execution/venue_adapters/registry.py:35:        event = adapter.execute_order(order, idempotency_key)
src/execution/venue_adapters/registry.py:51:        Register adapter for execution mode.
src/execution/venue_adapters/registry.py:70:        Get adapter for execution mode.
src/execution/venue_adapters/registry.py:84:                f"Live execution is governance-blocked (Phase 0). Mode={mode.value} is not allowed."
src/execution/order_ledger.py:18:from src.execution.contracts import Order, OrderState
src/docs/trading_bot_notes.md:72:â”‚  â”œâ”€ execution/
src/execution/venue_adapters/simulated.py:4:Provides deterministic paper/shadow execution simulation.
src/execution/venue_adapters/simulated.py:9:- Fast: No network I/O, instant execution
src/execution/venue_adapters/simulated.py:12:IMPORTANT: NO live execution. This adapter is for paper/shadow/testnet only.
src/execution/venue_adapters/simulated.py:22:from src.execution.contracts import Order, OrderSide, OrderType, Fill
src/execution/venue_adapters/simulated.py:23:from src.execution.orchestrator import ExecutionEvent
src/execution/venue_adapters/simulated.py:24:from src.execution.venue_adapters.base import VenueAdapterError
src/execution/venue_adapters/simulated.py:25:from src.execution.venue_adapters.fill_models import (
src/execution/venue_adapters/simulated.py:39:    Simulated venue adapter for deterministic paper/shadow execution.
src/execution/venue_adapters/simulated.py:45:    - No network I/O (instant execution)
src/execution/venue_adapters/simulated.py:93:    def execute_order(self, order: Order, idempotency_key: str) -> ExecutionEvent:
src/execution/venue_adapters/simulated.py:113:            VenueAdapterError: If execution fails
src/execution/venue_adapters/simulated.py:209:        Validate order before execution.
src/execution/telemetry.py:1:# src/execution/telemetry.py
src/execution/telemetry.py:5:Phase 16B: Pluggable telemetry backends for execution events.
src/execution/telemetry.py:23:    Abstract base for execution event emitters.
src/execution/telemetry.py:32:        Emit an execution event.
src/execution/telemetry.py:54:    JSONL file logger for execution events.
src/execution/telemetry.py:56:    Appends events to logs/execution/<session_id>.jsonl.
src/execution/telemetry.py:62:        logger = JsonlExecutionLogger("logs/execution")
src/execution/telemetry.py:64:        # Creates: logs/execution/<session_id>.jsonl
src/execution/telemetry.py:67:    def __init__(self, base_path: str = "logs/execution", *, fixed_filename: Optional[str] = None):
src/execution/telemetry.py:72:            base_path: Base directory for execution logs
src/execution/telemetry.py:74:                           (e.g. "execution_events.jsonl") instead of <session_id>.jsonl.
src/execution/telemetry.py:104:            logger.error(f"Failed to emit execution event: {e}")
src/execution/telemetry.py:112:      logs/execution/execution_events.jsonl
src/execution/README.md:3:**Location:** `src/execution/`  
src/execution/README.md:4:**Purpose:** Production execution pipeline with full feature set  
src/execution/README.md:11:This module provides the **full-featured execution pipeline** for:
src/execution/README.md:22:## Relationship to `src/execution_simple/`
src/execution/README.md:24:| Aspect | `src/execution/` (This Module) | `src/execution_simple/` |
src/execution/README.md:26:| **Purpose** | Production execution | Simplified/legacy |
src/execution/README.md:31:**Recommendation:** Use `src/execution/` for all new code. `src/execution_simple/` appears to be legacy.
src/execution/README.md:38:Main execution orchestration:
src/execution/README.md:40:- Order generation and execution
src/execution/README.md:52:- Fill (execution details)
src/execution/README.md:68:from src.execution.pipeline import ExecutionPipeline
src/execution/README.md:74:results = pipeline.execute_orders([order1, order2])
src/execution/README.md:81:**Use this module (`src/execution/`)** for live trading.
src/execution/risk_hook_impl.py:10:from src.execution.contracts import Order, RiskResult, RiskDecision as ContractRiskDecision
src/execution/risk_hook_impl.py:11:from src.execution.risk_runtime import RiskRuntime
src/execution/risk_hook_impl.py:12:from src.execution.risk_runtime.decisions import RiskDecision as RuntimeRiskDecision
src/execution/risk_hook_impl.py:154:        from src.execution.contracts import OrderSide
src/execution/beta_bridge/bridge.py:9:from src.execution.ledger import LedgerEngine
src/execution/contracts.py:4:This module defines the core data types and protocols for the live execution system.
src/execution/contracts.py:5:These types are STABLE and form the contract between execution components.
src/execution/ledger/engine.py:8:from src.execution.determinism import stable_id
src/execution/ledger/engine.py:68:    Deterministic ledger engine that consumes execution events and produces:
src/execution/telemetry_viewer.py:1:# src/execution/telemetry_viewer.py
src/execution/telemetry_viewer.py:3:Telemetry Viewer - Read-only queries for execution event logs.
src/execution/telemetry_viewer.py:6:execution telemetry without modifying logs.
src/execution/telemetry_viewer.py:84:        >>> paths = [Path("logs/execution/session_123.jsonl")]
src/execution/telemetry_viewer.py:306:def find_session_logs(base_path: Path = Path("logs/execution")) -> List[Path]:
src/execution/telemetry_viewer.py:311:        base_path: Base directory for execution logs
src/execution/bridge/int_ledger_engine.py:26:    - Production accounting continues to use src.execution.ledger.LedgerEngine.
src/live/broker_base.py:21:    def submit_orders(self, orders: Sequence[LiveOrderRequest]) -> List[LiveExecutionReport]:
src/live/broker_base.py:50:    def submit_orders(self, orders: Sequence[LiveOrderRequest]) -> List[LiveExecutionReport]:
src/live/broker_base.py:266:    def submit_orders(self, orders: Sequence[LiveOrderRequest]) -> List[LiveExecutionReport]:
src/live/alert_pipeline.py:1001:    def send_execution_alert(
src/execution/live/orchestrator.py:18:from src.execution.determinism import SimClock, stable_id
src/execution/live/orchestrator.py:308:            # Dryrun execution (bounded steps; no external deps)
src/live/testnet_orchestrator.py:252:        from ..execution.pipeline import ExecutionPipeline
src/exchange/base.py:271:        >>> order_id = client.place_order(
src/exchange/base.py:293:    def place_order(
src/live/audit.py:33:from src.live.safety import SafetyGuard, is_live_execution_allowed
src/live/audit.py:109:        is_live_execution_allowed: Ergebnis von is_live_execution_allowed()
src/live/audit.py:114:    is_live_execution_allowed: bool
src/live/audit.py:219:    allowed, reason = is_live_execution_allowed(env_config)
src/live/audit.py:237:        is_live_execution_allowed=allowed,
src/live/audit.py:299:            "is_live_execution_allowed": snapshot.safety.is_live_execution_allowed,
src/live/audit.py:369:    lines.append(f"- **is_live_execution_allowed:** {snapshot.safety.is_live_execution_allowed}")
src/execution/orchestrator.py:4:Implements the 8-stage execution pipeline from Intent to Recon Hand-off.
src/execution/orchestrator.py:10:4. Route Selection - Select adapter based on execution mode (paper/shadow/testnet/live_blocked)
src/execution/orchestrator.py:24:IMPORTANT: NO live execution. Default remains blocked/gated.
src/execution/orchestrator.py:44:from src.execution.contracts import (
src/execution/orchestrator.py:56:from src.execution.risk_hook import RiskHook, NullRiskHook
src/execution/orchestrator.py:57:from src.execution.order_state_machine import OrderStateMachine, StateMachineResult
src/execution/orchestrator.py:58:from src.execution.order_ledger import OrderLedger
src/execution/orchestrator.py:59:from src.execution.position_ledger import PositionLedger
src/execution/orchestrator.py:60:from src.execution.audit_log import AuditLog
src/execution/orchestrator.py:61:from src.execution.retry_policy import RetryPolicy, RetryConfig
src/execution/orchestrator.py:62:from src.execution.ledger_mapper import EventToLedgerMapper
src/execution/orchestrator.py:63:from src.execution.reconciliation import ReconciliationEngine
src/execution/orchestrator.py:64:from src.execution.determinism import SimClock, seed_u64, stable_id
src/execution/orchestrator.py:65:from src.execution.telemetry import FixedJsonlAppendOnlyWriter
src/execution/orchestrator.py:92:        SHADOW: Shadow mode (dry-run, no real execution)
src/execution/orchestrator.py:111:    - ADAPTER_*: Adapter execution failures
src/execution/orchestrator.py:181:    Result of pipeline execution.
src/execution/orchestrator.py:213:    Protocol for order execution adapters (WP0C).
src/execution/orchestrator.py:218:    def execute_order(self, order: Order, idempotency_key: str) -> "ExecutionEvent":
src/execution/orchestrator.py:220:        Execute order and return execution event.
src/execution/orchestrator.py:263:    Always returns ACK immediately (simulates instant execution).
src/execution/orchestrator.py:266:    def execute_order(self, order: Order, idempotency_key: str) -> ExecutionEvent:
src/execution/orchestrator.py:284:    Orchestrates the 8-stage execution pipeline:
src/execution/orchestrator.py:302:    IMPORTANT: NO live execution. Default remains blocked/gated.
src/execution/orchestrator.py:310:        execution_mode: ExecutionMode = ExecutionMode.PAPER,
src/execution/orchestrator.py:318:        execution_events_log_path: str = "logs/execution/execution_events.jsonl",
src/execution/orchestrator.py:321:        Initialize execution orchestrator.
src/execution/orchestrator.py:325:            adapter: Order execution adapter (defaults to NullAdapter)
src/execution/orchestrator.py:330:            execution_mode: Execution mode (paper/shadow/testnet/live_blocked)
src/execution/orchestrator.py:338:        self.execution_mode = execution_mode
src/execution/orchestrator.py:345:        self._beta_log_writer = FixedJsonlAppendOnlyWriter(Path(execution_events_log_path))
src/execution/orchestrator.py:370:    # RUNBOOK B / Slice 1: Deterministic event logging (execution_events.jsonl)
src/execution/orchestrator.py:410:        event_id = stable_id(kind="execution_event", fields=canonical_fields)
src/execution/orchestrator.py:444:        4. Route Selection - Select adapter based on execution mode
src/execution/orchestrator.py:489:        _ai_record_action(action="intent_intake", component="execution", run_id=run_id)
src/execution/orchestrator.py:525:                    component="execution",
src/execution/orchestrator.py:557:                    component="execution",
src/execution/orchestrator.py:579:                    component="execution",
src/execution/orchestrator.py:595:                    component="execution",
src/execution/orchestrator.py:610:                    component="execution",
src/execution/orchestrator.py:622:            execution_event = dispatch_result.metadata.get("execution_event")
src/execution/orchestrator.py:623:            assert execution_event is not None
src/execution/orchestrator.py:626:            event_result = self._stage_6_event_handling(order, execution_event, correlation_id)
src/execution/orchestrator.py:633:                order, execution_event, correlation_id, event_result.metadata
src/execution/orchestrator.py:659:                component="execution",
src/execution/orchestrator.py:758:        sm_result = self.state_machine.create_order(
src/execution/orchestrator.py:844:                # Add to ledger (includes ORDER_CREATED from create_order in Stage 2)
src/execution/orchestrator.py:891:        Select adapter based on execution mode and policy.
src/execution/orchestrator.py:911:            f"mode={self.execution_mode.value}"
src/execution/orchestrator.py:915:        if self.execution_mode == ExecutionMode.LIVE_BLOCKED:
src/execution/orchestrator.py:918:                f"Live execution is governance-blocked in Phase 0"
src/execution/orchestrator.py:923:                order, reason="Live execution not enabled (Phase 0)"
src/execution/orchestrator.py:936:                reason_detail="Live execution is governance-blocked (Phase 0 default)",
src/execution/orchestrator.py:945:                selected_adapter = self.adapter_registry.get_adapter(self.execution_mode)
src/execution/orchestrator.py:948:                    f"mode={self.execution_mode.value}, "
src/execution/orchestrator.py:1008:            PipelineResult with execution_event in metadata
src/execution/orchestrator.py:1013:        sm_result = self.state_machine.submit_order(order)
src/execution/orchestrator.py:1057:            execution_event = adapter.execute_order(order, idempotency_key)
src/execution/orchestrator.py:1062:                f"event_type={execution_event.event_type}"
src/execution/orchestrator.py:1072:                metadata={"execution_event": execution_event},
src/execution/orchestrator.py:1096:        self, order: Order, execution_event: ExecutionEvent, correlation_id: str
src/execution/orchestrator.py:1101:        Process execution event from adapter:
src/execution/orchestrator.py:1109:            execution_event: Execution event from adapter
src/execution/orchestrator.py:1117:            f"event_type={execution_event.event_type}"
src/execution/orchestrator.py:1120:        event_type = execution_event.event_type
src/execution/orchestrator.py:1125:                order, exchange_order_id=execution_event.exchange_order_id or "unknown"
src/execution/orchestrator.py:1143:                            "exchange_order_id": execution_event.exchange_order_id or "unknown"
src/execution/orchestrator.py:1158:                order, reason=execution_event.reject_reason or "Rejected by adapter"
src/execution/orchestrator.py:1176:                        reason_detail=(execution_event.reject_reason or "Rejected by adapter")[
src/execution/orchestrator.py:1185:                reason_detail=execution_event.reject_reason or "Rejected by adapter",
src/execution/orchestrator.py:1193:            fill = execution_event.fill
src/execution/orchestrator.py:1208:                    order, exchange_order_id=execution_event.exchange_order_id or "unknown"
src/execution/orchestrator.py:1225:                                "exchange_order_id": execution_event.exchange_order_id or "unknown"
src/execution/orchestrator.py:1299:        execution_event: ExecutionEvent,
src/execution/orchestrator.py:1313:            execution_event: Execution event
src/execution/orchestrator.py:1323:        if execution_event.event_type == "FILL":
src/execution/orchestrator.py:1324:            # Get fill from execution event
src/execution/orchestrator.py:1325:            fill = execution_event.fill
src/execution/orchestrator.py:1351:                    execution_event=execution_event,
src/execution/orchestrator.py:1441:            # Reconciliation failure is not critical (does not block order execution)
src/exchange/__init__.py:16:- Order-Platzierung (place_order)
src/exchange/__init__.py:29:    order_id = trading_client.place_order("BTC/EUR", "buy", 0.01, "market")
src/exchange/__init__.py:132:        >>> order_id = client.place_order("BTC/EUR", "buy", 0.01, "market")
src/risk_layer/risk_gate.py:14:from src.execution_simple.types import Order
src/risk_layer/README.md:50:- `execution_gate.py` - ExecutionGate (blocks orders when killed)
src/risk_layer/README.md:70:# Create execution gate
src/risk_layer/README.md:167:- `src/execution/pipeline.py` - ExecutionPipeline respects execution gate
src/risk_layer/README.md:280:â”‚   â”œâ”€â”€ execution_gate.py
src/exchange/kraken_testnet.py:276:        >>> txid = client.create_order(order)
src/exchange/kraken_testnet.py:497:    def create_order(self, order: OrderRequest) -> str:
src/exchange/kraken_testnet.py:515:            f"[KRAKEN TESTNET] create_order: "
src/reporting/__init__.py:10:- execution_reports: ExecutionStats und Analyse-Funktionen (Phase 16D)
src/reporting/__init__.py:11:- execution_plots: Visualisierungen fuer Execution-Daten (optional)
src/reporting/__init__.py:22:from .execution_reports import (
src/reporting/__init__.py:24:    from_execution_logs,
src/reporting/__init__.py:25:    from_execution_results,
src/reporting/__init__.py:27:    format_execution_stats,
src/reporting/__init__.py:156:    "from_execution_logs",
src/reporting/__init__.py:157:    "from_execution_results",
src/reporting/__init__.py:159:    "format_execution_stats",
src/exchange/dummy_client.py:22:    >>> order_id = client.place_order("BTC/EUR", "buy", 0.01, "market")
src/exchange/dummy_client.py:112:        >>> order_id = client.place_order("BTC/EUR", "buy", 0.01, "market")
src/exchange/dummy_client.py:158:    def place_order(
src/risk_layer/adapters.py:12:from src.execution_simple.types import Order, OrderSide, OrderType
src/reporting/execution_plots.py:1:# src/reporting/execution_plots.py
src/reporting/execution_plots.py:38:    from .execution_reports import ExecutionStats
src/reporting/execution_plots.py:338:def plot_execution_summary(
src/risk_layer/kill_switch/execution_gate.py:12:    """Protocol for execution gate.
src/risk_layer/kill_switch/execution_gate.py:14:    This defines the contract that any execution gate must implement.
src/risk_layer/kill_switch/execution_gate.py:18:        """Check if execution is allowed.
src/risk_layer/kill_switch/execution_gate.py:30:    """Gate for order execution.
src/risk_layer/kill_switch/execution_gate.py:32:    Integrates kill switch with the execution layer.
src/risk_layer/kill_switch/execution_gate.py:51:        """Initialize execution gate.
src/risk_layer/kill_switch/execution_gate.py:59:        """Check if execution is allowed.
src/risk_layer/kill_switch/execution_gate.py:62:            True if execution allowed
src/risk_layer/kill_switch/execution_gate.py:91:        """Check if execution is blocked (without raising exception).
src/reporting/execution_reports.py:1:# src/reporting/execution_reports.py
src/reporting/execution_reports.py:11:- from_execution_logs(): Erzeugt ExecutionStats aus Engine-Logs
src/reporting/execution_reports.py:12:- from_execution_results(): Erzeugt ExecutionStats aus OrderExecutionResult-Liste
src/reporting/execution_reports.py:171:def from_execution_logs(logs: List[Dict[str, Any]]) -> ExecutionStats:
src/reporting/execution_reports.py:175:    Die Logs stammen von BacktestEngine.get_execution_logs() und enthalten
src/reporting/execution_reports.py:179:        logs: Liste von Log-Dictionaries aus get_execution_logs()
src/reporting/execution_reports.py:185:        >>> engine = BacktestEngine(use_execution_pipeline=True, log_executions=True)
src/reporting/execution_reports.py:187:        >>> logs = engine.get_execution_logs()
src/reporting/execution_reports.py:188:        >>> stats = from_execution_logs(logs)
src/reporting/execution_reports.py:261:def from_execution_results(
src/reporting/execution_reports.py:268:    Diese Funktion bietet detailliertere Auswertung als from_execution_logs(),
src/reporting/execution_reports.py:272:        results: Liste von OrderExecutionResult aus BacktestEngine.execution_results
src/reporting/execution_reports.py:281:        >>> engine = BacktestEngine(use_execution_pipeline=True)
src/reporting/execution_reports.py:283:        >>> stats = from_execution_results(engine.execution_results)
src/reporting/execution_reports.py:422:    execution_results: Optional[Sequence["OrderExecutionResult"]] = None,
src/reporting/execution_reports.py:432:        execution_results: Optionale Liste von OrderExecutionResult fuer
src/reporting/execution_reports.py:440:        >>> engine = BacktestEngine(use_execution_pipeline=True)
src/reporting/execution_reports.py:442:        >>> stats = from_backtest_result(result, engine.execution_results)
src/reporting/execution_reports.py:462:    # Wenn execution_results vorhanden, detailliertere Stats berechnen
src/reporting/execution_reports.py:463:    if execution_results:
src/reporting/execution_reports.py:464:        detailed_stats = from_execution_results(execution_results)
src/reporting/execution_reports.py:495:    # Ohne execution_results: nur aggregierte Stats
src/reporting/execution_reports.py:515:def format_execution_stats(
src/reporting/execution_reports.py:536:        >>> stats = from_execution_logs(logs)
src/reporting/execution_reports.py:537:        >>> print(format_execution_stats(stats))
src/risk_layer/alerting/alert_types.py:62:    EXECUTION_ERROR = "execution_error"
src/reporting/trigger_training_report.py:402:def _build_execution_latency_section_html(
src/reporting/trigger_training_report.py:870:        latency_html = _build_execution_latency_section_html(latency_summary)
src/risk_layer/kill_switch/__init__.py:37:from .execution_gate import ExecutionGate
