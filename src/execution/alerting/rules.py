"""
Alert Rules - Phase 16I

Rule definitions and evaluation logic for telemetry alerting.
"""

import logging
from dataclasses import dataclass
from datetime import datetime, timezone
from enum import Enum
from typing import Any, Callable, Dict, List, Optional

from .models import AlertEvent, AlertSeverity

logger = logging.getLogger(__name__)


class RuleType(str, Enum):
    """Types of alert rules."""
    
    HEALTH_CHECK = "health_check"  # Triggered by health check results
    DEGRADATION = "degradation"    # Triggered by degradation detection
    LEADING_INDICATOR = "leading_indicator"  # Triggered by leading indicator breach


@dataclass
class AlertRule:
    """
    Alert rule definition.
    
    Attributes:
        rule_id: Unique rule identifier
        enabled: Whether rule is active
        rule_type: Type of rule (health_check, degradation, leading_indicator)
        severity: Severity of alerts generated by this rule
        title_template: Alert title template (supports {placeholders})
        body_template: Alert body template (supports {placeholders})
        predicate: Function that evaluates if rule should fire
        cooldown_seconds: Minimum time between alerts from same rule
        dedupe_window_seconds: Time window for deduplication
        labels: Static labels to attach to alerts
    """
    
    rule_id: str
    enabled: bool
    rule_type: RuleType
    severity: AlertSeverity
    title_template: str
    body_template: str
    predicate: Callable[[Dict[str, Any]], bool]
    
    cooldown_seconds: int = 300  # 5 minutes default
    dedupe_window_seconds: int = 900  # 15 minutes default
    labels: Dict[str, str] = None
    
    def __post_init__(self):
        """Initialize defaults."""
        if self.labels is None:
            self.labels = {}
        
        # Ensure types
        if isinstance(self.rule_type, str):
            self.rule_type = RuleType(self.rule_type)
        if isinstance(self.severity, str):
            self.severity = AlertSeverity(self.severity)
    
    def evaluate(self, context: Dict[str, Any]) -> Optional[AlertEvent]:
        """
        Evaluate rule against context.
        
        Args:
            context: Evaluation context (health_report, trend_report, etc.)
        
        Returns:
            AlertEvent if rule fires, None otherwise
        """
        if not self.enabled:
            return None
        
        try:
            if not self.predicate(context):
                return None
            
            # Rule fired - create alert
            title = self.title_template.format(**context)
            body = self.body_template.format(**context)
            
            alert = AlertEvent(
                source=f"rule:{self.rule_id}",
                severity=self.severity,
                title=title,
                body=body,
                labels={
                    **self.labels,
                    "rule_id": self.rule_id,
                    "rule_type": self.rule_type.value,
                },
                dedupe_key=f"{self.rule_id}:{title}",
                sample_payload={"context": context},
            )
            
            return alert
        
        except Exception as e:
            logger.error(f"Error evaluating rule {self.rule_id}: {e}", exc_info=True)
            return None


# =============================================================================
# BUILT-IN RULES
# =============================================================================

def rule_health_check_critical(context: Dict[str, Any]) -> bool:
    """Rule: Health check critical status."""
    health_report = context.get("health_report")
    if not health_report:
        return False
    
    # Check if overall status is critical
    status = health_report.get("status", "ok")
    return status == "critical"


def rule_degradation_detected(context: Dict[str, Any]) -> bool:
    """Rule: Degradation detected in trends."""
    degradation = context.get("degradation")
    if not degradation:
        return False
    
    return degradation.get("degrading", False)


def rule_leading_indicator_disk_growth(context: Dict[str, Any]) -> bool:
    """Rule: Disk usage growing rapidly (leading indicator)."""
    degradation = context.get("degradation")
    if not degradation:
        return False
    
    reasons = degradation.get("reasons", [])
    
    # Check if any reason mentions disk usage increasing
    return any("disk usage increasing" in str(r).lower() for r in reasons)


def rule_parse_error_rate_high(context: Dict[str, Any]) -> bool:
    """Rule: Parse error rate above threshold."""
    health_report = context.get("health_report")
    if not health_report:
        return False
    
    checks = health_report.get("checks", [])
    
    for check in checks:
        if check.get("name") == "parse_error_rate":
            value = check.get("value", 0.0)
            # Alert if parse error rate > 5%
            return value > 5.0
    
    return False


# =============================================================================
# DEFAULT RULES
# =============================================================================

DEFAULT_RULES = [
    AlertRule(
        rule_id="health_critical",
        enabled=True,
        rule_type=RuleType.HEALTH_CHECK,
        severity=AlertSeverity.CRITICAL,
        title_template="Telemetry Health Check CRITICAL",
        body_template=(
            "Telemetry health check status is CRITICAL.\n"
            "Overall status: {health_status}\n"
            "Please investigate immediately."
        ),
        predicate=rule_health_check_critical,
        cooldown_seconds=300,
        dedupe_window_seconds=900,
        labels={"category": "health"},
    ),
    AlertRule(
        rule_id="degradation_detected",
        enabled=True,
        rule_type=RuleType.DEGRADATION,
        severity=AlertSeverity.WARN,
        title_template="Telemetry Health Degradation Detected",
        body_template=(
            "Telemetry health degradation detected.\n"
            "Reasons: {degradation_reasons}\n"
            "Critical count: {degradation_critical_count}\n"
            "Warn count: {degradation_warn_count}\n"
            "Window size: {degradation_window_size} snapshots\n"
            "Action: Review recent health trends and apply retention/cleanup if needed."
        ),
        predicate=rule_degradation_detected,
        cooldown_seconds=600,  # 10 minutes (less urgent than critical)
        dedupe_window_seconds=1800,  # 30 minutes
        labels={"category": "degradation"},
    ),
    AlertRule(
        rule_id="leading_indicator_disk_growth",
        enabled=True,
        rule_type=RuleType.LEADING_INDICATOR,
        severity=AlertSeverity.WARN,
        title_template="Leading Indicator: Disk Usage Growing",
        body_template=(
            "Disk usage is growing rapidly (leading indicator).\n"
            "This may predict capacity issues 2-4 weeks ahead.\n"
            "Reasons: {degradation_reasons}\n"
            "Action: Review retention policy or plan capacity expansion."
        ),
        predicate=rule_leading_indicator_disk_growth,
        cooldown_seconds=3600,  # 1 hour (long-term trend)
        dedupe_window_seconds=7200,  # 2 hours
        labels={"category": "leading_indicator", "metric": "disk_growth"},
    ),
    AlertRule(
        rule_id="parse_error_rate_high",
        enabled=True,
        rule_type=RuleType.HEALTH_CHECK,
        severity=AlertSeverity.WARN,
        title_template="Parse Error Rate Above Threshold",
        body_template=(
            "Parse error rate is above 5%.\n"
            "This indicates data quality issues.\n"
            "Action: Investigate recent telemetry sessions for corrupted logs."
        ),
        predicate=rule_parse_error_rate_high,
        cooldown_seconds=600,
        dedupe_window_seconds=1800,
        labels={"category": "data_quality"},
    ),
]
